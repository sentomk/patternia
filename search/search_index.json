{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Patternia Documentation","text":"<p>A modern C++ pattern matching DSL</p> <p>Patternia is a modern C++ pattern-matching DSL designed to make dispatch logic clear, expressive, and type-safe \u2014 without sacrificing performance or compilation efficiency.</p>"},{"location":"#navigation","title":"Navigation","text":""},{"location":"#quick-start","title":"Quick Start","text":"<ul> <li>Installation - How to integrate Patternia into your project</li> <li>Getting Started - Complete examples from basics to advanced</li> </ul>"},{"location":"#pattern-system","title":"Pattern System","text":"<ul> <li>Pattern System Overview - Understand Patternia's design philosophy</li> <li>Value Patterns - Value matching with literals, case-insensitive strings, predicates</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>API Documentation - Complete API reference for all functions and patterns</li> </ul>"},{"location":"#project-information","title":"Project Information","text":"<ul> <li>Roadmap - Future development directions and plans</li> <li>Releases - Version update history</li> </ul>"},{"location":"#core-features","title":"Core Features","text":"<ul> <li>Header-only: Zero dependencies, plug-and-play</li> <li>Declarative Syntax: <code>match().when().otherwise()</code> chaining</li> <li>Type Safety: Compile-time guarantees, zero runtime overhead</li> <li>Rich Patterns: Literal patterns, case-insensitive patterns, predicate patterns</li> <li>DSL Operators: <code>&gt;&gt;</code> for pattern-handler binding</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>#include &lt;ptn/patternia.hpp&gt;\nusing namespace ptn;\n\nint x = 42;\n\nauto result =\n    match(x)\n      .when(lit(0) &gt;&gt; \"zero\")\n      .when(lit(42) &gt;&gt; \"answer\")\n      .otherwise(\"other\");\n</code></pre> <p>Patternia evaluates patterns in order and returns the result associated with the first successful match.</p>"},{"location":"#where-to-start","title":"Where to Start","text":"<p>If you're new to Patternia, we recommend reading in this order:</p> <ol> <li>Installation - Integrate into your project</li> <li>Getting Started - Learn basic usage</li> <li>Value Patterns - Deep dive into value matching patterns</li> </ol> <p>If you're looking for specific information:</p> <ul> <li>Need a function reference? \u2192 API Documentation</li> <li>Want to understand design philosophy? \u2192 Pattern System Overview</li> <li>Check version updates? \u2192 Releases</li> </ul>"},{"location":"#system-requirements","title":"System Requirements","text":"<ul> <li>C++ Standard: C++17 or later</li> <li>Compilers: GCC \u226511, Clang \u226512, MSVC \u22652019</li> <li>Platforms: Linux, Windows, macOS</li> </ul> Make logical structure explicit, make C++ code more elegant"},{"location":"api/","title":"Patternia API Reference","text":""},{"location":"api/#namespace-structure-overview","title":"Namespace Structure Overview","text":"<p>Patternia adopts a layered namespace design, primarily containing the following namespaces:</p> <pre><code>ptn/                                    // Root namespace\n\u251c\u2500\u2500 core/                              // Core matching engine\n\u2502   \u251c\u2500\u2500 engine/                        // Matching engine implementation\n\u2502   \u251c\u2500\u2500 dsl/                          // DSL operators\n\u2502   \u2514\u2500\u2500 common/                       // Common utilities and traits\n\u251c\u2500\u2500 pat/                              // Pattern definitions\n\u2502   \u251c\u2500\u2500 base/                         // Pattern base classes\n\u2502   \u251c\u2500\u2500 lit.hpp                        // Literal pattern implementation\n\u2502   \u2514\u2500\u2500 bind.hpp                       // Binding pattern implementation\n\u2514\u2500\u2500 meta/                             // Meta programming tools\n    \u251c\u2500\u2500 base/                         // Base traits\n    \u251c\u2500\u2500 dsa/                          // Data structures and algorithms\n    \u2514\u2500\u2500 query/                        // Query utilities\n</code></pre>"},{"location":"api/#main-namespace-aliases","title":"Main Namespace Aliases","text":"<p>For user convenience, Patternia provides all pattern functions directly in the <code>ptn</code> namespace:</p> <pre><code>namespace ptn {\n  // lit, lit_ci, bind are available directly\n}\n</code></pre>"},{"location":"api/#core-matching-engine-api","title":"Core Matching Engine API","text":""},{"location":"api/#main-entry-functions","title":"Main Entry Functions","text":""},{"location":"api/#ptnmatchvalue","title":"<code>ptn::match(value)</code>","text":"<p>Type-deduced matching entry point that automatically deduces the value type.</p> <pre><code>template &lt;typename T&gt;\nconstexpr auto match(T &amp;&amp;value);\n</code></pre> <p>Parameters: - <code>value</code> - Value to match (forwarding reference)</p> <p>Returns: <code>match_builder</code> object for chained calls to <code>.when()</code> and <code>.otherwise()</code></p> <p>Example: <pre><code>int x = 42;\nauto result = match(x)\n    .when(lit(42) &gt;&gt; \"answer\")\n    .otherwise(\"other\");\n</code></pre></p>"},{"location":"api/#ptnmatchuvalue","title":"<code>ptn::match&lt;U&gt;(value)</code>","text":"<p>Explicit type-specified matching entry point that forces conversion to target type.</p> <pre><code>template &lt;typename U, typename T&gt;\nconstexpr auto match(T &amp;&amp;value);\n</code></pre> <p>Parameters: - <code>U</code> - Target type - <code>value</code> - Value to match</p> <p>Constraints: Type U must be constructible from value</p> <p>Example: <pre><code>double d = 3.14;\nauto result = match&lt;int&gt;(d)  // Force convert to int\n    .when(lit(3) &gt;&gt; \"three\")\n    .otherwise(\"other\");\n</code></pre></p>"},{"location":"api/#match-builder-api","title":"Match Builder API","text":""},{"location":"api/#match_builderwhenpattern-handler","title":"<code>match_builder::when(pattern &gt;&gt; handler)</code>","text":"<p>Add a matching branch.</p> <p>Syntax: <pre><code>.when(pattern &gt;&gt; handler)\n</code></pre></p> <p>Parameters: - <code>pattern</code> - Any pattern object - <code>handler</code> - Handler function or value</p> <p>Returns: New <code>match_builder</code> object (supports chained calls)</p>"},{"location":"api/#match_builderotherwisehandler","title":"<code>match_builder::otherwise(handler)</code>","text":"<p>Add a default branch.</p> <p>Syntax: <pre><code>.otherwise(handler)\n</code></pre></p> <p>Parameters: - <code>handler</code> - Default handler function or value</p> <p>Returns: Match result</p>"},{"location":"api/#value-pattern-api","title":"Value Pattern API","text":"<p>Note</p> <p><code>ptn::pat::lit</code>, <code>ptn::pat::lit_ci</code>, and <code>ptn::pat::bind</code> are available directly in <code>ptn</code> namespace</p>"},{"location":"api/#literal-patterns","title":"Literal Patterns","text":""},{"location":"api/#ptnlitvalue","title":"<code>ptn::lit(value)</code>","text":"<p>Create exact match pattern.</p> <pre><code>template &lt;typename V&gt;\nconstexpr auto lit(V &amp;&amp;v);\n</code></pre> <p>Purpose: Create a pattern that exactly matches the given value</p> <p>Supported Types: - Arithmetic types (int, double, float, etc.) - Enum types - Strings (std::string, std::string_view, const char*) - User-defined types (must support operator==)</p> <p>Examples: <pre><code>// Integer matching\nmatch(42).when(lit(42) &gt;&gt; \"answer\");\n\n// String matching\nmatch(\"hello\").when(lit(\"hello\") &gt;&gt; \"greeting\");\n\n// Enum matching\nenum class Color { Red, Green, Blue };\nColor c = Color::Red;\nmatch(c).when(lit(Color::Red) &gt;&gt; \"red\");\n</code></pre></p>"},{"location":"api/#ptnlit_civalue","title":"<code>ptn::lit_ci(value)</code>","text":"<p>Create case-insensitive string matching pattern.</p> <pre><code>template &lt;typename V&gt;\nconstexpr auto lit_ci(V &amp;&amp;v);\n</code></pre> <p>Purpose: Create a case-insensitive string matching pattern (ASCII only)</p> <p>Example: <pre><code>std::string s = \"HELLO\";\nmatch(s).when(lit_ci(\"hello\") &gt;&gt; \"case-insensitive-match\");\n</code></pre></p>"},{"location":"api/#binding-patterns","title":"Binding Patterns","text":""},{"location":"api/#ptnbind","title":"<code>ptn::bind()</code>","text":"<p>Create a pattern that captures the entire subject value.</p> <pre><code>constexpr auto bind();\n</code></pre> <p>Purpose: Create a pattern that always matches and captures the subject as a tuple</p> <p>Returns: <code>binding_pattern</code> that binds the subject value</p> <p>Examples: <pre><code>// Capture any value\nmatch(42).when(bind() &gt;&gt; [](int v) { \n    return \"captured: \" + std::to_string(v);\n});\n\n// Fallback capture\nenum Status { Pending, Running };\nmatch(Status::Running)\n    .when(lit(Status::Pending) &gt;&gt; \"pending\")\n    .when(bind() &gt;&gt; [](int v) { return \"status: \" + std::to_string(v); });\n</code></pre></p>"},{"location":"api/#ptnbindsubpattern","title":"<code>ptn::bind(subpattern)</code>","text":"<p>Create a pattern that first matches with subpattern, then captures the subject.</p> <pre><code>template &lt;typename SubPattern&gt;\nconstexpr auto bind(SubPattern &amp;&amp;subpattern);\n</code></pre> <p>Purpose: Create a pattern that combines subpattern matching with subject capturing</p> <p>Parameters: - <code>subpattern</code> - Pattern to use for matching</p> <p>Returns: <code>binding_as_pattern</code> that binds both subject and subpattern bindings</p> <p>Examples: <pre><code>// Capture after matching specific value\nenum Status { Pending, Running, Completed };\nmatch(Status::Running)\n    .when(bind(lit(Status::Running)) &gt;&gt; [](int whole) {\n        std::cout &lt;&lt; \"Captured enum value: \" &lt;&lt; whole &lt;&lt; \"\\n\";\n        return \"running\";\n    });\n\n// Capture with string matching\nstd::string cmd = \"START\";\nmatch(cmd)\n    .when(bind(lit_ci(\"start\")) &gt;&gt; [](std::string command) {\n        return \"processing: \" + command;\n    });\n</code></pre></p> <p>Binding Behavior: - <code>bind()</code> alone binds the subject as <code>std::tuple&lt;Subject&gt;</code> - <code>bind(subpattern)</code> binds <code>std::tuple&lt;Subject, SubPatternBindings...&gt;</code> - Handler functions receive the bound values as parameters</p>"},{"location":"api/#dsl-operators-api","title":"DSL Operators API","text":""},{"location":"api/#pattern-handler-binding-operators","title":"Pattern-Handler Binding Operators","text":""},{"location":"api/#pattern-handler-pattern-binding","title":"<code>pattern &gt;&gt; handler</code> - Pattern binding","text":"<p>Bind a pattern with a handler function or value.</p> <p>Two modes:</p> <ol> <li> <p>Value handler mode: <pre><code>pattern &gt;&gt; value\n</code></pre>    Automatically creates a handler that returns a fixed value</p> </li> <li> <p>Function handler mode: <pre><code>pattern &gt;&gt; function\n</code></pre>    Directly uses the provided function as the handler</p> </li> </ol> <p>Examples: <pre><code>// Value handler\nmatch(42).when(lit(42) &gt;&gt; \"answer\");  // Returns string \"answer\"\n\n// Function handler\nmatch(42).when(lit(42) &gt;&gt; []{ \n    return \"answer\";\n});  // Returns string \"answer\"\n\n// Capturing handler with bind()\nmatch(42).when(bind() &gt;&gt; [](int value) { \n    return \"captured: \" + std::to_string(value);\n});\n\n// Capturing handler with subpattern\nenum Status { Running };\nmatch(Status::Running)\n    .when(bind(lit(Status::Running)) &gt;&gt; [](int whole) {\n        return \"status: \" + std::to_string(whole);\n    });\n</code></pre></p>"},{"location":"api/#binding-system-api","title":"Binding System API","text":""},{"location":"api/#binding-traits","title":"Binding Traits","text":"<p>Patternia uses a type trait system to determine what values each pattern binds.</p>"},{"location":"api/#binding_argspattern-subject","title":"<code>binding_args&lt;Pattern, Subject&gt;</code>","text":"<p>Trait that defines the binding result type for a pattern-subject pair.</p> <pre><code>template &lt;typename Pattern, typename Subject&gt;\nstruct binding_args {\n    using type = std::tuple&lt;&gt;; // default implementation\n};\n</code></pre> <p>Specializations: - <code>binding_args&lt;binding_pattern, Subject&gt;</code> \u2192 <code>std::tuple&lt;Subject&gt;</code> - <code>binding_args&lt;binding_as_pattern&lt;Tag, SubPattern&gt;, Subject&gt;</code> \u2192 concatenated tuple</p>"},{"location":"api/#binding_args_tpattern-subject","title":"<code>binding_args_t&lt;Pattern, Subject&gt;</code>","text":"<p>Convenience alias for binding arguments type.</p> <pre><code>template &lt;typename Pattern, typename Subject&gt;\nusing binding_args_t = typename binding_args&lt;Pattern, Subject&gt;::type;\n</code></pre>"},{"location":"api/#api-feature-summary","title":"API Feature Summary","text":""},{"location":"api/#type-safety","title":"Type Safety","text":"<ul> <li>All pattern matching is compile-time type safe</li> <li>Support for heterogeneous comparisons (comparisons between different types)</li> <li>Automatic type deduction and explicit type specification</li> <li>Strong typing for binding values</li> </ul>"},{"location":"api/#performance-optimization","title":"Performance Optimization","text":"<ul> <li>Zero runtime overhead abstractions</li> <li>Compile-time pattern combination optimization</li> <li>Support for constant expression evaluation</li> <li>No RTTI or virtual dispatch</li> </ul>"},{"location":"api/#extensibility","title":"Extensibility","text":"<ul> <li>CRTP-based pattern base classes</li> <li>Easy to add custom pattern types</li> <li>Support for custom comparators and predicates</li> <li>Modular binding trait system</li> </ul>"},{"location":"api/#expressiveness","title":"Expressiveness","text":"<ul> <li>Rich built-in pattern types (literal, binding, case-insensitive)</li> <li>Intuitive DSL syntax with <code>&gt;&gt;</code> operator</li> <li>Support for complex pattern combinations</li> <li>Value capturing and binding capabilities</li> </ul>"},{"location":"api/#compatibility","title":"Compatibility","text":"<ul> <li>Support for C++17 and C++20</li> <li>Modular header file design</li> <li>Configurable feature switches</li> <li>Header-only integration</li> </ul> <p>This complete API reference covers all public interfaces of the Patternia library, including internal and external APIs, and provides comprehensive example code. You can use this documentation to write GitHub Pages documentation and README files.</p>"},{"location":"guide/getting-started/","title":"Getting Started","text":"<p>Patternia is a header-only library. Once installed or fetched into your project, you can start using pattern matching immediately.</p> <p>Below is minimal working example demonstrating the core DSL:</p>"},{"location":"guide/getting-started/#optional-recommended-code-style","title":"Optional: Recommended Code Style","text":"<p>To keep your chained <code>.when()</code> and <code>.otherwise()</code> expressions visually aligned and easy to scan, you can add a minimal <code>.clang-format</code> to your project root:</p> <pre><code># patternia .clang-format (minimal)\nBasedOnStyle: LLVM\nIndentWidth: 2            # or 4\nContinuationIndentWidth: 4 # or 6\nColumnLimit: 0\nBinPackArguments: false\nBinPackParameters: false\nBreakBeforeBinaryOperators: None\n</code></pre> <p>With this style, multi-line match expressions remain clean and consistent:</p> <pre><code>auto out =\n    match(5)\n      .when(lit(0) &gt;&gt; \"zero\")\n      .when(lit(5) &gt;&gt; \"five\")\n      .otherwise(\"other\");\n</code></pre>"},{"location":"guide/getting-started/#basic-example","title":"Basic Example","text":"<pre><code>#include &lt;ptn/patternia.hpp&gt;\n#include &lt;iostream&gt;\nusing namespace ptn;\n\nint main() {\n  int x = 42;\n\n  auto result =\n    match(x)\n      .when(lit(0)       &gt;&gt; \"zero\")\n      .when(lit(42)      &gt;&gt; \"answer to everything\")\n      .otherwise(\"other\");\n\n  std::cout &lt;&lt; result &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>answer to everything\n</code></pre>"},{"location":"guide/getting-started/#case-insensitive-matching","title":"Case-insensitive matching","text":"<pre><code>std::string s = \"Ok\";\n\nauto out = match(s)\n  .when(lit_ci(\"OK\") &gt;&gt; \"accepted\")\n  .otherwise(\"rejected\");\n</code></pre>"},{"location":"guide/getting-started/#no-macros-no-reflection-no-magic","title":"No macros. No reflection. No magic","text":"<p>Patternia compiles down to normal C++ control flow using inlined pattern objects. There is no runtime overhead beyond executing the selected handler.</p>"},{"location":"guide/installation/","title":"Installation","text":"<p>Patternia is a header-only C++ library. There is no build system, no linking step, and no external dependency.</p> <p>You can integrate Patternia into your project in any of the following ways.</p>"},{"location":"guide/installation/#1-recommended-fetch-patternia-automatically","title":"1. Recommended: Fetch Patternia automatically","text":"<p>You may choose to fetch Patternia as a remote dependency during configuration.</p> <p>FetchContent:</p> <pre><code>include(FetchContent)\nFetchContent_Declare(patternia\n  GIT_REPOSITORY https://github.com/sentomk/patternia.git\n  GIT_TAG main\n)\nFetchContent_MakeAvailable(patternia)\n\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>CPM.cmake:</p> <pre><code>CPMAddPackage(\"gh:sentomk/patternia@main\")\n</code></pre> <p>This fits well in reproducible CI pipelines and modern CMake workflows.</p>"},{"location":"guide/installation/#2-install-and-consume-via-find_package","title":"2. Install and consume via <code>find_package()</code>","text":"<p>Patternia provides full CMake package export support.</p> <p>Install:</p> <pre><code>cmake -B build\ncmake --build build\ncmake --install build --prefix /path/to/install\n</code></pre> <p>Use in any project:</p> <pre><code>find_package(patternia REQUIRED)\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>This is the recommended method for system-wide integration, packaging, and distribution.</p>"},{"location":"guide/installation/#3-add-patternia-as-a-git-submodule","title":"3. Add Patternia as a Git submodule","text":"<pre><code>git submodule add https://github.com/sentomk/patternia extern/patternia\n</code></pre> <p>Then in your CMake project:</p> <pre><code>add_subdirectory(extern/patternia)\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>This approach keeps Patternia version-controlled inside your repository and works well for mid- to large-scale projects.</p>"},{"location":"guide/installation/#4-include-the-include-directory-directly","title":"4. Include the <code>include/</code> directory directly","text":"<p>This is the simplest approach. Just add Patternia\u2019s header path to your target:</p> <pre><code>target_include_directories(your_target\n  PRIVATE /path/to/patternia/include\n)\n</code></pre> <p>No configuration, no installation, immediately usable.</p>"},{"location":"patterns/foreword/","title":"Pattern System Architecture","text":"<p>Patternia is built around a single architectural idea: matching should be a first-class, composable, zero-overhead operation in C++.</p> <p>Most C++ projects rely heavily on hand-written branching logic\u2014nested <code>if</code> statements, large <code>switch</code> blocks, duplicated comparisons, and one-off helper functions. These mechanisms are powerful but structurally limited:</p> <ul> <li>Logic becomes scattered across functions.  </li> <li>Conditions cannot be abstracted or composed easily.  </li> <li>Type-dependent paths require RTTI or explicit <code>dynamic_cast</code>.  </li> <li>Value-dependent paths become deeply imperative and repetitive.  </li> <li>Maintenance requires editing many disconnected branches.</li> </ul> <p>Patternia introduces a dedicated Pattern System to unify these forms of branching under a single semantic model.</p> <p>At its core, a Pattern is an object that describes a condition, and the system determines how to evaluate that condition safely and efficiently. All patterns\u2014whether they describe a value, a predicate, or a type\u2014share the same conceptual role:</p> <ol> <li> <p>Describe a match rule.    A pattern encapsulates the logic for deciding whether a subject satisfies a condition.</p> </li> <li> <p>Compose into larger rules.    Patterns form an algebra: they can be combined into richer logic without changing control flow.</p> </li> <li> <p>Participate in the matching pipeline.    The system evaluates patterns in sequence and invokes handlers for the first matching rule.</p> </li> </ol> <p>The Pattern System is not an auxiliary feature. It is the architectural foundation on which the entire library\u2014value dispatch, type dispatch, and later variant dispatch\u2014is built.</p> <p>This chapter examines the architectural model of the Pattern System and clarifies how different pattern categories cooperate to define matching behavior. The discussion begins with value patterns and type patterns as foundational components.</p> <ul> <li>Value Patterns </li> <li>Type Patterns</li> </ul> <p>Their APIs appear elsewhere; here we focus on their design purpose, abstraction model, and role within the match pipeline.</p>"},{"location":"patterns/type/","title":"Type Patterns \u2014 Architectural Perspective","text":"<p>Type Patterns define the part of the Pattern System dedicated to type-level dispatch. They describe conditions about what a value is, rather than how it behaves or what its runtime value contains.</p> <p>They solve a central architectural problem in C++ codebases:</p> <p>How do we express type-dependent logic without RTTI, virtual inheritance, or manual <code>if constexpr</code> chains?</p> <p>Type Patterns provide a unified answer.</p>"},{"location":"patterns/type/#1-type-level-semantics-as-first-class-objects","title":"1. Type-Level Semantics as First-Class Objects","text":"<p>In typical C++ systems, type-specific logic is embedded in:</p> <ul> <li>Template specializations  </li> <li><code>std::variant</code> visitor lambdas  </li> <li>Chains of <code>if constexpr (std::is_same_v&lt;T, ...&gt;)</code> </li> <li>RTTI (<code>typeid</code>, <code>dynamic_cast</code>)  </li> </ul> <p>These mechanisms work but lack a uniform abstraction for type conditions.</p> <p>Type Patterns elevate type checks to first-class pattern objects, enabling the same:</p> <ul> <li>Composition  </li> <li>Reuse  </li> <li>Declarative structure  </li> </ul> <p>that Value Patterns provide for runtime data.</p>"},{"location":"patterns/type/#2-zero-cost-type-dispatch","title":"2. Zero-Cost Type Dispatch","text":"<p>All type decisions in Patternia are resolved through normal C++ type inspection and inlining. The Pattern System introduces:</p> <ul> <li>No RTTI  </li> <li>No virtual calls  </li> <li>No runtime type discrimination  </li> <li>No dynamic polymorphism  </li> </ul> <p>By making type checks structural (not reflective), Patternia provides the performance profile needed for high-throughput or low-latency applications.</p>"},{"location":"patterns/type/#3-unifying-value-and-type-domains","title":"3. Unifying Value and Type Domains","text":"<p>A key architectural goal is that Value Patterns and Type Patterns participate in the same matching pipeline.</p> <p>This allows rules such as:</p> <ul> <li>\"If the subject is an <code>int</code> and greater than zero\u2026\"  </li> <li>\"If the subject is a <code>std::string</code> and equals 'start'\u2026\"  </li> <li>\"If the subject is from this template family and satisfies a numeric guard\u2026\"</li> </ul> <p>The system does not treat type and value as separate languages. They are part of one cohesive pattern algebra.</p>"},{"location":"patterns/type/#4-foundation-for-variant-dispatch","title":"4. Foundation for Variant Dispatch","text":"<p>The upcoming Variant Layer relies directly on Type Patterns.</p> <p>Matching an active alternative of <code>std::variant</code> is fundamentally a type-level operation:</p> <ul> <li>If the active type is <code>T</code>\u2026  </li> <li>If the active type belongs to <code>{A, B, C}</code>\u2026  </li> <li>If the alternative is any specialization of a template family\u2026</li> </ul> <p>Type Patterns make these decisions explicit and reusable.</p> <p>In other words, they are not an optional feature; they are a structural part of the library\u2019s dispatch model.</p>"},{"location":"patterns/type/#summary","title":"Summary","text":"<p>Architecturally, Type Patterns:</p> <ul> <li>Represent type-based semantics independently of runtime values  </li> <li>Provide a uniform abstraction for type dispatch  </li> <li>Integrate with the same compositional model used by Value Patterns  </li> <li>Enable zero-overhead matching  </li> <li>Form the basis for variant-aware pattern layers</li> </ul> <p>They are the type-theoretic pillar of Patternia\u2019s Pattern System.</p>"},{"location":"patterns/value/","title":"Value Patterns \u2014 Architectural Perspective","text":"<p>Value Patterns represent the part of the Pattern System concerned with runtime values. They describe conditions on concrete data: numbers, strings, states, commands, and any object that can be inspected without involving its type structure.</p> <p>From an architectural perspective, Value Patterns serve three core roles:</p>"},{"location":"patterns/value/#1-unifying-value-level-logic","title":"1. Unifying Value-Level Logic","text":"<p>In conventional C++, comparisons and conditions are expressed through imperative constructs:</p> <ul> <li><code>if (x == 42)</code> </li> <li><code>if (name == \"start\")</code> </li> <li><code>if (name == \"START\")</code> (case-insensitive)</li> </ul> <p>Each condition is tied to surrounding control flow. Value Patterns decouple the expression of conditions from the control structure that uses them.</p> <p>As a result:</p> <ul> <li>Value conditions become reusable units.</li> <li>Complex value logic becomes declarative\u2014described, not executed.</li> <li>Matching rules become centralized and maintainable.</li> </ul>"},{"location":"patterns/value/#2-enabling-compositional-semantics","title":"2. Enabling Compositional Semantics","text":"<p>Patterns obey a formal algebra. Value Patterns can be combined with logical operators to describe richer semantics without duplicating comparisons or control logic.</p> <p>This provides architectural benefits:</p> <ul> <li>Conditions become first-class objects.  </li> <li>Rules can be assembled, reused, refined, or shared across modules.  </li> <li>Large matching systems can be built from small, orthogonal components.</li> </ul> <p>This capability is essential as the library grows toward supporting predicate guards, custom user-defined patterns, and domain-specific pattern sets.</p>"},{"location":"patterns/value/#3-integrating-with-the-match-pipeline","title":"3. Integrating with the Match Pipeline","text":"<p>At match time, Value Patterns participate in a common evaluation pipeline:</p> <ol> <li>The subject is passed to each pattern.  </li> <li>The pattern decides, independently, whether the subject satisfies its rule.  </li> <li>A matching pattern triggers a handler and short-circuits evaluation.</li> </ol> <p>Value Patterns do not influence the structure of evaluation\u2014only the semantics of the condition. This separation of responsibilities keeps the system modular and allows different pattern families to coexist imperatively.</p>"},{"location":"patterns/value/#current-implementation","title":"Current Implementation","text":"<p>The current implementation provides:</p>"},{"location":"patterns/value/#literal-patterns","title":"Literal Patterns","text":"<ul> <li><code>lit(value)</code> - Exact value matching</li> <li><code>lit_ci(value)</code> - Case-insensitive string matching (ASCII only)</li> </ul>"},{"location":"patterns/value/#supported-types","title":"Supported Types","text":"<ul> <li>Arithmetic types (int, double, float, etc.)</li> <li>Enum types  </li> <li>Strings (std::string, std::string_view, const char*)</li> <li>User-defined types (must support operator==)</li> </ul>"},{"location":"patterns/value/#dsl-operators","title":"DSL Operators","text":"<ul> <li><code>&gt;&gt;</code> - Pattern-handler binding operator</li> </ul>"},{"location":"patterns/value/#summary","title":"Summary","text":"<p>Architecturally, Value Patterns:</p> <ul> <li>Represent value-level semantics in declarative form  </li> <li>Promote reusable, composable conditions  </li> <li>Integrate seamlessly into the shared match pipeline  </li> <li>Prepare the ground for higher-level constructs (predicates, guards, domain-specific rules)</li> </ul> <p>They are the foundational layer of runtime data dispatch in Patternia.</p>"}]}