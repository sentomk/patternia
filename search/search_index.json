{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Patternia","text":"<p>Patternia is a modern C++ pattern-matching DSL designed to make dispatch logic clear, expressive, and type-safe \u2014 without sacrificing performance or compilation efficiency.</p> <p>It provides a structured way to express matching rules through composable patterns, including value patterns, type patterns, and extensible DSL operators.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>#include &lt;ptn/patternia.hpp&gt;\nusing namespace ptn;\n\nint x = 42;\n\nauto result =\n  match(x)\n    .when(lit(0) &gt;&gt; \"zero\")\n    .when(lit(42) &gt;&gt; \"answer\")\n    .when(type::is&lt;int&gt; &gt;&gt; \"int value\")\n    .otherwise(\"other\");\n</code></pre> <p>Patternia evaluates patterns in order and returns the result associated with the first successful match.</p>"},{"location":"#why-patternia","title":"Why Patternia","text":"<ul> <li>Header-only, zero dependencies</li> <li>Declarative matching style</li> <li>Strongly typed DSL</li> <li>Composable value, type, and predicate patterns</li> <li>Clean chaining model: <code>match().when().otherwise()</code></li> <li>Ready for integration into modern C++ projects</li> </ul>"},{"location":"#core-concepts","title":"Core Concepts","text":"<p>Patternia organizes matching logic into a simple layered model:</p> <ul> <li> <p>Value Patterns   Match literals, ranges, and custom predicates.</p> </li> <li> <p>Type Patterns   Match exact types, type lists, or template families.</p> </li> <li> <p>Variant Patterns (in development)   Structured matching for <code>std::variant</code> and user-defined sum types.</p> </li> <li> <p>DSL Operators <code>&gt;&gt;</code> (pattern \u2192 handler), <code>&amp;&amp;</code>, <code>||</code>, <code>!</code> for pattern composition.</p> </li> </ul>"},{"location":"#get-started","title":"Get Started","text":"<p>To begin using Patternia, see:</p> <ul> <li>Installation</li> <li>Getting Started</li> <li>Concepts</li> </ul>"},{"location":"#explore-the-pattern-system","title":"Explore the Pattern System","text":"<ul> <li>Pattern System Architecture</li> <li>Value Patterns</li> <li>Type Patterns</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>match()</li> <li>value patterns</li> <li>type patterns</li> <li>variant</li> <li>DSL Operators</li> </ul>"},{"location":"#project","title":"Project","text":"<ul> <li>Roadmap</li> <li>Releases</li> <li>GitHub Repository</li> </ul> <p>Patternia aims to make logical structure explicit \u2014 so your C++ code becomes easier to read, reason about, and extend.</p>"},{"location":"patternia_architecture_en/","title":"Patternia Pattern Matching Library Architecture Analysis","text":""},{"location":"patternia_architecture_en/#part-1-namespace-structure","title":"Part 1: Namespace Structure","text":"<p>Patternia library adopts a clear hierarchical namespace structure, divided into the following layers:</p>"},{"location":"patternia_architecture_en/#root-namespace-ptn","title":"Root Namespace <code>ptn</code>","text":"<p>The root namespace of Patternia library, where all public APIs are located.</p>"},{"location":"patternia_architecture_en/#core-sub-namespaces","title":"Core Sub-namespaces","text":""},{"location":"patternia_architecture_en/#ptncore","title":"<code>ptn::core</code>","text":"<p>Core engine and DSL-related functionality - <code>ptn::core::common</code> - Common utilities and diagnostics - <code>ptn::core::dsl</code> - Domain-specific language operators - <code>ptn::core::engine</code> - Core matching engine implementation</p>"},{"location":"patternia_architecture_en/#ptnpat","title":"<code>ptn::pat</code>","text":"<p>Pattern definitions and implementations - <code>ptn::pat::base</code> - Base pattern abstractions and traits - <code>ptn::pat::value</code> - Value patterns (literal, relational, predicate) - <code>ptn::pat::type</code> - Type patterns</p>"},{"location":"patternia_architecture_en/#ptnmeta","title":"<code>ptn::meta</code>","text":"<p>Metaprogramming utilities - <code>ptn::meta::base</code> - Basic type traits - <code>ptn::meta::dsa</code> - Data structures and algorithms - <code>ptn::meta::query</code> - Type query utilities</p>"},{"location":"patternia_architecture_en/#implementation-detail-namespaces","title":"Implementation Detail Namespaces","text":"<ul> <li><code>ptn::core::engine::detail</code> - Engine implementation details</li> <li><code>ptn::core::dsl::detail</code> - DSL implementation details</li> <li><code>ptn::pat::value::detail</code> - Value pattern implementation details</li> <li><code>ptn::pat::type::detail</code> - Type pattern implementation details</li> </ul>"},{"location":"patternia_architecture_en/#part-2-layer-division","title":"Part 2: Layer Division","text":"<p>Patternia library adopts a classic layered architecture design, divided into the following layers from bottom to top:</p>"},{"location":"patternia_architecture_en/#meta-layer","title":"Meta Layer","text":"<p>Location: <code>ptn/meta/</code> Responsibility: Provides compile-time type operations and metaprogramming infrastructure - <code>base/traits.hpp</code> - Basic type traits (remove_cvref_t, is_spec_of, etc.) - <code>dsa/</code> - Data structures and algorithms (type_list, algorithms) - <code>query/</code> - Type query utilities (index, template_info)</p>"},{"location":"patternia_architecture_en/#core-layer","title":"Core Layer","text":"<p>Location: <code>ptn/core/</code> Responsibility: Provides core pattern matching engine and DSL support</p>"},{"location":"patternia_architecture_en/#common-sublayer","title":"Common Sublayer","text":"<ul> <li><code>common/</code> - Common utilities, diagnostics, optimization, evaluation</li> </ul>"},{"location":"patternia_architecture_en/#dsl-sublayer","title":"DSL Sublayer","text":"<ul> <li><code>dsl/</code> - Domain-specific language operators (&gt;&gt;, &amp;&amp;, ||, !)</li> </ul>"},{"location":"patternia_architecture_en/#engine-sublayer","title":"Engine Sublayer","text":"<ul> <li><code>engine/</code> - Matching engine implementation (builder, match)</li> </ul>"},{"location":"patternia_architecture_en/#pattern-layer","title":"Pattern Layer","text":"<p>Location: <code>ptn/pattern/</code> Responsibility: Defines various types of patterns and pattern factories</p>"},{"location":"patternia_architecture_en/#base-sublayer","title":"Base Sublayer","text":"<ul> <li><code>base/</code> - Pattern base classes, traits, binding contracts</li> </ul>"},{"location":"patternia_architecture_en/#value-pattern-sublayer","title":"Value Pattern Sublayer","text":"<ul> <li><code>value/</code> - Value patterns (literal, relational comparison, predicate)</li> </ul>"},{"location":"patternia_architecture_en/#type-pattern-sublayer","title":"Type Pattern Sublayer","text":"<ul> <li><code>type/</code> - Type patterns (is, in, not_in, from)</li> </ul>"},{"location":"patternia_architecture_en/#configuration-layer","title":"Configuration Layer","text":"<p>Location: <code>ptn/config.hpp</code> Responsibility: Compile-time configuration switches and feature control</p>"},{"location":"patternia_architecture_en/#integration-layer","title":"Integration Layer","text":"<p>Location: <code>ptn/patternia.hpp</code> Responsibility: Unified public entry point, exports all necessary headers</p>"},{"location":"patternia_architecture_en/#part-3-api-summary-and-semantics","title":"Part 3: API Summary and Semantics","text":""},{"location":"patternia_architecture_en/#core-matching-apis","title":"Core Matching APIs","text":""},{"location":"patternia_architecture_en/#ptnmatcht-value","title":"<code>ptn::match(T&amp;&amp; value)</code>","text":"<p>Semantics: Entry point for pattern matching, creates a match builder Parameters: Value to be matched Returns: <code>match_builder</code> object supporting chained calls</p>"},{"location":"patternia_architecture_en/#ptnmatchut-value","title":"<code>ptn::match&lt;U&gt;(T&amp;&amp; value)</code>","text":"<p>Semantics: Pattern matching entry point with explicit type specification Parameters: Target type U and value to be converted Returns: Typed <code>match_builder</code> object</p>"},{"location":"patternia_architecture_en/#pattern-builder-apis","title":"Pattern Builder APIs","text":""},{"location":"patternia_architecture_en/#whencase_expr","title":"<code>when(case_expr)</code>","text":"<p>Semantics: Add a matching condition and corresponding handler function Parameters: Case expression created using <code>&gt;&gt;</code> operator Returns: New match builder (supports chained calls)</p>"},{"location":"patternia_architecture_en/#otherwisehandler","title":"<code>otherwise(handler)</code>","text":"<p>Semantics: Set default handler function, executed when all patterns fail to match Parameters: Handler function or return value Returns: Matching result</p>"},{"location":"patternia_architecture_en/#dsl-operator-apis","title":"DSL Operator APIs","text":""},{"location":"patternia_architecture_en/#pattern-handler","title":"<code>pattern &gt;&gt; handler</code>","text":"<p>Semantics: Associate pattern with handler function Special: If handler is a value type, automatically converted to a function returning that value</p>"},{"location":"patternia_architecture_en/#pattern1-pattern2","title":"<code>pattern1 &amp;&amp; pattern2</code>","text":"<p>Semantics: Logical AND composition, both patterns must match</p>"},{"location":"patternia_architecture_en/#pattern1-pattern2_1","title":"<code>pattern1 || pattern2</code>","text":"<p>Semantics: Logical OR composition, either pattern matching is sufficient</p>"},{"location":"patternia_architecture_en/#pattern","title":"<code>!pattern</code>","text":"<p>Semantics: Logical NOT, succeeds when pattern does not match</p>"},{"location":"patternia_architecture_en/#value-pattern-apis","title":"Value Pattern APIs","text":""},{"location":"patternia_architecture_en/#literal-patterns","title":"Literal Patterns","text":"<ul> <li><code>lit(value)</code> - Exact literal value matching</li> <li><code>lit_ci(value)</code> - Case-insensitive string matching</li> </ul>"},{"location":"patternia_architecture_en/#relational-patterns","title":"Relational Patterns","text":"<ul> <li><code>lt(value)</code> - Less than (x &lt; value)</li> <li><code>le(value)</code> - Less than or equal (x &lt;= value)</li> <li><code>gt(value)</code> - Greater than (x &gt; value)</li> <li><code>ge(value)</code> - Greater than or equal (x &gt;= value)</li> <li><code>eq(value)</code> - Equal (x == value)</li> <li><code>ne(value)</code> - Not equal (x != value)</li> <li><code>between(lo, hi, closed=true)</code> - Interval matching</li> </ul>"},{"location":"patternia_architecture_en/#predicate-patterns","title":"Predicate Patterns","text":"<ul> <li><code>pred(predicate)</code> - Use arbitrary predicate function</li> </ul>"},{"location":"patternia_architecture_en/#type-pattern-apis","title":"Type Pattern APIs","text":""},{"location":"patternia_architecture_en/#ptnpattypeist","title":"<code>ptn::pat::type::is&lt;T&gt;</code>","text":"<p>Semantics: Exact type matching, binds value to handler when match succeeds Binding: Binds matched value as <code>std::tuple&lt;Subject&gt;</code></p>"},{"location":"patternia_architecture_en/#ptnpattypeintypes","title":"<code>ptn::pat::type::in&lt;Types...&gt;</code>","text":"<p>Semantics: Type set matching, checks if type is in given type list</p>"},{"location":"patternia_architecture_en/#ptnpattypenot_intypes","title":"<code>ptn::pat::type::not_in&lt;Types...&gt;</code>","text":"<p>Semantics: Type exclusion matching, checks if type is not in given type list</p>"},{"location":"patternia_architecture_en/#ptnpattypefromt","title":"<code>ptn::pat::type::from&lt;T&gt;</code>","text":"<p>Semantics: Type conversion matching, checks if convertible from target type</p>"},{"location":"patternia_architecture_en/#metaprogramming-apis","title":"Metaprogramming APIs","text":""},{"location":"patternia_architecture_en/#type-traits","title":"Type Traits","text":"<ul> <li><code>ptn::meta::remove_cvref_t&lt;T&gt;</code> - Remove const/volatile and reference</li> <li><code>ptn::meta::is_spec_of_v&lt;Template, T&gt;</code> - Check if template specialization</li> <li><code>ptn::meta::is_tmpl_v&lt;T&gt;</code> - Check if template instance</li> </ul>"},{"location":"patternia_architecture_en/#type-list-operations","title":"Type List Operations","text":"<ul> <li><code>ptn::meta::dsa::type_list</code> - Type list container</li> <li><code>ptn::meta::dsa::algorithms</code> - Type list algorithms</li> </ul>"},{"location":"patternia_architecture_en/#configuration-macros","title":"Configuration Macros","text":"<ul> <li><code>PTN_ENABLE_VALUE_PATTERN</code> - Enable value patterns</li> <li><code>PTN_ENABLE_RELATIONAL_PATTERN</code> - Enable relational patterns</li> <li><code>PTN_ENABLE_TYPE_PATTERN</code> - Enable type patterns</li> <li><code>PTN_ENABLE_PREDICATE_PATTERN</code> - Enable predicate patterns</li> <li><code>PTN_USE_CONCEPTS</code> - Enable C++20 concepts support</li> </ul>"},{"location":"patternia_architecture_en/#binding-semantics","title":"Binding Semantics","text":"<ul> <li>Literal patterns: Bind no values (<code>std::tuple&lt;&gt;</code>)</li> <li>Relational patterns: Bind no values (<code>std::tuple&lt;&gt;</code>)</li> <li>Predicate patterns: Bind no values (<code>std::tuple&lt;&gt;</code>)</li> <li>Type patterns: Bind matched value (<code>std::tuple&lt;Subject&gt;</code>)</li> </ul>"},{"location":"patternia_architecture_en/#error-handling","title":"Error Handling","text":"<p>The library uses <code>static_assert</code> for compile-time validation of: - Pattern type validity - Handler function signature compatibility - Type constructibility - Operator support</p> <p>This design ensures type safety and high performance while providing an intuitive and easy-to-use DSL syntax.</p>"},{"location":"patternia_architecture_zh/","title":"Patternia \u6a21\u5f0f\u5339\u914d\u5e93\u67b6\u6784\u5206\u6790","text":""},{"location":"patternia_architecture_zh/#_1","title":"\u7b2c\u4e00\u90e8\u5206\uff1a\u547d\u540d\u7a7a\u95f4\u7ed3\u6784","text":"<p>Patternia \u5e93\u91c7\u7528\u4e86\u6e05\u6670\u7684\u5c42\u6b21\u5316\u547d\u540d\u7a7a\u95f4\u7ed3\u6784\uff0c\u4e3b\u8981\u5206\u4e3a\u4ee5\u4e0b\u51e0\u4e2a\u5c42\u6b21\uff1a</p>"},{"location":"patternia_architecture_zh/#ptn","title":"\u6839\u547d\u540d\u7a7a\u95f4 <code>ptn</code>","text":"<p>Patternia \u5e93\u7684\u6839\u547d\u540d\u7a7a\u95f4\uff0c\u6240\u6709\u516c\u5171API\u90fd\u4f4d\u4e8e\u6b64\u547d\u540d\u7a7a\u95f4\u4e0b\u3002</p>"},{"location":"patternia_architecture_zh/#_2","title":"\u6838\u5fc3\u5b50\u547d\u540d\u7a7a\u95f4","text":""},{"location":"patternia_architecture_zh/#ptncore","title":"<code>ptn::core</code>","text":"<p>\u6838\u5fc3\u5f15\u64ce\u548cDSL\u76f8\u5173\u529f\u80fd - <code>ptn::core::common</code> - \u901a\u7528\u5de5\u5177\u548c\u8bca\u65ad - <code>ptn::core::dsl</code> - \u9886\u57df\u7279\u5b9a\u8bed\u8a00\u64cd\u4f5c\u7b26 - <code>ptn::core::engine</code> - \u5339\u914d\u5f15\u64ce\u6838\u5fc3\u5b9e\u73b0</p>"},{"location":"patternia_architecture_zh/#ptnpat","title":"<code>ptn::pat</code>","text":"<p>\u6a21\u5f0f\u5b9a\u4e49\u548c\u5b9e\u73b0 - <code>ptn::pat::base</code> - \u57fa\u7840\u6a21\u5f0f\u62bd\u8c61\u548c\u7279\u5f81 - <code>ptn::pat::value</code> - \u503c\u6a21\u5f0f\uff08\u5b57\u9762\u91cf\u3001\u5173\u7cfb\u3001\u8c13\u8bcd\uff09 - <code>ptn::pat::type</code> - \u7c7b\u578b\u6a21\u5f0f</p>"},{"location":"patternia_architecture_zh/#ptnmeta","title":"<code>ptn::meta</code>","text":"<p>\u5143\u7f16\u7a0b\u5de5\u5177 - <code>ptn::meta::base</code> - \u57fa\u7840\u7c7b\u578b\u7279\u5f81 - <code>ptn::meta::dsa</code> - \u6570\u636e\u7ed3\u6784\u548c\u7b97\u6cd5 - <code>ptn::meta::query</code> - \u7c7b\u578b\u67e5\u8be2\u5de5\u5177</p>"},{"location":"patternia_architecture_zh/#_3","title":"\u5b9e\u73b0\u7ec6\u8282\u547d\u540d\u7a7a\u95f4","text":"<ul> <li><code>ptn::core::engine::detail</code> - \u5f15\u64ce\u5b9e\u73b0\u7ec6\u8282</li> <li><code>ptn::core::dsl::detail</code> - DSL\u5b9e\u73b0\u7ec6\u8282</li> <li><code>ptn::pat::value::detail</code> - \u503c\u6a21\u5f0f\u5b9e\u73b0\u7ec6\u8282</li> <li><code>ptn::pat::type::detail</code> - \u7c7b\u578b\u6a21\u5f0f\u5b9e\u73b0\u7ec6\u8282</li> </ul>"},{"location":"patternia_architecture_zh/#_4","title":"\u7b2c\u4e8c\u90e8\u5206\uff1a\u5c42\u6b21\u5212\u5206","text":"<p>Patternia \u5e93\u91c7\u7528\u4e86\u7ecf\u5178\u7684\u5206\u5c42\u67b6\u6784\u8bbe\u8ba1\uff0c\u4ece\u5e95\u5c42\u5230\u9876\u5c42\u5206\u4e3a\u4ee5\u4e0b\u5c42\u6b21\uff1a</p>"},{"location":"patternia_architecture_zh/#meta-layer","title":"Meta Layer (\u5143\u7f16\u7a0b\u5c42)","text":"<p>\u4f4d\u7f6e: <code>ptn::meta/</code> \u804c\u8d23: \u63d0\u4f9b\u7f16\u8bd1\u65f6\u7c7b\u578b\u64cd\u4f5c\u548c\u5143\u7f16\u7a0b\u57fa\u7840\u8bbe\u65bd - <code>base/traits.hpp</code> - \u57fa\u7840\u7c7b\u578b\u7279\u5f81\uff08remove_cvref_t, is_spec_of\u7b49\uff09 - <code>dsa/</code> - \u6570\u636e\u7ed3\u6784\u548c\u7b97\u6cd5\uff08type_list, algorithms\uff09 - <code>query/</code> - \u7c7b\u578b\u67e5\u8be2\u5de5\u5177\uff08index, template_info\uff09</p>"},{"location":"patternia_architecture_zh/#core-layer","title":"Core Layer (\u6838\u5fc3\u5c42)","text":"<p>\u4f4d\u7f6e: <code>ptn/core/</code> \u804c\u8d23: \u63d0\u4f9b\u6a21\u5f0f\u5339\u914d\u7684\u6838\u5fc3\u5f15\u64ce\u548cDSL\u652f\u6301</p>"},{"location":"patternia_architecture_zh/#common-sublayer","title":"Common Sublayer","text":"<ul> <li><code>common/</code> - \u901a\u7528\u5de5\u5177\u3001\u8bca\u65ad\u3001\u4f18\u5316\u3001\u8bc4\u4f30</li> </ul>"},{"location":"patternia_architecture_zh/#dsl-sublayer","title":"DSL Sublayer","text":"<ul> <li><code>dsl/</code> - \u9886\u57df\u7279\u5b9a\u8bed\u8a00\u64cd\u4f5c\u7b26\uff08&gt;&gt;, &amp;&amp;, ||, !\uff09</li> </ul>"},{"location":"patternia_architecture_zh/#engine-sublayer","title":"Engine Sublayer","text":"<ul> <li><code>engine/</code> - \u5339\u914d\u5f15\u64ce\u5b9e\u73b0\uff08builder, match\uff09</li> </ul>"},{"location":"patternia_architecture_zh/#pattern-layer","title":"Pattern Layer (\u6a21\u5f0f\u5c42)","text":"<p>\u4f4d\u7f6e: <code>ptn/pattern/</code> \u804c\u8d23: \u5b9a\u4e49\u5404\u79cd\u7c7b\u578b\u7684\u6a21\u5f0f\u548c\u6a21\u5f0f\u5de5\u5382</p>"},{"location":"patternia_architecture_zh/#base-sublayer","title":"Base Sublayer","text":"<ul> <li><code>base/</code> - \u6a21\u5f0f\u57fa\u7c7b\u3001\u7279\u5f81\u3001\u7ed1\u5b9a\u5951\u7ea6</li> </ul>"},{"location":"patternia_architecture_zh/#value-pattern-sublayer","title":"Value Pattern Sublayer","text":"<ul> <li><code>value/</code> - \u503c\u6a21\u5f0f\uff08\u5b57\u9762\u91cf\u3001\u5173\u7cfb\u6bd4\u8f83\u3001\u8c13\u8bcd\uff09</li> </ul>"},{"location":"patternia_architecture_zh/#type-pattern-sublayer","title":"Type Pattern Sublayer","text":"<ul> <li><code>type/</code> - \u7c7b\u578b\u6a21\u5f0f\uff08is, in, not_in, from\uff09</li> </ul>"},{"location":"patternia_architecture_zh/#configuration-layer","title":"Configuration Layer (\u914d\u7f6e\u5c42)","text":"<p>\u4f4d\u7f6e: <code>ptn/config.hpp</code> \u804c\u8d23: \u7f16\u8bd1\u65f6\u914d\u7f6e\u5f00\u5173\u548c\u7279\u6027\u63a7\u5236</p>"},{"location":"patternia_architecture_zh/#integration-layer","title":"Integration Layer (\u96c6\u6210\u5c42)","text":"<p>\u4f4d\u7f6e: <code>ptn/patternia.hpp</code> \u804c\u8d23: \u7edf\u4e00\u7684\u516c\u5171\u5165\u53e3\u70b9\uff0c\u5bfc\u51fa\u6240\u6709\u5fc5\u8981\u7684\u5934\u6587\u4ef6</p>"},{"location":"patternia_architecture_zh/#api","title":"\u7b2c\u4e09\u90e8\u5206\uff1aAPI\u6c47\u603b\u53ca\u5176\u8bed\u4e49","text":""},{"location":"patternia_architecture_zh/#api_1","title":"\u6838\u5fc3\u5339\u914dAPI","text":""},{"location":"patternia_architecture_zh/#ptnmatcht-value","title":"<code>ptn::match(T&amp;&amp; value)</code>","text":"<p>\u8bed\u4e49: \u6a21\u5f0f\u5339\u914d\u7684\u5165\u53e3\u70b9\uff0c\u521b\u5efa\u5339\u914d\u6784\u5efa\u5668 \u53c2\u6570: \u8981\u5339\u914d\u7684\u503c \u8fd4\u56de: <code>match_builder</code> \u5bf9\u8c61\uff0c\u652f\u6301\u94fe\u5f0f\u8c03\u7528</p>"},{"location":"patternia_architecture_zh/#ptnmatchut-value","title":"<code>ptn::match&lt;U&gt;(T&amp;&amp; value)</code>","text":"<p>\u8bed\u4e49: \u663e\u5f0f\u6307\u5b9a\u7c7b\u578b\u7684\u6a21\u5f0f\u5339\u914d\u5165\u53e3\u70b9 \u53c2\u6570: \u76ee\u6807\u7c7b\u578bU\u548c\u8981\u8f6c\u6362\u7684\u503c \u8fd4\u56de: \u6307\u5b9a\u7c7b\u578b\u7684 <code>match_builder</code> \u5bf9\u8c61</p>"},{"location":"patternia_architecture_zh/#api_2","title":"\u6a21\u5f0f\u6784\u5efa\u5668API","text":""},{"location":"patternia_architecture_zh/#whencase_expr","title":"<code>when(case_expr)</code>","text":"<p>\u8bed\u4e49: \u6dfb\u52a0\u4e00\u4e2a\u5339\u914d\u6761\u4ef6\u548c\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570 \u53c2\u6570: \u4f7f\u7528 <code>&gt;&gt;</code> \u64cd\u4f5c\u7b26\u521b\u5efa\u7684case\u8868\u8fbe\u5f0f \u8fd4\u56de: \u65b0\u7684\u5339\u914d\u6784\u5efa\u5668\uff08\u652f\u6301\u94fe\u5f0f\u8c03\u7528\uff09</p>"},{"location":"patternia_architecture_zh/#otherwisehandler","title":"<code>otherwise(handler)</code>","text":"<p>\u8bed\u4e49: \u8bbe\u7f6e\u9ed8\u8ba4\u5904\u7406\u51fd\u6570\uff0c\u5f53\u6240\u6709\u6a21\u5f0f\u90fd\u4e0d\u5339\u914d\u65f6\u6267\u884c \u53c2\u6570: \u5904\u7406\u51fd\u6570\u6216\u8fd4\u56de\u503c \u8fd4\u56de: \u5339\u914d\u7ed3\u679c</p>"},{"location":"patternia_architecture_zh/#dslapi","title":"DSL\u64cd\u4f5c\u7b26API","text":""},{"location":"patternia_architecture_zh/#pattern-handler","title":"<code>pattern &gt;&gt; handler</code>","text":"<p>\u8bed\u4e49: \u5c06\u6a21\u5f0f\u4e0e\u5904\u7406\u51fd\u6570\u5173\u8054 \u7279\u6b8a: \u5982\u679chandler\u662f\u503c\u7c7b\u578b\uff0c\u81ea\u52a8\u8f6c\u6362\u4e3a\u8fd4\u56de\u8be5\u503c\u7684\u51fd\u6570</p>"},{"location":"patternia_architecture_zh/#pattern1-pattern2","title":"<code>pattern1 &amp;&amp; pattern2</code>","text":"<p>\u8bed\u4e49: \u903b\u8f91AND\u7ec4\u5408\uff0c\u4e24\u4e2a\u6a21\u5f0f\u90fd\u5fc5\u987b\u5339\u914d</p>"},{"location":"patternia_architecture_zh/#pattern1-pattern2_1","title":"<code>pattern1 || pattern2</code>","text":"<p>\u8bed\u4e49: \u903b\u8f91OR\u7ec4\u5408\uff0c\u4efb\u4e00\u6a21\u5f0f\u5339\u914d\u5373\u53ef</p>"},{"location":"patternia_architecture_zh/#pattern","title":"<code>!pattern</code>","text":"<p>\u8bed\u4e49: \u903b\u8f91NOT\uff0c\u6a21\u5f0f\u4e0d\u5339\u914d\u65f6\u6210\u529f</p>"},{"location":"patternia_architecture_zh/#api_3","title":"\u503c\u6a21\u5f0fAPI","text":""},{"location":"patternia_architecture_zh/#_5","title":"\u5b57\u9762\u91cf\u6a21\u5f0f","text":"<ul> <li><code>lit(value)</code> - \u7cbe\u786e\u5339\u914d\u5b57\u9762\u503c</li> <li><code>lit_ci(value)</code> - \u5927\u5c0f\u5199\u4e0d\u654f\u611f\u7684\u5b57\u7b26\u4e32\u5339\u914d</li> </ul>"},{"location":"patternia_architecture_zh/#_6","title":"\u5173\u7cfb\u6a21\u5f0f","text":"<ul> <li><code>lt(value)</code> - \u5c0f\u4e8e (x &lt; value)</li> <li><code>le(value)</code> - \u5c0f\u4e8e\u7b49\u4e8e (x &lt;= value)</li> <li><code>gt(value)</code> - \u5927\u4e8e (x &gt; value)</li> <li><code>ge(value)</code> - \u5927\u4e8e\u7b49\u4e8e (x &gt;= value)</li> <li><code>eq(value)</code> - \u7b49\u4e8e (x == value)</li> <li><code>ne(value)</code> - \u4e0d\u7b49\u4e8e (x != value)</li> <li><code>between(lo, hi, closed=true)</code> - \u533a\u95f4\u5339\u914d</li> </ul>"},{"location":"patternia_architecture_zh/#_7","title":"\u8c13\u8bcd\u6a21\u5f0f","text":"<ul> <li><code>pred(predicate)</code> - \u4f7f\u7528\u4efb\u610f\u8c13\u8bcd\u51fd\u6570</li> </ul>"},{"location":"patternia_architecture_zh/#api_4","title":"\u7c7b\u578b\u6a21\u5f0fAPI","text":""},{"location":"patternia_architecture_zh/#ptnpattypeist","title":"<code>ptn::pat::type::is&lt;T&gt;</code>","text":"<p>\u8bed\u4e49: \u7cbe\u786e\u7c7b\u578b\u5339\u914d\uff0c\u5339\u914d\u6210\u529f\u65f6\u7ed1\u5b9a\u503c\u5230\u5904\u7406\u51fd\u6570 \u7ed1\u5b9a: \u7ed1\u5b9a\u5339\u914d\u7684\u503c\u4f5c\u4e3a <code>std::tuple&lt;Subject&gt;</code></p>"},{"location":"patternia_architecture_zh/#ptnpattypeintypes","title":"<code>ptn::pat::type::in&lt;Types...&gt;</code>","text":"<p>\u8bed\u4e49: \u7c7b\u578b\u96c6\u5408\u5339\u914d\uff0c\u68c0\u67e5\u7c7b\u578b\u662f\u5426\u5728\u7ed9\u5b9a\u7684\u7c7b\u578b\u5217\u8868\u4e2d</p>"},{"location":"patternia_architecture_zh/#ptnpattypenot_intypes","title":"<code>ptn::pat::type::not_in&lt;Types...&gt;</code>","text":"<p>\u8bed\u4e49: \u7c7b\u578b\u6392\u9664\u5339\u914d\uff0c\u68c0\u67e5\u7c7b\u578b\u4e0d\u5728\u7ed9\u5b9a\u7684\u7c7b\u578b\u5217\u8868\u4e2d</p>"},{"location":"patternia_architecture_zh/#ptnpattypefromt","title":"<code>ptn::pat::type::from&lt;T&gt;</code>","text":"<p>\u8bed\u4e49: \u7c7b\u578b\u8f6c\u6362\u5339\u914d\uff0c\u68c0\u67e5\u662f\u5426\u53ef\u4ee5\u4ece\u76ee\u6807\u7c7b\u578b\u8f6c\u6362\u800c\u6765</p>"},{"location":"patternia_architecture_zh/#api_5","title":"\u5143\u7f16\u7a0bAPI","text":""},{"location":"patternia_architecture_zh/#_8","title":"\u7c7b\u578b\u7279\u5f81","text":"<ul> <li><code>ptn::meta::remove_cvref_t&lt;T&gt;</code> - \u79fb\u9664const/volatile\u548c\u5f15\u7528</li> <li><code>ptn::meta::is_spec_of_v&lt;Template, T&gt;</code> - \u68c0\u67e5\u662f\u5426\u4e3a\u6a21\u677f\u7279\u5316</li> <li><code>ptn::meta::is_tmpl_v&lt;T&gt;</code> - \u68c0\u67e5\u662f\u5426\u4e3a\u6a21\u677f\u5b9e\u4f8b</li> </ul>"},{"location":"patternia_architecture_zh/#_9","title":"\u7c7b\u578b\u5217\u8868\u64cd\u4f5c","text":"<ul> <li><code>ptn::meta::dsa::type_list</code> - \u7c7b\u578b\u5217\u8868\u5bb9\u5668</li> <li><code>ptn::meta::dsa::algorithms</code> - \u7c7b\u578b\u5217\u8868\u7b97\u6cd5</li> </ul>"},{"location":"patternia_architecture_zh/#_10","title":"\u914d\u7f6e\u5b8f","text":"<ul> <li><code>PTN_ENABLE_VALUE_PATTERN</code> - \u542f\u7528\u503c\u6a21\u5f0f</li> <li><code>PTN_ENABLE_RELATIONAL_PATTERN</code> - \u542f\u7528\u5173\u7cfb\u6a21\u5f0f</li> <li><code>PTN_ENABLE_TYPE_PATTERN</code> - \u542f\u7528\u7c7b\u578b\u6a21\u5f0f</li> <li><code>PTN_ENABLE_PREDICATE_PATTERN</code> - \u542f\u7528\u8c13\u8bcd\u6a21\u5f0f</li> <li><code>PTN_USE_CONCEPTS</code> - \u542f\u7528C++20\u6982\u5ff5\u652f\u6301</li> </ul>"},{"location":"patternia_architecture_zh/#_11","title":"\u7ed1\u5b9a\u8bed\u4e49","text":"<ul> <li>\u5b57\u9762\u91cf\u6a21\u5f0f: \u4e0d\u7ed1\u5b9a\u4efb\u4f55\u503c\uff08<code>std::tuple&lt;&gt;</code>\uff09</li> <li>\u5173\u7cfb\u6a21\u5f0f: \u4e0d\u7ed1\u5b9a\u4efb\u4f55\u503c\uff08<code>std::tuple&lt;&gt;</code>\uff09</li> <li>\u8c13\u8bcd\u6a21\u5f0f: \u4e0d\u7ed1\u5b9a\u4efb\u4f55\u503c\uff08<code>std::tuple&lt;&gt;</code>\uff09</li> <li>\u7c7b\u578b\u6a21\u5f0f: \u7ed1\u5b9a\u5339\u914d\u7684\u503c\uff08<code>std::tuple&lt;Subject&gt;</code>\uff09</li> </ul>"},{"location":"patternia_architecture_zh/#_12","title":"\u9519\u8bef\u5904\u7406","text":"<p>\u5e93\u4f7f\u7528 <code>static_assert</code> \u5728\u7f16\u8bd1\u65f6\u9a8c\u8bc1\uff1a - \u6a21\u5f0f\u7c7b\u578b\u7684\u6709\u6548\u6027 - \u5904\u7406\u51fd\u6570\u7b7e\u540d\u7684\u517c\u5bb9\u6027 - \u7c7b\u578b\u7684\u53ef\u6784\u9020\u6027 - \u64cd\u4f5c\u7b26\u7684\u652f\u6301\u6027</p> <p>\u8fd9\u4e2a\u8bbe\u8ba1\u786e\u4fdd\u4e86\u7c7b\u578b\u5b89\u5168\u548c\u9ad8\u6027\u80fd\uff0c\u540c\u65f6\u63d0\u4f9b\u4e86\u76f4\u89c2\u6613\u7528\u7684DSL\u8bed\u6cd5\u3002</p>"},{"location":"api/match/","title":"<code>ptn::match()</code> and the Match Builder","text":"<p>The <code>ptn::match()</code> function is the entry point to the Patternia DSL. It accepts a Subject Value to be matched against, and returns a Match Builder object, which allows the user to chain calls for adding patterns and handlers.</p>"},{"location":"api/match/#1-entry-function-ptnmatch","title":"1. Entry Function: <code>ptn::match</code>","text":""},{"location":"api/match/#signature","title":"Signature","text":"<p>This function is templated to accept any subject value, preserving its value category (e.g., it stores a copy for an lvalue, or moves the value for an rvalue).</p> <pre><code>namespace ptn {\n\n  template &lt;typename T&gt;\n  constexpr auto match(T &amp;&amp;value) noexcept;\n\n} // namespace ptn\n</code></pre>"},{"location":"api/match/#description","title":"Description","text":"<p>Constructs an instance of the <code>match_builder</code> containing a copy or moved version of the <code>value</code>. This function signifies the beginning of a pattern matching sequence.</p>"},{"location":"api/match/#template-parameters","title":"Template Parameters","text":"Name Description <code>T</code> The type of the Subject Value passed to <code>match()</code>."},{"location":"api/match/#parameters","title":"Parameters","text":"Name Type Description <code>value</code> <code>T &amp;&amp;</code> The value to be matched against the defined patterns."},{"location":"api/match/#returns","title":"Returns","text":"<p>Type: <code>ptn::core::match_builder&lt;std::decay_t&lt;T&gt;, std::tuple&lt;&gt;&gt;</code></p> <p>Returns an initialized match builder object, with the decayed type of T as its subject type. The initial case tuple is empty.</p>"},{"location":"api/match/#example","title":"Example","text":"<pre><code>#include &lt;ptn/patternia.hpp&gt;\nusing namespace ptn;\n\n// Matches an int (lvalue copy)\nint x = 10;\nauto builder_int = match(x);\n\n// Matches an rvalue string (move semantics)\nauto builder_str = match(std::string(\"hello\"));\n</code></pre>"},{"location":"api/match/#2-the-match-builder-ptncorematch_builder","title":"2. The Match Builder: <code>ptn::core::match_builder</code>","text":"<p>The <code>match_builder</code> is internally an immutable class. Each call to <code>.when()</code> returns a new builder instance with a different type, which statically records the newly added pattern-handler pair.</p>"},{"location":"api/match/#signature_1","title":"Signature","text":"<pre><code>namespace ptn::core {\n\n  template &lt;typename TV, typename... Cases&gt;\n  class match_builder { /* ... */ };\n\n} // namespace ptn::core\n</code></pre>"},{"location":"api/match/#member-functions","title":"Member Functions","text":""},{"location":"api/match/#a-when","title":"A. <code>.when()</code>","text":"<p>Appends a new pattern-handler pair (a Case) to the matching sequence.</p>"},{"location":"api/match/#signature_2","title":"Signature","text":"<pre><code>template &lt;typename Pattern, typename Handler&gt;\nconstexpr auto when(dsl::case_expr&lt;Pattern, Handler&gt; &amp;&amp;e) &amp;&amp;;\n</code></pre>"},{"location":"api/match/#description_1","title":"Description","text":"<p>Appends a <code>case_expr</code> (created via the <code>Pattern &gt;&gt; Handler</code> expression) to the compile-time list of cases. This operation is chainable and returns a new <code>match_builder</code> object that incorporates the new case.</p>"},{"location":"api/match/#returns_1","title":"Returns","text":"<p>Type: <code>ptn::core::match_builder&lt;TV, Cases..., NewCase&gt;</code></p> <p>Returns a new <code>match_builder</code> instance, which includes all previous cases plus the newly added case.</p>"},{"location":"api/match/#b-otherwise","title":"B. <code>.otherwise()</code>","text":"<p>Finalizes the matching sequence, triggering the evaluation and returning the result.</p>"},{"location":"api/match/#signature_3","title":"Signature","text":"<pre><code>template &lt;typename H&gt;\nconstexpr auto otherwise(H &amp;&amp;fallback) &amp;&amp;;\n</code></pre>"},{"location":"api/match/#description_2","title":"Description","text":"<p>Terminates the matching chain and performs evaluation:</p> <ol> <li>All patterns defined via <code>.when()</code> are checked sequentially.</li> <li>If the first matching pattern is found, its corresponding <code>Handler</code> is executed, and the result is returned.</li> <li>If no patterns match, the <code>fallback</code> handler is executed instead.</li> <li>Note: The final return type (<code>R</code>) is computed as the <code>std::common_type_t</code> of the return types of all handlers (including the <code>fallback</code>).</li> </ol>"},{"location":"api/match/#parameters_1","title":"Parameters","text":"Name Type Description <code>fallback</code> <code>H &amp;&amp;</code> The handler (function, lambda, or value) to be executed if no patterns match."},{"location":"api/match/#returns_2","title":"Returns","text":"<p>Type: <code>R</code> (The common type of all handlers' return values)</p> <p>Returns the result of the first successful pattern's handler, or the result of the <code>fallback</code> handler.</p>"},{"location":"guide/getting-started/","title":"Getting Started","text":"<p>Patternia is a header-only library. Once installed or fetched into your project, you can start using pattern matching immediately.</p> <p>Below is the minimal working example demonstrating the core DSL:</p>"},{"location":"guide/getting-started/#optional-recommended-code-style","title":"Optional: Recommended Code Style","text":"<p>To keep your chained <code>.when()</code> and <code>.otherwise()</code> expressions visually aligned and easy to scan, you can add a minimal <code>.clang-format</code> to your project root:</p> <pre><code># patternia .clang-format (minimal)\nBasedOnStyle: LLVM\nIndentWidth: 2            # or 4\nContinuationIndentWidth: 4 # or 6\nColumnLimit: 0\nBinPackArguments: false\nBinPackParameters: false\nBreakBeforeBinaryOperators: None\n</code></pre> <p>With this style, multi-line match expressions remain clean and consistent:</p> <pre><code>auto out =\n    match(5)\n      .when(lt(0) &gt;&gt; \"neg\")\n      .when(gt(0) &gt;&gt; \"pos\")\n      .otherwise(\"other\");\n</code></pre>"},{"location":"guide/getting-started/#basic-example","title":"Basic Example","text":"<pre><code>#include &lt;ptn/patternia.hpp&gt;\n#include &lt;iostream&gt;\nusing namespace ptn;\n\nint main() {\n  int x = 42;\n\n  auto result =\n    match(x)\n      .when(lit(0)       &gt;&gt; \"zero\")\n      .when(lit(42)      &gt;&gt; \"answer to everything\")\n      .when(pred([](int v){ return v % 2 == 0; }) &gt;&gt; \"even\")\n      .otherwise(\"other\");\n\n  std::cout &lt;&lt; result &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>answer to everything\n</code></pre>"},{"location":"guide/getting-started/#type-based-matching","title":"Type-based Matching","text":"<p>Patternia provides a type layer for matching based on static type.</p> <pre><code>std::variant&lt;int, float, std::string&gt; v = 3.14f;\n\nauto out = match(v)\n  .when(type::is&lt;int&gt;    &gt;&gt; \"int\")\n  .when(type::is&lt;float&gt;  &gt;&gt; \"float\")\n  .when(type::is&lt;std::string&gt; &gt;&gt; \"string\")\n  .otherwise(\"unknown\");\n</code></pre>"},{"location":"guide/getting-started/#relational-patterns","title":"Relational Patterns","text":"<p>Patternia\u2019s relational DSL (<code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>) works on any comparable value.</p> <pre><code>int score = 87;\n\nauto grade = match(score)\n  .when(lt(60)             &gt;&gt; \"F\") // less than\n  .when(ge(90)             &gt;&gt; \"A\") // greater equal\n  .when(ge(80)             &gt;&gt; \"B\")\n  .when(ge(70)             &gt;&gt; \"C\")\n  .otherwise(\"D\");\n</code></pre>"},{"location":"guide/getting-started/#predicates","title":"Predicates","text":"<p>Arbitrary logic can be wrapped into concise predicate patterns:</p> <pre><code>auto res = match(x)\n  .when(pred([](int v){ return v % 2 == 1; }) &gt;&gt; \"odd\")\n  .otherwise(\"even\");\n</code></pre>"},{"location":"guide/getting-started/#case-insensitive-matching","title":"Case-insensitive matching","text":"<pre><code>std::string s = \"Ok\";\n\nauto out = match(s)\n  .when(lit_ci(\"OK\") &gt;&gt; \"accepted\")\n  .otherwise(\"rejected\");\n</code></pre>"},{"location":"guide/getting-started/#no-macros-no-reflection-no-magic","title":"No macros. No reflection. No magic","text":"<p>Patternia compiles down to normal C++ control flow using inlined pattern objects. There is no runtime overhead beyond executing the selected handler.</p>"},{"location":"guide/installation/","title":"Installation","text":"<p>Patternia is a header-only C++ library. There is no build system, no linking step, and no external dependency.</p> <p>You can integrate Patternia into your project in any of the following ways.</p>"},{"location":"guide/installation/#1-recommended-fetch-patternia-automatically","title":"1. Recommended: Fetch Patternia automatically","text":"<p>You may choose to fetch Patternia as a remote dependency during configuration.</p> <p>FetchContent:</p> <pre><code>include(FetchContent)\nFetchContent_Declare(patternia\n  GIT_REPOSITORY https://github.com/sentomk/patternia.git\n  GIT_TAG main\n)\nFetchContent_MakeAvailable(patternia)\n\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>CPM.cmake:</p> <pre><code>CPMAddPackage(\"gh:sentomk/patternia@main\")\n</code></pre> <p>This fits well in reproducible CI pipelines and modern CMake workflows.</p>"},{"location":"guide/installation/#2-install-and-consume-via-find_package","title":"2. Install and consume via <code>find_package()</code>","text":"<p>Patternia provides full CMake package export support.</p> <p>Install:</p> <pre><code>cmake -B build\ncmake --build build\ncmake --install build --prefix /path/to/install\n</code></pre> <p>Use in any project:</p> <pre><code>find_package(patternia REQUIRED)\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>This is the recommended method for system-wide integration, packaging, and distribution.</p>"},{"location":"guide/installation/#3-add-patternia-as-a-git-submodule","title":"3. Add Patternia as a Git submodule","text":"<pre><code>git submodule add https://github.com/sentomk/patternia extern/patternia\n</code></pre> <p>Then in your CMake project:</p> <pre><code>add_subdirectory(extern/patternia)\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>This approach keeps Patternia version-controlled inside your repository and works well for mid- to large-scale projects.</p>"},{"location":"guide/installation/#4-include-the-include-directory-directly","title":"4. Include the <code>include/</code> directory directly","text":"<p>This is the simplest approach. Just add Patternia\u2019s header path to your target:</p> <pre><code>target_include_directories(your_target\n  PRIVATE /path/to/patternia/include\n)\n</code></pre> <p>No configuration, no installation, immediately usable.</p>"},{"location":"patterns/foreword/","title":"Pattern System Architecture","text":"<p>Patternia is built around a single architectural idea: matching should be a first-class, composable, zero-overhead operation in C++.</p> <p>Most C++ projects rely heavily on hand-written branching logic\u2014nested <code>if</code> statements, large <code>switch</code> blocks, duplicated comparisons, and one-off helper functions. These mechanisms are powerful but structurally limited:</p> <ul> <li>Logic becomes scattered across functions.  </li> <li>Conditions cannot be abstracted or composed easily.  </li> <li>Type-dependent paths require RTTI or explicit <code>dynamic_cast</code>.  </li> <li>Value-dependent paths become deeply imperative and repetitive.  </li> <li>Maintenance requires editing many disconnected branches.</li> </ul> <p>Patternia introduces a dedicated Pattern System to unify these forms of branching under a single semantic model.</p> <p>At its core, a Pattern is an object that describes a condition, and the system determines how to evaluate that condition safely and efficiently. All patterns\u2014whether they describe a value, a predicate, or a type\u2014share the same conceptual role:</p> <ol> <li> <p>Describe a match rule.    A pattern encapsulates the logic for deciding whether a subject satisfies a condition.</p> </li> <li> <p>Compose into larger rules.    Patterns form an algebra: they can be combined into richer logic without changing control flow.</p> </li> <li> <p>Participate in the matching pipeline.    The system evaluates patterns in sequence and invokes handlers for the first matching rule.</p> </li> </ol> <p>The Pattern System is not an auxiliary feature. It is the architectural foundation on which the entire library\u2014value dispatch, type dispatch, and later variant dispatch\u2014is built.</p> <p>This chapter examines the architectural model of the Pattern System and clarifies how different pattern categories cooperate to define matching behavior. The discussion begins with value patterns and type patterns as foundational components.</p> <ul> <li>Value Patterns </li> <li>Type Patterns</li> </ul> <p>Their APIs appear elsewhere; here we focus on their design purpose, abstraction model, and role within the match pipeline.</p>"},{"location":"patterns/type/","title":"Type Patterns \u2014 Architectural Perspective","text":"<p>Type Patterns define the part of the Pattern System dedicated to type-level dispatch. They describe conditions about what a value is, rather than how it behaves or what its runtime value contains.</p> <p>They solve a central architectural problem in C++ codebases:</p> <p>How do we express type-dependent logic without RTTI, virtual inheritance, or manual <code>if constexpr</code> chains?</p> <p>Type Patterns provide a unified answer.</p>"},{"location":"patterns/type/#1-type-level-semantics-as-first-class-objects","title":"1. Type-Level Semantics as First-Class Objects","text":"<p>In typical C++ systems, type-specific logic is embedded in:</p> <ul> <li>Template specializations  </li> <li><code>std::variant</code> visitor lambdas  </li> <li>Chains of <code>if constexpr (std::is_same_v&lt;T, ...&gt;)</code> </li> <li>RTTI (<code>typeid</code>, <code>dynamic_cast</code>)  </li> </ul> <p>These mechanisms work but lack a uniform abstraction for type conditions.</p> <p>Type Patterns elevate type checks to first-class pattern objects, enabling the same:</p> <ul> <li>Composition  </li> <li>Reuse  </li> <li>Declarative structure  </li> </ul> <p>that Value Patterns provide for runtime data.</p>"},{"location":"patterns/type/#2-zero-cost-type-dispatch","title":"2. Zero-Cost Type Dispatch","text":"<p>All type decisions in Patternia are resolved through normal C++ type inspection and inlining. The Pattern System introduces:</p> <ul> <li>No RTTI  </li> <li>No virtual calls  </li> <li>No runtime type discrimination  </li> <li>No dynamic polymorphism  </li> </ul> <p>By making type checks structural (not reflective), Patternia provides the performance profile needed for high-throughput or low-latency applications.</p>"},{"location":"patterns/type/#3-unifying-value-and-type-domains","title":"3. Unifying Value and Type Domains","text":"<p>A key architectural goal is that Value Patterns and Type Patterns participate in the same matching pipeline.</p> <p>This allows rules such as:</p> <ul> <li>\"If the subject is an <code>int</code> and greater than zero\u2026\"  </li> <li>\"If the subject is a <code>std::string</code> and equals 'start'\u2026\"  </li> <li>\"If the subject is from this template family and satisfies a numeric guard\u2026\"</li> </ul> <p>The system does not treat type and value as separate languages. They are part of one cohesive pattern algebra.</p>"},{"location":"patterns/type/#4-foundation-for-variant-dispatch","title":"4. Foundation for Variant Dispatch","text":"<p>The upcoming Variant Layer relies directly on Type Patterns.</p> <p>Matching an active alternative of <code>std::variant</code> is fundamentally a type-level operation:</p> <ul> <li>If the active type is <code>T</code>\u2026  </li> <li>If the active type belongs to <code>{A, B, C}</code>\u2026  </li> <li>If the alternative is any specialization of a template family\u2026</li> </ul> <p>Type Patterns make these decisions explicit and reusable.</p> <p>In other words, they are not an optional feature; they are a structural part of the library\u2019s dispatch model.</p>"},{"location":"patterns/type/#summary","title":"Summary","text":"<p>Architecturally, Type Patterns:</p> <ul> <li>Represent type-based semantics independently of runtime values  </li> <li>Provide a uniform abstraction for type dispatch  </li> <li>Integrate with the same compositional model used by Value Patterns  </li> <li>Enable zero-overhead matching  </li> <li>Form the basis for variant-aware pattern layers</li> </ul> <p>They are the type-theoretic pillar of Patternia\u2019s Pattern System.</p>"},{"location":"patterns/value/","title":"Value Patterns \u2014 Architectural Perspective","text":"<p>Value Patterns represent the part of the Pattern System concerned with runtime values. They describe conditions on concrete data: numbers, strings, states, commands, and any object that can be inspected without involving its type structure.</p> <p>From an architectural perspective, Value Patterns serve three core roles:</p>"},{"location":"patterns/value/#1-unifying-value-level-logic","title":"1. Unifying Value-Level Logic","text":"<p>In conventional C++, comparisons and conditions are expressed through imperative constructs:</p> <ul> <li><code>if (x == 42)</code> </li> <li><code>if (size &lt; capacity)</code> </li> <li><code>if (name == \"start\")</code> </li> <li><code>if (x &gt; 0 &amp;&amp; x &lt; 10)</code> </li> </ul> <p>Each condition is tied to surrounding control flow. Value Patterns decouple the expression of conditions from the control structure that uses them.</p> <p>As a result:</p> <ul> <li>Value conditions become reusable units.</li> <li>Complex value logic becomes declarative\u2014described, not executed.</li> <li>Matching rules become centralized and maintainable.</li> </ul>"},{"location":"patterns/value/#2-enabling-compositional-semantics","title":"2. Enabling Compositional Semantics","text":"<p>Patterns obey a formal algebra. Value Patterns can be combined with logical operators to describe richer semantics without duplicating comparisons or control logic.</p> <p>This provides architectural benefits:</p> <ul> <li>Conditions become first-class objects.  </li> <li>Rules can be assembled, reused, refined, or shared across modules.  </li> <li>Large matching systems can be built from small, orthogonal components.</li> </ul> <p>This capability is essential as the library grows toward supporting predicate guards, custom user-defined patterns, and domain-specific pattern sets.</p>"},{"location":"patterns/value/#3-integrating-with-the-match-pipeline","title":"3. Integrating with the Match Pipeline","text":"<p>At match time, Value Patterns participate in a common evaluation pipeline:</p> <ol> <li>The subject is passed to each pattern.  </li> <li>The pattern decides, independently, whether the subject satisfies its rule.  </li> <li>A matching pattern triggers a handler and short-circuits evaluation.</li> </ol> <p>Value Patterns do not influence the structure of evaluation\u2014only the semantics of the condition. This separation of responsibilities keeps the system modular and allows different pattern families to coexist imperatively.</p>"},{"location":"patterns/value/#summary","title":"Summary","text":"<p>Architecturally, Value Patterns:</p> <ul> <li>Represent value-level semantics in declarative form  </li> <li>Promote reusable, composable conditions  </li> <li>Integrate seamlessly into the shared match pipeline  </li> <li>Prepare the ground for higher-level constructs (predicates, guards, domain-specific rules)</li> </ul> <p>They are the foundational layer of runtime data dispatch in Patternia.</p>"}]}