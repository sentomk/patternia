{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Patternia","text":"<p>Patternia is a modern C++ pattern-matching DSL designed to make dispatch logic clear, expressive, and type-safe \u2014 without sacrificing performance or compilation efficiency.</p> <p>It provides a structured way to express matching rules through composable patterns, including value patterns, type patterns, and extensible DSL operators.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>#include &lt;ptn/patternia.hpp&gt;\nusing namespace ptn;\n\nint x = 42;\n\nauto result =\n  match(x)\n    .when(lit(0) &gt;&gt; \"zero\")\n    .when(lit(42) &gt;&gt; \"answer\")\n    .when(type::is&lt;int&gt; &gt;&gt; \"int value\")\n    .otherwise(\"other\");\n</code></pre> <p>Patternia evaluates patterns in order and returns the result associated with the first successful match.</p>"},{"location":"#why-patternia","title":"Why Patternia","text":"<ul> <li>Header-only, zero dependencies</li> <li>Declarative matching style</li> <li>Strongly typed DSL</li> <li>Composable value, type, and predicate patterns</li> <li>Clean chaining model: <code>match().when().otherwise()</code></li> <li>Ready for integration into modern C++ projects</li> </ul>"},{"location":"#core-concepts","title":"Core Concepts","text":"<p>Patternia organizes matching logic into a simple layered model:</p> <ul> <li> <p>Value Patterns   Match literals, ranges, and custom predicates.</p> </li> <li> <p>Type Patterns   Match exact types, type lists, or template families.</p> </li> <li> <p>Variant Patterns (in development)   Structured matching for <code>std::variant</code> and user-defined sum types.</p> </li> <li> <p>DSL Operators <code>&gt;&gt;</code> (pattern \u2192 handler), <code>&amp;&amp;</code>, <code>||</code>, <code>!</code> for pattern composition.</p> </li> </ul>"},{"location":"#get-started","title":"Get Started","text":"<p>To begin using Patternia, see:</p> <ul> <li>Installation</li> <li>Getting Started</li> <li>Concepts</li> </ul>"},{"location":"#explore-the-pattern-system","title":"Explore the Pattern System","text":"<ul> <li>Value Patterns</li> <li>Type Patterns</li> <li>Variant Patterns</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>match()</li> <li>value patterns</li> <li>type patterns</li> <li>variant</li> <li>DSL Operators</li> </ul>"},{"location":"#project","title":"Project","text":"<ul> <li>Roadmap</li> <li>Releases</li> <li>GitHub Repository</li> </ul> <p>Patternia aims to make logical structure explicit \u2014 so your C++ code becomes easier to read, reason about, and extend.</p>"},{"location":"guide/getting-started/","title":"Getting Started","text":"<p>Patternia is a header-only library. Once installed or fetched into your project, you can start using pattern matching immediately.</p> <p>Below is the minimal working example demonstrating the core DSL:</p>"},{"location":"guide/getting-started/#optional-recommended-code-style","title":"Optional: Recommended Code Style","text":"<p>To keep your chained <code>.when()</code> and <code>.otherwise()</code> expressions visually aligned and easy to scan, you can add a minimal <code>.clang-format</code> to your project root:</p> <pre><code># patternia .clang-format (minimal)\nBasedOnStyle: LLVM\nIndentWidth: 2            # or 4\nContinuationIndentWidth: 4 # or 6\nColumnLimit: 0\nBinPackArguments: false\nBinPackParameters: false\nBreakBeforeBinaryOperators: None\n</code></pre> <p>With this style, multi-line match expressions remain clean and consistent:</p> <pre><code>auto out =\n    match(5)\n      .when(lt(0) &gt;&gt; \"neg\")\n      .when(gt(0) &gt;&gt; \"pos\")\n      .otherwise(\"other\");\n</code></pre>"},{"location":"guide/getting-started/#basic-example","title":"Basic Example","text":"<pre><code>#include &lt;ptn/patternia.hpp&gt;\n#include &lt;iostream&gt;\nusing namespace ptn;\n\nint main() {\n  int x = 42;\n\n  auto result =\n    match(x)\n      .when(lit(0)       &gt;&gt; \"zero\")\n      .when(lit(42)      &gt;&gt; \"answer to everything\")\n      .when(pred([](int v){ return v % 2 == 0; }) &gt;&gt; \"even\")\n      .otherwise(\"other\");\n\n  std::cout &lt;&lt; result &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>answer to everything\n</code></pre>"},{"location":"guide/getting-started/#type-based-matching","title":"Type-based Matching","text":"<p>Patternia provides a type layer for matching based on static type.</p> <pre><code>std::variant&lt;int, float, std::string&gt; v = 3.14f;\n\nauto out = match(v)\n  .when(type::is&lt;int&gt;    &gt;&gt; \"int\")\n  .when(type::is&lt;float&gt;  &gt;&gt; \"float\")\n  .when(type::is&lt;std::string&gt; &gt;&gt; \"string\")\n  .otherwise(\"unknown\");\n</code></pre>"},{"location":"guide/getting-started/#relational-patterns","title":"Relational Patterns","text":"<p>Patternia\u2019s relational DSL (<code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>) works on any comparable value.</p> <pre><code>int score = 87;\n\nauto grade = match(score)\n  .when(value(score &lt; 60)  &gt;&gt; \"F\")\n  .when(score &gt;= 90        &gt;&gt; \"A\")\n  .when(score &gt;= 80        &gt;&gt; \"B\")\n  .when(score &gt;= 70        &gt;&gt; \"C\")\n  .otherwise(\"D\");\n</code></pre>"},{"location":"guide/getting-started/#predicates","title":"Predicates","text":"<p>Arbitrary logic can be wrapped into concise predicate patterns:</p> <pre><code>auto res = match(x)\n  .when(pred([](int v){ return v % 2 == 1; }) &gt;&gt; \"odd\")\n  .otherwise(\"even\");\n</code></pre>"},{"location":"guide/getting-started/#case-insensitive-matching","title":"Case-insensitive matching","text":"<pre><code>std::string s = \"Ok\";\n\nauto out = match(s)\n  .when(lit_ci(\"OK\") &gt;&gt; \"accepted\")\n  .otherwise(\"rejected\");\n</code></pre>"},{"location":"guide/getting-started/#no-macros-no-reflection-no-magic","title":"No macros. No reflection. No magic","text":"<p>Patternia compiles down to normal C++ control flow using inlined pattern objects. There is no runtime overhead beyond executing the selected handler.</p>"},{"location":"guide/installation/","title":"Installation","text":"<p>Patternia is a header-only C++ library. There is no build system, no linking step, and no external dependency.</p> <p>You can integrate Patternia into your project in any of the following ways.</p>"},{"location":"guide/installation/#1-recommended-fetch-patternia-automatically","title":"1. Recommended: Fetch Patternia automatically","text":"<p>You may choose to fetch Patternia as a remote dependency during configuration.</p> <p>FetchContent:</p> <pre><code>include(FetchContent)\nFetchContent_Declare(patternia\n  GIT_REPOSITORY https://github.com/sentomk/patternia.git\n  GIT_TAG main\n)\nFetchContent_MakeAvailable(patternia)\n\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>CPM.cmake:</p> <pre><code>CPMAddPackage(\"gh:sentomk/patternia@main\")\n</code></pre> <p>This fits well in reproducible CI pipelines and modern CMake workflows.</p>"},{"location":"guide/installation/#2-install-and-consume-via-find_package","title":"2. Install and consume via <code>find_package()</code>","text":"<p>Patternia provides full CMake package export support.</p> <p>Install:</p> <pre><code>cmake -B build\ncmake --build build\ncmake --install build --prefix /path/to/install\n</code></pre> <p>Use in any project:</p> <pre><code>find_package(patternia REQUIRED)\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>This is the recommended method for system-wide integration, packaging, and distribution.</p>"},{"location":"guide/installation/#3-add-patternia-as-a-git-submodule","title":"3. Add Patternia as a Git submodule","text":"<pre><code>git submodule add https://github.com/sentomk/patternia extern/patternia\n</code></pre> <p>Then in your CMake project:</p> <pre><code>add_subdirectory(extern/patternia)\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>This approach keeps Patternia version-controlled inside your repository and works well for mid- to large-scale projects.</p>"},{"location":"guide/installation/#4-include-the-include-directory-directly","title":"4. Include the <code>include/</code> directory directly","text":"<p>This is the simplest approach. Just add Patternia\u2019s header path to your target:</p> <pre><code>target_include_directories(your_target\n  PRIVATE /path/to/patternia/include\n)\n</code></pre> <p>No configuration, no installation, immediately usable.</p>"}]}