{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Patternia Documentation","text":"<p>A modern C++ pattern matching DSL</p> <p>Patternia is a modern C++ pattern-matching DSL designed to make dispatch logic clear, expressive, and type-safe \u2014 without sacrificing performance or compilation efficiency.</p>"},{"location":"#navigation","title":"Navigation","text":""},{"location":"#quick-start","title":"Quick Start","text":"<ul> <li>Installation - How to integrate Patternia into your project</li> <li>Getting Started - Complete examples from basics to advanced</li> </ul>"},{"location":"#pattern-system","title":"Pattern System","text":"<ul> <li>Pattern System Overview - Understand Patternia's design philosophy</li> <li>Value Patterns - Value matching with literals, case-insensitive strings, predicates</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>API Documentation - Complete API reference for all functions and patterns</li> </ul>"},{"location":"#project-information","title":"Project Information","text":"<ul> <li>Roadmap - Future development directions and plans</li> <li>Releases - Version update history</li> </ul>"},{"location":"#core-features","title":"Core Features","text":"<ul> <li>Header-only: Zero dependencies, plug-and-play</li> <li>Declarative Syntax: <code>match().when().otherwise()</code> chaining</li> <li>Type Safety: Compile-time guarantees, zero runtime overhead</li> <li>Rich Patterns: Literal patterns, case-insensitive patterns, predicate patterns</li> <li>DSL Operators: <code>&gt;&gt;</code> for pattern-handler binding</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>#include &lt;ptn/patternia.hpp&gt;\nusing namespace ptn;\n\nint x = 42;\n\nauto result =\n    match(x)\n      .when(lit(0) &gt;&gt; \"zero\")\n      .when(lit(42) &gt;&gt; \"answer\")\n      .otherwise(\"other\");\n</code></pre> <p>Patternia evaluates patterns in order and returns the result associated with the first successful match.</p>"},{"location":"#where-to-start","title":"Where to Start","text":"<p>If you're new to Patternia, we recommend reading in this order:</p> <ol> <li>Installation - Integrate into your project</li> <li>Getting Started - Learn basic usage</li> <li>Value Patterns - Deep dive into value matching patterns</li> </ol> <p>If you're looking for specific information:</p> <ul> <li>Need a function reference? \u2192 API Documentation</li> <li>Want to understand design philosophy? \u2192 Pattern System Overview</li> <li>Check version updates? \u2192 Releases</li> </ul>"},{"location":"#system-requirements","title":"System Requirements","text":"<ul> <li>C++ Standard: C++17 or later</li> <li>Compilers: GCC \u226511, Clang \u226512, MSVC \u22652019</li> <li>Platforms: Linux, Windows, macOS</li> </ul> Make logical structure explicit, make C++ code more elegant"},{"location":"api/","title":"Patternia API Reference","text":""},{"location":"api/#introduction","title":"Introduction","text":"<p>Patternia provides a comprehensive pattern matching system for C++ with a focus on type safety, performance, and expressiveness. This document outlines the core APIs that constitute Patternia's pattern matching language.</p>"},{"location":"api/#i-match-dsl-core-framework","title":"I. Match DSL Core Framework","text":"<p>The Match DSL forms the foundation of Patternia and determines how users understand the system. These APIs have the highest priority for comprehension.</p>"},{"location":"api/#matchsubject","title":"<code>match(subject)</code>","text":"<p>Role: DSL entry point and evaluation context for the entire system.</p> <p>Syntax: <pre><code>template &lt;typename T&gt;\nconstexpr auto match(T &amp;&amp;value);\n\ntemplate &lt;typename U, typename T&gt;\nconstexpr auto match(T &amp;&amp;value);\n</code></pre></p> <p>Core Characteristics:</p> <ul> <li><code>subject</code> represents the value being matched, not implicit capture</li> <li><code>match()</code> returns a builder object, not immediate execution</li> <li>Cases are evaluated with first-match semantics in sequential order</li> </ul> <p>Basic Usage: <pre><code>match(x)\n  .when(lit(1) &gt;&gt; [] { return \"one\"; })\n  .otherwise(\"default\");\n</code></pre></p> <p>Type Deduction: <pre><code>// Automatic type deduction\nint x = 42;\nmatch(x)  // deduced as int\n\n// Explicit type specification\ndouble d = 3.14;\nmatch&lt;int&gt;(d)  // forces conversion to int\n</code></pre></p>"},{"location":"api/#whenpattern-handler","title":"<code>.when(pattern &gt;&gt; handler)</code>","text":"<p>Role: Primary case definition primitive.</p> <p>Syntax: <pre><code>.when(pattern &gt;&gt; handler)\n</code></pre></p> <p>Key Characteristics:</p> <ul> <li><code>pattern &gt;&gt; handler</code> constitutes a case expression</li> <li>Handler parameters are determined entirely by the pattern's binding behavior</li> <li><code>when</code> registers branches without executing them</li> </ul> <p>Usage Examples:</p> <pre><code>// Handler without bindings\n.when(lit(1) &gt;&gt; [] { return \"one\"; })           // No parameters\n.when(lit(1) &gt;&gt; 42)                              // Value handler\n\n// Handler with bindings\n.when(bind() &gt;&gt; [](int v) { return v * 2; })     // Single binding\n.when(bind(lit(1)) &gt;&gt; [](int subject, int) { })  // Multiple bindings\n</code></pre> <p>Handler Types: - Value Handler: <code>pattern &gt;&gt; value</code> - Returns a fixed value - Function Handler: <code>pattern &gt;&gt; lambda</code> - Receives bound parameters</p>"},{"location":"api/#otherwise-and-end","title":"<code>.otherwise(...)</code> and <code>.end()</code>","text":"<p>These terminal methods represent a distinctive design aspect of Patternia that requires careful explanation.</p>"},{"location":"api/#otherwise","title":"<code>.otherwise(...)</code>","text":"<p>Trigger Condition: Executed when no when clauses match successfully.</p> <p>Purpose: Used for expression-style matching.</p> <p>Characteristics: - Must return a type consistent with other branches - Provides defensive fallback behavior</p> <pre><code>auto r = match(x)\n  .when(lit(1) &gt;&gt; 10)\n  .otherwise(0);  // Default value\n</code></pre> <p>Execution Semantics: <pre><code>auto result = match(42)\n    .when(lit(1) &gt;&gt; \"one\")      // No match\n    .when(lit(2) &gt;&gt; \"two\")      // No match  \n    .when(__ &gt;&gt; \"other\")        // Pattern matches, returns \"other\"\n    .otherwise(\"default\");       // Not executed: pattern already matched\n</code></pre></p>"},{"location":"api/#end","title":"<code>.end()</code>","text":"<p>Purpose: Used for statement-style matching.</p> <p>Characteristics: - Requires all handlers to return void - No fallback execution - Compile-time verification of exhaustive case coverage</p> <pre><code>match(x)\n  .when(lit(1) &gt;&gt; [] { log(\"one\"); })\n  .when(__   &gt;&gt; [] { log(\"other\"); })\n  .end();  // All cases must be covered\n</code></pre> <p>Design Philosophy: This represents a key divergence from Rust/Scala pattern matching systems.</p> <p>Comparison Summary:</p> Feature <code>.otherwise()</code> <code>.end()</code> Return Type Handler-determined <code>void</code> Use Case Expression Statement Safety Always has fallback Compile-time exhaustiveness check Typical Scenario Value computation Side effects execution"},{"location":"api/#ii-pattern-primitives","title":"II. Pattern Primitives","text":"<p>These constitute the vocabulary of Patternia's pattern language.</p>"},{"location":"api/#litvalue","title":"<code>lit(value)</code>","text":"<p>Role: Fundamental value pattern for exact matching.</p> <p>Syntax: <pre><code>template &lt;typename V&gt;\nconstexpr auto lit(V &amp;&amp;v);\n\ntemplate &lt;typename V&gt;\nconstexpr auto lit_ci(V &amp;&amp;v);  // Case-insensitive matching\n</code></pre></p> <p>Semantics: - Uses <code>operator==</code> for precise matching - Produces no bindings - Suitable for enums, integers, literals, and constexpr values</p> <p>Examples: <pre><code>.when(lit(Status::Running) &gt;&gt; ...)    // Enum matching\n.when(lit(42) &gt;&gt; ...)                  // Integer matching\n.when(lit_ci(\"hello\") &gt;&gt; ...)         // Case-insensitive string matching\n</code></pre></p> <p>Supported Types: - Arithmetic types (int, double, float) - Enumeration types - Strings (std::string, std::string_view, const char*) - User-defined types (must support operator==)</p>"},{"location":"api/#__-wildcard","title":"<code>__</code> (Wildcard)","text":"<p>Role: Fallback pattern for matching any value without binding.</p> <p>Syntax: <pre><code>inline constexpr detail::wildcard_t __;\n</code></pre></p> <p>Key Properties:</p> <ul> <li>Matches any value</li> <li>No binding behavior</li> <li>Distinct semantics from <code>.otherwise()</code></li> </ul> <pre><code>.when(__ &gt;&gt; [] { /* Cannot access matched value */ })\n</code></pre> <p>Design Intent: <pre><code>match(value)\n  .when(lit(\"success\") &gt;&gt; \"ok\")\n  .when(lit(\"error\")   &gt;&gt; \"fail\") \n  .when(__             &gt;&gt; \"unknown\")  // Pattern-level fallback\n  .otherwise(\"fallback\");              // Expression-level fallback\n</code></pre></p> <p>Key Distinction: - <code>__</code>: Pattern-level wildcard, participates in matching process - <code>.otherwise()</code>: Expression-level final safety net</p>"},{"location":"api/#bind-binding-pattern","title":"<code>bind()</code> (Binding Pattern)","text":"<p>Role: Soul API of Patternia for explicit value capture.</p> <p>Syntax: <pre><code>constexpr auto bind();                    // Binds entire subject\ntemplate &lt;typename SubPattern&gt;\nconstexpr auto bind(SubPattern &amp;&amp;sub);    // Binds with subpattern matching\n</code></pre></p> <p>Core Concepts:</p> <ol> <li><code>bind()</code> is the exclusive mechanism for explicit binding introduction</li> <li>No implicit binding occurs</li> <li>Binding behavior determines handler parameter lists</li> </ol> <p>Basic Usage: <pre><code>.when(bind() &gt;&gt; [](auto v) { \n    return \"captured: \" + std::to_string(v); \n})\n</code></pre></p> <p>Structural Binding: <pre><code>// Bind structure members\nstruct Point { int x, y; };\n\n.when(bind(has&lt;&amp;Point::x, &amp;Point::y&gt;()) &gt;&gt; [](int subject, int x, int y) {\n    return fmt(\"point({}, {})\", x, y);\n})\n\n// Bind partial members, ignore others\n.when(bind(has&lt;&amp;Point::x, _ign&gt;()) &gt;&gt; [](int subject, int x) {\n    return fmt(\"x={}\", x);\n})\n</code></pre></p> <p>Composite Binding: <pre><code>// Match subpattern first, then bind entire value\n.when(bind(lit(Status::Running)) &gt;&gt; [](int whole_status) {\n    return fmt(\"status code: {}\", whole_status);\n})\n</code></pre></p> <p>Binding Order: - <code>bind(subpattern)</code> binding order: <code>(subject, subpattern_bindings...)</code> - Handler parameter order must correspond to binding order</p>"},{"location":"api/#iii-guard-system","title":"III. Guard System","text":"<p>The Guard system represents a key differentiator for Patternia in the C++ ecosystem.</p>"},{"location":"api/#guard-syntax","title":"<code>[]</code> Guard Syntax","text":"<p>Role: One of Patternia's most distinctive features.</p> <p>Syntax: <pre><code>pattern[guard]\n</code></pre></p> <p>Key Characteristics:</p> <ul> <li>Guard is part of the pattern, not a handler precondition</li> <li>Guard executes after binding but before handler execution</li> <li>Guard failure continues to next case rather than terminating matching</li> </ul> <p>Basic Examples: <pre><code>bind()[_ &gt; 0 &amp;&amp; _ &lt; 10]  // Range check\nbind()[_ % 2 == 0]       // Even number check\n</code></pre></p> <p>Execution Order: <pre><code>.when(bind()[_ &gt; 0] &gt;&gt; [](int v) { \n    // Execution sequence:\n    // 1. bind() matches (always succeeds)\n    // 2. bind() binds (captures value to tuple)\n    // 3. guard evaluation (_ &gt; 0)\n    // 4. handler execution (if guard passes)\n})\n</code></pre></p>"},{"location":"api/#_-placeholder","title":"<code>_</code> (Placeholder)","text":"<p>Role: Predicate constructor for guard expressions.</p> <p>Key Properties:</p> <ul> <li><code>_</code> is not a value but a predicate constructor</li> <li><code>_ &gt; 0</code> constructs a predicate, not a boolean</li> <li>Can only be used within guard contexts</li> </ul> <pre><code>[_ % 2 == 0]           // Even predicate\n[_ &gt; 0 &amp;&amp; _ &lt; 100]     // Range predicate\n</code></pre> <p>Supported Operators: <pre><code>_ &gt; 5           // Greater than\n_ &lt; 10          // Less than\n_ &gt;= 0          // Greater than or equal\n_ &lt;= 100        // Less than or equal\n_ == 42         // Equal to\n_ != 0          // Not equal to\n</code></pre></p> <p>Compound Predicates: <pre><code>[_ &gt; 0 &amp;&amp; _ &lt; 10]     // AND composition\n[_ &lt; 0 || _ &gt; 100]    // OR composition\n</code></pre></p>"},{"location":"api/#argn","title":"<code>arg&lt;N&gt;</code>","text":"<p>Role: Core API for multi-value guard expressions.</p> <p>Syntax: <pre><code>template &lt;std::size_t I&gt;\ninline constexpr arg_t&lt;I&gt; arg{};\n</code></pre></p> <p>Characteristics:</p> <ul> <li><code>arg&lt;0&gt;</code>, <code>arg&lt;1&gt;</code> reference binding results by index</li> <li>Corresponds one-to-one with handler parameter order</li> <li>Supports arithmetic, relational, and logical combinations</li> </ul> <p>Basic Examples: <pre><code>bind(has&lt;&amp;Point::x, &amp;Point::y&gt;())[arg&lt;0&gt; + arg&lt;1&gt; == 0]  // x + y == 0\nbind(has&lt;&amp;Point::x, &amp;Point::y&gt;())[arg&lt;0&gt; &gt; arg&lt;1&gt;]       // x &gt; y\n</code></pre></p> <p>Complex Expressions: <pre><code>bind(has&lt;&amp;Packet::type, &amp;Packet::length&gt;())[arg&lt;0&gt; == 0x01 &amp;&amp; arg&lt;1] == 0]\nbind(has&lt;&amp;Packet::payload&gt;())[arg&lt;0&gt;.size() &gt; 0]\n</code></pre></p> <p>Boundary Checking: Compile-time validation that arg index does not exceed binding count <pre><code>bind(has&lt;&amp;Point::x&gt;())[arg&lt;1&gt; &gt; 0]  // Compile error: only one bound value\n</code></pre>"},{"location":"api/#lambda-guards","title":"Lambda Guards","text":"<p>Custom Predicate Support:</p> <pre><code>auto is_prime = [](int v) {\n    if (v &lt; 2) return false;\n    for (int i = 2; i * i &lt;= v; ++i)\n        if (v % i == 0) return false;\n    return true;\n};\n\nbind()[is_prime]  // Custom predicate\n</code></pre> <p>Multi-parameter Lambda: <pre><code>auto sum_is_even = [](int a, int b) { return (a + b) % 2 == 0; };\n\nbind(has&lt;&amp;Point::x, &amp;Point::y&gt;())[sum_is_even]\n</code></pre></p>"},{"location":"api/#iv-structural-matching","title":"IV. Structural Matching","text":""},{"location":"api/#hastmember","title":"<code>has&lt;&amp;T::member...&gt;</code>","text":"<p>Role: Unique Patternia API for C++ structural decomposition.</p> <p>Syntax: <pre><code>template &lt;auto... Ms&gt;\nconstexpr auto has();\n</code></pre></p> <p>Semantics: Compile-time structural constraint declaration.</p> <p>Core Characteristics: - Declarative structural constraints without value access - Value extraction only occurs within <code>bind()</code> context - Analogous to Rust's <code>{ x, y, .. }</code> syntax</p> <p>Basic Examples: <pre><code>struct Point { int x, y; };\nstruct Packet { uint8_t type; uint16_t length; std::vector&lt;uint8_t&gt; data; };\n\n// Structural checks\nhas&lt;&amp;Point::x, &amp;Point::y&gt;           // Checks for x, y members\nhas&lt;&amp;Packet::type, &amp;Packet::length&gt;  // Checks for type, length members\n</code></pre></p> <p>Placeholder Support: <pre><code>using ptn::pat::_ign;  // or using ptn::_ign;\n\nhas&lt;&amp;Point::x, _ign&gt;    // Checks for x member, ignores others\nhas&lt;&amp;Point::x, nullptr&gt; // Same as above, using nullptr\n</code></pre></p> <p>Integration with bind(): <pre><code>.when(bind(has&lt;&amp;Point::x, &amp;Point::y&gt;()) &gt;&gt; [](int subject, int x, int y) {\n    // subject: entire Point\n    // x: Point::x value\n    // y: Point::y value\n    return fmt(\"({}, {})\", x, y);\n})\n\n// Ignore certain members\n.when(bind(has&lt;&amp;Point::x, _ign&gt;()) &gt;&gt; [](int subject, int x) {\n    return fmt(\"x={}\", x);\n})\n</code></pre></p> <p>Design Philosophy: - <code>has()</code> standalone: structural checking only, no value extraction - <code>bind(has())</code>: structural checking + value extraction - Compile-time validation of member pointer validity</p>"},{"location":"api/#v-composition-and-extension","title":"V. Composition and Extension","text":""},{"location":"api/#guard-composition","title":"<code>&amp;&amp;</code> / <code>||</code> (Guard Composition)","text":"<p>Guard Logical Composition:</p> <pre><code>// AND composition\n[_ &gt; 0 &amp;&amp; _ &lt; 100]                    // Built-in operators\n[(_ &gt; 0) &amp;&amp; (_ &lt; 100)]               // Explicit composition (identical functionality)\n\n// OR composition  \n[_ &lt; 0 || _ &gt; 100]                    // Built-in operators\n[(_ &lt; 0) || (_ &gt; 100)]               // Explicit composition (identical functionality)\n\n// Complex composition\n[(_ &gt; 0 &amp;&amp; _ &lt; 10) || (_ &gt; 90 &amp;&amp; _ &lt;= 100)]\n</code></pre> <p>Multi-value Guard Composition: <pre><code>bind(has&lt;&amp;Point::x, &amp;Point::y&gt;())[arg&lt;0&gt; &gt; 0 &amp;&amp; arg&lt;1] &lt; 0]  // x &gt; 0 &amp;&amp; y &lt; 0\n</code></pre></p> <p>Lambda Composition: <pre><code>auto positive = [](int v) { return v &gt; 0; };\nauto small    = [](int v) { return v &lt; 10; };\n\nbind()[positive &amp;&amp; small]  // Equivalent to [_ &gt; 0 &amp;&amp; _ &lt; 10]\n</code></pre></p>"},{"location":"api/#range-predicates","title":"Range Predicates","text":"<p>Range Checking API:</p> <pre><code>using ptn::pat::mod::rng;\n\n// Closed interval [0, 100]\nrng(0, 100)\n\n// Open interval (0, 100)  \nrng(0, 100, open)\n\n// Left-open right-closed (0, 100]\nrng(0, 100, open_closed)\n\n// Left-closed right-open [0, 100)\nrng(0, 100, closed_open)\n</code></pre> <p>Examples: <pre><code>bind()[rng(0, 100)]        // 0 &lt;= v &lt;= 100\nbind()[rng(0, 100, open)]  // 0 &lt; v &lt; 100\n</code></pre></p>"},{"location":"api/#custom-predicate-guards","title":"Custom Predicate Guards","text":"<p>Custom Predicates:</p> <pre><code>// Simple lambda\nauto is_even = [](int v) { return v % 2 == 0; };\nbind()[is_even]\n\n// Stateful functor\nclass RangeChecker {\n    int lo_, hi_;\npublic:\n    RangeChecker(int lo, int hi) : lo_(lo), hi_(hi) {}\n    bool operator()(int v) const { return lo_ &lt;= v &amp;&amp; v &lt;= hi_; }\n};\n\nbind()[RangeChecker(0, 100)]\n</code></pre> <p>Multi-parameter Predicates: <pre><code>auto sum_equals = [](int a, int b, int target) { return a + b == target; };\n\nbind(has&lt;&amp;Point::x, &amp;Point::y&gt;())[std::bind_front(sum_equals, 10)]\n// Alternative with lambda\nbind(has&lt;&amp;Point::x, &amp;Point::y&gt;())[[](int x, int y) { return x + y == 10; }]\n</code></pre></p>"},{"location":"api/#vi-design-philosophy-summary","title":"VI. Design Philosophy Summary","text":""},{"location":"api/#core-principles","title":"Core Principles","text":"<ol> <li>Explicit over Implicit: All bindings are explicit with no implicit capture</li> <li>Composition over Inheritance: Complex patterns built from primitive composition</li> <li>Type Safety: Compile-time guarantee of type correctness for all operations</li> <li>Zero Overhead: All abstractions resolved at compile-time with no runtime cost</li> </ol>"},{"location":"api/#language-comparison","title":"Language Comparison","text":"Feature Patternia Rust Scala C++17 switch Type Safety Yes Yes Yes Yes Pattern Composition Yes Yes Yes No Guard System Yes Yes Yes No Structural Binding Yes Yes Yes No Zero Overhead Yes Yes Yes Yes Compile-time Checking Yes Yes Yes Partial"},{"location":"api/#extensibility","title":"Extensibility","text":"<p>Patternia's design enables: - Custom pattern types - Custom guard predicates - Complex pattern composition - Seamless integration with existing C++ code</p>"},{"location":"api/#viii-namespace-structure","title":"VIII. Namespace Structure","text":"<p>Patternia employs a layered namespace architecture:</p> <pre><code>ptn/                                    // Root namespace\n\u251c\u2500\u2500 core/                              // Core matching engine\n\u2502   \u251c\u2500\u2500 engine/                        // Matching engine implementation\n\u2502   \u251c\u2500\u2500 dsl/                          // DSL operators\n\u2502   \u2514\u2500\u2500 common/                       // Common utilities and traits\n\u251c\u2500\u2500 pat/                              // Pattern definitions\n\u2502   \u251c\u2500\u2500 base/                         // Pattern base classes\n\u2502   \u251c\u2500\u2500 lit.hpp                        // Literal pattern implementation\n\u2502   \u251c\u2500\u2500 bind.hpp                       // Binding pattern implementation\n\u2502   \u251c\u2500\u2500 wildcard.hpp                   // Wildcard pattern\n\u2502   \u251c\u2500\u2500 structural.hpp                 // Structural pattern\n\u2502   \u2514\u2500\u2500 modifiers/                     // Pattern modifiers\n\u2502       \u2514\u2500\u2500 guard.hpp                  // Guard system\n\u2514\u2500\u2500 meta/                             // Metaprogramming tools\n    \u251c\u2500\u2500 base/                         // Base traits\n    \u251c\u2500\u2500 dsa/                          // Data structures and algorithms\n    \u2514\u2500\u2500 query/                        // Query utilities\n</code></pre>"},{"location":"api/#primary-namespace-aliases","title":"Primary Namespace Aliases","text":"<p>For user convenience, Patternia provides all pattern functions directly in the <code>ptn</code> namespace:</p> <pre><code>namespace ptn {\n  // Core matching\n  using ptn::core::engine::match;\n\n  // Pattern primitives\n  using ptn::pat::lit;\n  using ptn::pat::lit_ci;\n  using ptn::pat::bind;\n  using ptn::pat::__;\n\n  // Guard system\n  using ptn::pat::mod::_;\n  using ptn::pat::mod::arg;\n  using ptn::pat::mod::rng;\n\n  // Structural patterns\n  using ptn::pat::has;\n  using ptn::pat::_ign;\n}\n</code></pre> <p>This API reference focuses on Patternia's core design philosophy and essential APIs, providing readers with an understanding of Patternia's language composition rather than merely a function list. This organization facilitates better comprehension of Patternia's mental model and usage patterns.</p>"},{"location":"design-overview/","title":"Patternia Matching Semantics Overview","text":"<p>(<code>__</code>, <code>.end()</code>, <code>.otherwise()</code> and Destructuring Patterns)</p>"},{"location":"design-overview/#0-core-objectives","title":"0. Core Objectives","text":"<p>Patternia's DSL is designed to satisfy three key principles:</p> <ol> <li>Semantic Clarity:</li> <li>Clear separation between \"pattern-level\" and \"match-level\" responsibilities.</li> <li>Predictable Behavior:</li> <li>Consistent with Rust and the C++ standard proposal P1371R1 <code>inspect</code> mechanism in spirit.</li> <li>User-Friendly:</li> <li>Minimal API coverage for both \"statement-style matching\" and \"expression-style matching\" requirements.</li> </ol> <p>Around these three principles, the entire system can be abstracted into three levels:</p> <ol> <li>Pattern Level: <code>lit(...)</code>, <code>type::is&lt;T&gt;</code>, destructuring, <code>bind(...)</code>, <code>__</code>, etc.</li> <li>Case Level: <code>.when(pattern &gt;&gt; handler)</code>.</li> <li>Match Finalizer Level: <code>.end()</code> / <code>.otherwise(...)</code>.</li> </ol> <p>All discussions below revolve around these three levels.</p>"},{"location":"design-overview/#1-formal-definitions-of-core-concepts","title":"1. Formal Definitions of Core Concepts","text":""},{"location":"design-overview/#11-__-wildcard-pattern","title":"1.1 <code>__</code> (Wildcard Pattern)","text":"<ul> <li><code>__</code> is a pattern used to match \"any value\".</li> <li>It exists only at the Pattern Level and does not control the entire match lifecycle.</li> <li> <p>It plays different roles in different contexts:</p> </li> <li> <p>In literal matching: Serves as a \"fallback case\".</p> </li> <li>In enum/variant-like matching: Serves as a \"fallback for remaining constructors\".</li> <li>In struct destructuring:     Used for \"field-level ignoring\", similar to Rust's <code>_</code> / <code>..</code>.</li> </ul>"},{"location":"design-overview/#12-end-statement-style-match-finalizer","title":"1.2 <code>.end()</code> (Statement-style Match Finalizer)","text":"<ul> <li> <p><code>.end()</code> transforms the builder into statement-style matching:</p> </li> <li> <p>The entire <code>match(...)</code> expression does not return a value.</p> </li> <li>Used only for side effects (printing, logging, state modification, etc.).</li> <li> <p>Corresponds to the statement form in the standard proposal's <code>inspect</code>:</p> </li> <li> <p><code>pattern: statement;</code></p> </li> <li> <p>Constraints:</p> </li> <li> <p>All case handlers must return <code>void</code>.</p> </li> <li> <p>For exhaustible types (enum, bool, variant-like), future exhaustiveness checking will be performed:</p> <ul> <li>Compile-time diagnostics when not all enum values or alternatives are covered.</li> </ul> </li> </ul>"},{"location":"design-overview/#13-otherwise-expression-style-match-finalizer","title":"1.3 <code>.otherwise(...)</code> (Expression-style Match Finalizer)","text":"<ul> <li> <p><code>.otherwise(fallback)</code> transforms the builder into expression-style matching:</p> </li> <li> <p>The entire <code>match(...)</code> has a unified return value.</p> </li> <li>Similar to Rust's <code>let r = match x { ... };</code></li> <li> <p>Corresponds to the expression form in the standard proposal's <code>inspect</code>:</p> </li> <li> <p><code>pattern =&gt; expression,</code></p> </li> <li> <p>Constraints:</p> </li> <li> <p>All <code>.when(pattern &gt;&gt; handler)</code> handlers must return non-void and be type-unifiable.</p> </li> <li> <p><code>.otherwise(...)</code> provides the final fallback value:</p> <ul> <li>Used when no branches match.</li> <li><code>.otherwise(...)</code> terminates the builder and determines the return type.</li> </ul> </li> </ul>"},{"location":"design-overview/#2-semantic-levels-pattern-vs-match-finalizer","title":"2. Semantic Levels: Pattern vs Match Finalizer","text":"<p>Always remember:</p> <p><code>__</code> is a Pattern-level object; <code>.end()</code> and <code>.otherwise()</code> are Match Finalizer-level objects.</p> <p>They solve completely different problems:</p> Role Level Problem Solved <code>__</code> Pattern Level How current case matches \"any/remaining forms\" <code>.end()</code> Match Level Entire match \"executed as statement\" with no return <code>.otherwise</code> Match Level Entire match \"as expression\" with final return value <p>Therefore:</p> <ul> <li><code>__</code> cannot replace <code>.otherwise()</code>:   It doesn't terminate the builder, nor determine return type.</li> <li><code>.otherwise()</code> cannot replace <code>__</code>:   It cannot express \"fallback for remaining constructors/fields in pattern tree\".</li> </ul>"},{"location":"design-overview/#3-end-vs-otherwise-two-modes","title":"3. <code>.end()</code> vs <code>.otherwise()</code>: Two Modes","text":""},{"location":"design-overview/#31-end-statement-style-matching","title":"3.1 <code>.end()</code> \u2014 Statement-style Matching","text":"<p>Use Cases:</p> <ul> <li>Only care about side effects, no return value needed.</li> <li>Want exhaustiveness checking for enum/variant-like types.</li> </ul> <p>Semantic Characteristics:</p> <ul> <li>All handlers must return <code>void</code>.</li> <li>Return type is <code>void</code>.</li> <li>Exhaustible types will be checked for \"complete coverage\".</li> </ul> <p>Example (enum):</p> <pre><code>enum class Status { Pending, Running, Failed };\n\nmatch(status)\n    .when(lit(Status::Pending) &gt;&gt; [] { log(\"Pending\"); })\n    .when(lit(Status::Running) &gt;&gt; [] { log(\"Running\"); })\n    .when(__ &gt;&gt; [] { log(\"Other\"); })  // pattern-level fallback\n    .end();                            // match finalizer, no return value\n</code></pre> <p>Rust Analogy:</p> <pre><code>match status {\n    Status::Pending =&gt; log(\"Pending\"),\n    Status::Running =&gt; log(\"Running\"),\n    _               =&gt; log(\"Other\"),\n};\n</code></pre>"},{"location":"design-overview/#32-otherwise-expression-style-matching","title":"3.2 <code>.otherwise(...)</code> \u2014 Expression-style Matching","text":"<p>Use Cases:</p> <ul> <li>Need to compute a value from match:</li> <li>Generate labels for enum/variant;</li> <li>Calculate results, map strings, etc.</li> </ul> <p>Semantic Characteristics:</p> <ul> <li>All handlers return the same type (or commonly convertible).</li> <li><code>.otherwise(fallback)</code> provides the final value.</li> <li>The entire <code>match(...)</code> expression has a concrete type.</li> </ul> <p>Example (Rust counterpart):</p> <pre><code>int x = 2;\n\nauto res = match(x)\n    .when(lit(1) &gt;&gt; \"one\")\n    .when(lit(2) &gt;&gt; \"two\")\n    .otherwise(\"Other\");\n\nstd::cout &lt;&lt; res;\n</code></pre> <p>Corresponding Rust:</p> <pre><code>let x = 2;\nlet res = match x {\n    1 =&gt; \"one\",\n    2 =&gt; \"two\",\n    _ =&gt; \"Other\",\n};\nprintln!(\"{}\", res);\n</code></pre>"},{"location":"design-overview/#4-__-roles-in-different-scenarios","title":"4. <code>__</code> Roles in Different Scenarios","text":""},{"location":"design-overview/#41-as-case-fallback-wildcard","title":"4.1 As \"Case Fallback\" Wildcard","text":"<p>Simplest literal scenario:</p> <pre><code>auto res = match(x)\n    .when(lit(1) &gt;&gt; \"one\")\n    .when(lit(2) &gt;&gt; \"two\")\n    .when(__ &gt;&gt; \"other\")    // __ is pattern-level fallback here\n    .otherwise(\"panic\");    // match-level fallback (defensive, usually never triggered)\n</code></pre> <ul> <li><code>__ &gt;&gt; \"other\"</code>: Represents \"all other values\".</li> <li><code>.otherwise(\"panic\")</code>: Ideally never used, but can serve as defensive fallback.</li> </ul>"},{"location":"design-overview/#42-remaining-branch-in-enumvariant-like-matching","title":"4.2 Remaining Branch in Enum/Variant-like Matching","text":"<p>For variant-like types (including future kind/alternative patterns):</p> <pre><code>auto info = match(v)\n    .when(type::is&lt;int&gt;         &gt;&gt; \"int\")\n    .when(type::is&lt;std::string&gt; &gt;&gt; \"string\")\n    .when(__                     &gt;&gt; \"other-kind\")\n    .otherwise(\"panic\"); // match-level defense, ideally never triggered\n</code></pre> <p>Here:</p> <ul> <li><code>__</code> represents \"all alternatives except int and string\".</li> <li><code>.otherwise(\"panic\")</code> is the final match-level defense.</li> </ul>"},{"location":"design-overview/#43-field-wildcard-in-struct-destructuring","title":"4.3 Field Wildcard in Struct Destructuring","text":"<p>Corresponding Rust:</p> <pre><code>match p {\n    Point { x, .. } =&gt; println!(\"{}\", x),\n}\n</code></pre> <p>Patternia ideal DSL example:</p> <pre><code>struct Point { int x, y, z; };\n\nmatch(p)\n    .when(Point{ bind(x), __, __ } &gt;&gt; [&amp;] {\n        std::cout &lt;&lt; x;\n    })\n    .end();\n</code></pre> <p>Meaning:</p> <ul> <li>Matches object of type <code>Point</code>.</li> <li>Only binds first field <code>x</code>.</li> <li>Other fields (<code>y</code>, <code>z</code>) are ignored with <code>__</code>.</li> </ul> <p><code>__</code> here is field-level wildcard, not a fallback case. Future named field versions could also be extended:</p> <pre><code>.when(Point{ .x = bind(x), .y = __, .z = __ } &gt;&gt; ...)\n</code></pre>"},{"location":"design-overview/#5-when-do-__-and-otherwise-appear-together","title":"5. When Do <code>__</code> and <code>.otherwise()</code> \"Appear Together\"?","text":""},{"location":"design-overview/#51-typical-scenario-expression-match-pattern-fallback-match-fallback","title":"5.1 Typical Scenario: Expression Match + Pattern Fallback + Match Fallback","text":"<p>In complex modes:</p> <ul> <li>Pattern level might already use <code>__</code> for fallback matching all forms;</li> <li>But you can still set <code>.otherwise(...)</code> at match level as \"defensive branch that should never trigger\".</li> </ul> <p>Example:</p> <pre><code>auto label = match(v)\n    .when(type::is&lt;int&gt;         &gt;&gt; \"int\")\n    .when(type::is&lt;std::string&gt; &gt;&gt; \"string\")\n    .when(__                     &gt;&gt; \"other-kind\") // pattern-level fallback\n    .otherwise(\"unreachable\");                    // match-level defense\n</code></pre> <p>Here <code>.otherwise(\"unreachable\")</code> should ideally never trigger in normal logic, but:</p> <ul> <li>Can be used for debug/assertions;</li> <li>Semantically completely valid in the DSL.</li> </ul>"},{"location":"design-overview/#52-expression-matches-must-use-otherwise","title":"5.2 Expression Matches Must Use <code>.otherwise()</code>","text":"<p>Whenever you write:</p> <pre><code>auto res = match(subject)\n    .when(...)\n    ...\n</code></pre> <p>And want to assign the result to <code>res</code>, then expression-style matches must be terminated with <code>.otherwise(...)</code>. Even if the pattern level is already covered by <code>__</code>.</p> <p>The reason is:</p> <ul> <li>Builder needs a finalizer to determine \"this is an expression-style match\";</li> <li>C++ needs a clear return type, and <code>.otherwise(...)</code> is exactly this entry point.</li> </ul>"},{"location":"design-overview/#53-when-does-match-level-fallback-trigger","title":"5.3 When Does Match-level Fallback Trigger?","text":"<p>The <code>.otherwise(handler)</code> is triggered in two scenarios:</p>"},{"location":"design-overview/#scenario-1-no-pattern-matches","title":"Scenario 1: No Pattern Matches","text":"<p>When none of the <code>.when()</code> cases match the subject value:</p> <pre><code>auto result = match(42)\n    .when(lit(1) &gt;&gt; \"one\")      // \u274c No match\n    .when(lit(2) &gt;&gt; \"two\")      // \u274c No match  \n    .when(__ &gt;&gt; \"other\")           // \u274c No match (if no wildcard case for this specific scenario)\n    .otherwise(\"default\");         // \u2705 TRIGGERED: Returns \"default\"\n</code></pre>"},{"location":"design-overview/#scenario-2-explicit-match-level-defense","title":"Scenario 2: Explicit Match-level Defense","text":"<p>Even when patterns (including <code>__</code>) could theoretically match everything, <code>.otherwise()</code> still serves as a defensive fallback:</p> <pre><code>auto result = match(42)\n    .when(lit(1) &gt;&gt; \"one\")      // \u274c No match\n    .when(lit(2) &gt;&gt; \"two\")      // \u274c No match\n    .when(__ &gt;&gt; \"other\")           // \u2705 PATTERN MATCHES: Returns \"other\"\n    .otherwise(\"unreachable\");      // \u274c NOT TRIGGERED: Pattern already matched\n</code></pre> <p>Key Principles:</p> <ol> <li>Pattern Priority: Cases are evaluated in order. The first matching pattern wins.</li> <li>Wildcard Coverage: <code>__</code> matches any value, so if placed before <code>.otherwise()</code>, it will typically match first.</li> <li>Defensive Purpose: <code>.otherwise()</code> as \"unreachable\" provides runtime safety for logic errors or unexpected inputs.</li> </ol>"},{"location":"design-overview/#practical-example-with-pattern-vs-match-fallback","title":"Practical Example with Pattern vs Match Fallback:","text":"<pre><code>// This demonstrates the execution order\nauto classify = std::string input;\n\nauto result = match(classify)\n    .when(lit_ci(\"error\") &gt;&gt; \"ERROR\")           // Case 1: Specific match\n    .when(lit_ci(\"warning\") &gt;&gt; \"WARNING\")       // Case 2: Specific match  \n    .when(__ &gt;&gt; \"UNKNOWN\")                      // Case 3: Pattern fallback\n    .otherwise(\"INVALID INPUT\");                 // Case 4: Match-level fallback (unlikely to trigger)\n\n// For input \"INFO\":\n// - Cases 1,2: No match\n// - Case 3 (__): Matches \u2192 Returns \"UNKNOWN\"  \n// - Case 4 (.otherwise): NOT triggered\n\n// For input null/empty string (if it reaches match):\n// - Cases 1,2,3: All could potentially handle this\n// - Depending on implementation, might reach .otherwise() as defense\n</code></pre> <p>Summary: - Pattern-level fallback (<code>__</code>): Only affects case matching process at pattern level - Match-level fallback (<code>.otherwise()</code>): Determines final return value of match expression - When <code>__</code> can match all pattern forms: <code>.otherwise()</code> serves only as defensive fallback and typically won't trigger</p>"},{"location":"design-overview/#6-when-to-use-end-when-to-use-otherwise","title":"6. When to Use <code>.end()</code>, When to Use <code>.otherwise()</code>?","text":"<p>Use this decision table to directly guide user usage.</p>"},{"location":"design-overview/#61-decision-table","title":"6.1 Decision Table","text":"Requirement Recommended Usage Only execute side effects, no match return value Use <code>.end()</code> Need to get a value from match (like Rust) Use <code>.otherwise(...)</code> Want exhaustiveness checking for enum/variant Use <code>.end()</code> Express \"all remaining matching forms\" Use <code>__</code> in pattern Express \"entire match fallback return value\" Use <code>.otherwise(...)</code>"},{"location":"design-overview/#62-typical-patterns","title":"6.2 Typical Patterns","text":"<ol> <li>Statement-style with fallback:</li> </ol> <pre><code>match(s)\n    .when(lit(Status::Pending) &gt;&gt; [] { ... })\n    .when(lit(Status::Running) &gt;&gt; [] { ... })\n    .when(__ &gt;&gt; [] { ... }) // fallback\n    .end();\n</code></pre> <ol> <li>Expression-style, Rust counterpart:</li> </ol> <pre><code>auto res = match(x)\n    .when(lit(1) &gt;&gt; \"one\")\n    .when(lit(2) &gt;&gt; \"two\")\n    .otherwise(\"Other\");\n</code></pre> <ol> <li>Struct destructuring + field wildcard:</li> </ol> <pre><code>match(p)\n    .when(Point{ bind(x), __, __ } &gt;&gt; [&amp;] { return x; })\n    .otherwise(0);\n</code></pre> <ol> <li>Variant-like + type matching + pattern fallback:</li> </ol> <pre><code>auto info = match(v)\n    .when(type::is&lt;int&gt;         &gt;&gt; \"int\")\n    .when(type::is&lt;std::string&gt; &gt;&gt; \"string\")\n    .when(__                     &gt;&gt; \"other-kind\")\n    .otherwise(\"panic\");\n</code></pre>"},{"location":"design-overview/#7-implementation-details","title":"7. Implementation Details","text":""},{"location":"design-overview/#71-builder-execution-flow","title":"7.1 Builder Execution Flow","text":"<p>The builder pattern ensures that matches are only executed when properly terminated:</p> <pre><code>// Without .end() or .otherwise():\nmatch(value).when(lit(42) &gt;&gt; [] { /* handler */ });\n// Result: Nothing is executed - builder remains unterminated\n\n// With .end():\nmatch(value).when(lit(42) &gt;&gt; [] { /* handler */ }).end();\n// Result: match_impl::eval(subject_, cases_, std::move(dummy_fallback));\n\n// With .otherwise():\nmatch(value).when(lit(42) &gt;&gt; [] { /* handler */ }).otherwise(fallback);\n// Result: match_impl::eval(subject_, cases_, std::move(final_handler));\n</code></pre> <p>Key Points:</p> <ul> <li>Without <code>.end()</code> or <code>.otherwise()</code>, the builder never triggers execution.</li> <li><code>.end()</code> creates an empty fallback handler for statement-style execution.</li> <li><code>.otherwise()</code> uses the provided handler as the final fallback for expression-style execution.</li> </ul>"},{"location":"design-overview/#72-type-safety-guarantees","title":"7.2 Type Safety Guarantees","text":"<ul> <li>Statement-style (<code>.end()</code>): All handlers must return <code>void</code></li> <li>Expression-style (<code>.otherwise()</code>): All handlers must return compatible types</li> <li>Pattern matching: Type-safe heterogeneous comparisons</li> <li>Binding: Compile-time type deduction for bound values</li> </ul>"},{"location":"design-overview/#8-future-roadmap","title":"8. Future Roadmap","text":"<p>To make these semantics truly user-friendly, Patternia's future plans include:</p> <ol> <li>Exhaustiveness Checking for <code>.end()</code>:</li> <li>Enum/bool: Static checking for complete enum value coverage.</li> <li>Variant-like: Check for complete alternative coverage.</li> <li> <p>Provide \"missing case\" and \"useless case\" hints.</p> </li> <li> <p>Formal Struct Destructuring DSL:</p> </li> <li>Positional: <code>Point{ bind(x), __, __ }</code></li> <li>Named: <code>Point{ .x = bind(x), .y = __, .z = __ }</code></li> <li> <p>Support guard/bind/nested patterns.</p> </li> <li> <p>Improved Error Messages:</p> </li> <li>Non-void handler under <code>.end()</code> \u2192 Clear error.</li> <li>Handler return type inconsistency under <code>.otherwise()</code> \u2192 Clear type diagnostics.</li> <li>Wildcard + <code>.otherwise()</code> redundancy \u2192 Hint \"potentially redundant patterns\".</li> </ol> <p>This comprehensive design ensures that Patternia provides clear, predictable, and user-friendly pattern matching semantics while maintaining type safety and performance guarantees.</p>"},{"location":"changelog/releases/","title":"Patternia Releases","text":"<ul> <li>v0.5.2 - December 10, 2025</li> <li>v0.5.3 - December 14, 2025</li> </ul>"},{"location":"changelog/v0.5.2/","title":"Patternia v0.5.2 Release Notes","text":"<p>Release Date: December 10, 2025  Version: 0.5.2</p>"},{"location":"changelog/v0.5.2/#overview","title":"Overview","text":"<p>Patternia v0.5.2 introduces the wildcard pattern <code>__</code> and provides comprehensive documentation updates. This release focuses on semantic clarity, improved developer experience, and establishing a solid foundation for future exhaustiveness checking features.</p>"},{"location":"changelog/v0.5.2/#new-features","title":"New Features","text":""},{"location":"changelog/v0.5.2/#wildcard-pattern-__","title":"Wildcard Pattern (<code>__</code>)","text":"<p>Added: <code>ptn::__</code> - A pattern that matches any value without binding.</p> <pre><code>// Basic wildcard usage\nmatch(value)\n    .when(lit(0) &gt;&gt; \"zero\")\n    .when(__ &gt;&gt; \"other\")  // Matches any other value\n    .end();\n</code></pre> <p>Key Characteristics: - Always matches regardless of input value - Binds no data (returns empty tuple <code>std::tuple&lt;&gt;</code>) - More explicit than <code>bind()</code> when no capture is needed - Essential for catch-all cases and future struct destructuring</p>"},{"location":"changelog/v0.5.2/#enhanced-terminal-method-semantics","title":"Enhanced Terminal Method Semantics","text":"<p>Improved: Clear distinction between <code>.end()</code> and <code>.otherwise()</code> terminal methods.</p>"},{"location":"changelog/v0.5.2/#end-statement-style-matching","title":"<code>.end()</code> - Statement-style Matching","text":"<ul> <li>For void-returning matches</li> <li>Designed for exhaustiveness checking (future feature)</li> <li>Used when only side effects are needed</li> </ul>"},{"location":"changelog/v0.5.2/#otherwisehandler-expression-style-matching","title":"<code>.otherwise(handler)</code> - Expression-style Matching","text":"<ul> <li>For value-returning matches</li> <li>Provides explicit fallback behavior</li> <li>Used when computing results from matches</li> </ul>"},{"location":"changelog/v0.5.2/#fallback-trigger-mechanism-clarification","title":"Fallback Trigger Mechanism Clarification","text":"<p>Added: Detailed explanation of when <code>.otherwise()</code> is triggered:</p> <ol> <li>No Pattern Matches: When no <code>.when()</code> cases match the subject</li> <li>Defensive Fallback: Even with pattern coverage, provides runtime safety</li> </ol> <p>Key Principle: First matching pattern wins, regardless of fallback types.</p>"},{"location":"changelog/v0.5.2/#documentation-improvements","title":"Documentation Improvements","text":""},{"location":"changelog/v0.5.2/#design-overview-document","title":"Design Overview Document","text":"<p>Added: <code>docs/design-overview.md</code> - Comprehensive guide covering: - Three-level architecture (Pattern \u2192 Case \u2192 Match Finalizer) - Semantic differences between <code>__</code>, <code>.end()</code>, and <code>.otherwise()</code> - Usage scenarios and best practices - Implementation details and execution flow - Future roadmap for exhaustiveness checking</p>"},{"location":"changelog/v0.5.2/#enhanced-api-reference","title":"Enhanced API Reference","text":"<p>Updated: <code>docs/api.md</code> with: - Complete wildcard pattern documentation - Detailed comparison of terminal methods - Implementation notes about builder execution - Future features section with exhaustiveness checking roadmap</p>"},{"location":"changelog/v0.5.2/#improved-user-guide","title":"Improved User Guide","text":"<p>Updated: <code>README.md</code> featuring: - Wildcard pattern examples - Clear terminal method guidance - Future roadmap section - Better usage decision tables</p>"},{"location":"changelog/v0.5.2/#internal-improvements","title":"Internal Improvements","text":""},{"location":"changelog/v0.5.2/#comment-standardization","title":"Comment Standardization","text":"<p>Fixed: Consistent English comment style across all modified files: - <code>include/ptn/pattern/wildcard.hpp</code> - Added comprehensive file header - <code>include/ptn/core/engine/detail/builder_impl.hpp</code> - Completed member variable documentation - <code>include/ptn/core/common/common_traits.hpp</code> - Enhanced type trait comments - <code>samples/test.cpp</code> - Added explanatory comments and examples</p>"},{"location":"changelog/v0.5.2/#builder-implementation-enhancements","title":"Builder Implementation Enhancements","text":"<p>Improved: Better documentation in <code>match_builder</code> implementation: - Clear explanation of builder execution flow - Documented member variable purposes - Enhanced inline comments for complex template logic</p>"},{"location":"changelog/v0.5.2/#architecture-changes","title":"Architecture Changes","text":""},{"location":"changelog/v0.5.2/#three-level-design-formalization","title":"Three-Level Design Formalization","text":"<p>Patternia now explicitly follows a three-level architecture:</p> <ol> <li>Pattern Level: <code>lit()</code>, <code>bind()</code>, <code>__</code>, etc.</li> <li>Case Level: <code>.when(pattern &gt;&gt; handler)</code></li> <li>Match Finalizer Level: <code>.end()</code> / <code>.otherwise()</code></li> </ol> <p>This design ensures: - Clear separation of concerns - Predictable behavior matching Rust/standard proposals - Extensible foundation for future features</p>"},{"location":"changelog/v0.5.2/#semantic-clarity-improvements","title":"Semantic Clarity Improvements","text":"<p>Established: Clear distinctions between: - Pattern-level wildcards (<code>__</code>) vs match-level fallbacks (<code>.otherwise()</code>) - Statement-style (<code>.end()</code>) vs expression-style (<code>.otherwise()</code>) matching - Field-level ignoring vs case-level fallbacks</p>"},{"location":"changelog/v0.5.2/#usage-examples","title":"Usage Examples","text":""},{"location":"changelog/v0.5.2/#basic-pattern-matching","title":"Basic Pattern Matching","text":"<pre><code>#include &lt;ptn/patternia.hpp&gt;\n\n// Expression-style match\nauto result = match(value)\n    .when(lit(1) &gt;&gt; \"one\")\n    .when(lit(2) &gt;&gt; \"two\") \n    .when(__ &gt;&gt; \"other\")  // Wildcard fallback\n    .otherwise(\"default\");  // Match-level fallback\n</code></pre>"},{"location":"changelog/v0.5.2/#statement-style-matching","title":"Statement-style Matching","text":"<pre><code>// Statement-style match with exhaustiveness (future)\nmatch(status)\n    .when(lit(Status::Pending) &gt;&gt; [] { log(\"pending\"); })\n    .when(lit(Status::Running) &gt;&gt; [] { log(\"running\"); })\n    .when(__ &gt;&gt; [] { log(\"other\"); })  // Pattern fallback\n    .end();  // Statement termination\n</code></pre>"},{"location":"changelog/v0.5.2/#enum-with-wildcard","title":"Enum with Wildcard","text":"<pre><code>enum class Color { Red, Green, Blue };\nColor c = Color::Green;\n\nmatch(c)\n    .when(lit(Color::Red) &gt;&gt; [] { std::cout &lt;&lt; \"red\"; })\n    .when(lit(Color::Green) &gt;&gt; [] { std::cout &lt;&lt; \"green\"; })\n    .when(__ &gt;&gt; [] { std::cout &lt;&lt; \"other\"; })  // Catch-all\n    .end();\n</code></pre>"},{"location":"changelog/v0.5.2/#bug-fixes","title":"Bug Fixes","text":""},{"location":"changelog/v0.5.2/#api-clarity","title":"API Clarity","text":"<p>Fixed: Ambiguous terminal method behavior - Clear distinction between <code>.end()</code> and <code>.otherwise()</code>  - Better examples showing appropriate use cases</p>"},{"location":"changelog/v0.5.3/","title":"Patternia v0.5.3 Release Notes","text":"<p>Release Date: December 14, 2025  Version: 0.5.3</p>"},{"location":"changelog/v0.5.3/#overview","title":"Overview","text":"<p>Patternia v0.5.3 introduces advanced pattern matching capabilities with guard predicates, enhanced binding mechanisms, structural decomposition patterns, and range matching utilities. This release significantly expands the expressiveness of pattern matching while maintaining zero-overhead performance and type safety.</p>"},{"location":"changelog/v0.5.3/#new-features","title":"New Features","text":""},{"location":"changelog/v0.5.3/#enhanced-binding-patterns-bind-and-bindsubpattern","title":"Enhanced Binding Patterns (<code>bind()</code> and <code>bind(subpattern)</code>)","text":"<p>Enhanced: <code>bind()</code> function with subpattern support for conditional binding.</p> <pre><code>// Basic binding - captures the subject itself\nmatch(value)\n    .when(bind() &gt;&gt; [](auto x) { /* use x */ })\n    .end();\n\n// Binding with subpattern - first matches subpattern, then captures subject\nmatch(number)\n    .when(bind(lit(42)) &gt;&gt; [](auto x) { /* x is 42, subject is also captured */ })\n    .when(bind([](auto n) { return n &gt; 0; }) &gt;&gt; [](auto subject, auto n) {\n        return fmt::format(\"positive: {} (subject: {})\", n, subject);\n    })\n    .otherwise(\"non-positive\");\n</code></pre> <p>Key Capabilities: - <code>bind()</code> - Captures the subject itself as a single-element tuple - <code>bind(subpattern)</code> - First matches with subpattern, then captures both subject and subpattern bindings - Type-safe binding with compile-time validation - Integration with all existing pattern types</p>"},{"location":"changelog/v0.5.3/#guard-predicates-and-placeholder-expressions","title":"Guard Predicates and Placeholder Expressions","text":"<p>Added: Comprehensive guard system with placeholder <code>_</code> and predicate combinators.</p> <pre><code>// Placeholder-based guard expressions\nmatch(number)\n    .when(bind()[_ &gt; 10 &amp;&amp; _ &lt; 100] &gt;&gt; \"two-digit\")\n    .when(bind()[_ &gt;= 100] &gt;&gt; \"three-or-more-digits\")\n    .otherwise(\"single-digit\");\n\n// Range predicates with different modes\nmatch(value)\n    .when(bind()[rng(0, 10)] &gt;&gt; \"small closed\")           // [0, 10]\n    .when(bind()[rng(10, 20, open)] &gt;&gt; \"medium open\")    // (10, 20)\n    .when(bind()[rng(20, 30, open_closed)] &gt;&gt; \"large open-closed\") // (20, 30]\n    .when(bind()[rng(30, 40, closed_open)] &gt;&gt; \"xlarge closed-open\") // [30, 40)\n    .otherwise(\"out of range\");\n\n// Lambda guards for complex conditions\nmatch(data)\n    .when(bind()[[](auto x) { return x.is_valid() &amp;&amp; x.size() &gt; 0; }] &gt;&gt; \"valid\")\n    .otherwise(\"invalid\");\n</code></pre> <p>Guard Features: - <code>_</code> placeholder for creating comparison expressions (<code>_ &gt; 10</code>, <code>_ == 42</code>, etc.) - <code>rng()</code> function for range predicates with four modes: <code>closed</code>, <code>open</code>, <code>open_closed</code>, <code>closed_open</code> - Predicate combinators: <code>&amp;&amp;</code> (logical AND) and <code>||</code> (logical OR) - Lambda guard support for complex custom conditions - Type-safe guard predicate evaluation</p>"},{"location":"changelog/v0.5.3/#structural-decomposition-patterns-has","title":"Structural Decomposition Patterns (<code>has&lt;&gt;</code>)","text":"<p>Added: <code>has&lt;&amp;T::field...&gt;()</code> for aggregate and struct decomposition.</p> <pre><code>struct Point { int x, y; };\nstruct Circle { Point center; int radius; };\n\n// Basic field presence checking\nmatch(point)\n    .when(has&lt;&amp;Point::x, &amp;Point::y&gt; &gt;&gt; \"valid point\")\n    .otherwise(\"invalid point\");\n\n// Combining with binding for field access\nmatch(circle)\n    .when(has&lt;&amp;Circle::center, &amp;Circle::radius&gt; &gt;&gt; bind() &gt;&gt; [](auto c) {\n        return fmt::format(\"circle at ({}, {}) with radius {}\", \n                           c.center.x, c.center.y, c.radius);\n    })\n    .otherwise(\"invalid circle\");\n\n// Multi-level structural matching\nmatch(complex_data)\n    .when(has&lt;&amp;Data::points&gt; &gt;&gt; bind()[[](auto pts) { return !pts.empty(); }]\n         &gt;&gt; [](auto data, auto pts) {\n        return fmt::format(\"data with {} points\", pts.size());\n    })\n    .otherwise(\"empty or invalid data\");\n</code></pre> <p>Structural Pattern Features: - Compile-time validation of member pointer parameters - Support for multiple field pointers in single pattern - Integration with binding patterns for field access - Zero-overhead struct decomposition - Type-safe member access checking</p>"},{"location":"changelog/v0.5.3/#advanced-pattern-composition","title":"Advanced Pattern Composition","text":"<p>Enhanced: Seamless integration between all pattern types.</p> <pre><code>// Complex pattern combining all features\nmatch(data)\n    .when(\n        has&lt;&amp;Data::value, &amp;Data::status&gt; &gt;&gt; \n        bind()[[](auto d) { return d.value &gt; 0; } &amp;&amp; [](auto d) { return d.status == Status::Active; }]\n     &gt;&gt; [](auto d, auto value, auto status) {\n        return fmt::format(\"active data: {} (status: {})\", value, status);\n    })\n    .when(\n        has&lt;&amp;Data::value&gt; &gt;&gt; \n        bind([](auto v) { return v &lt; 0; })[_ &gt; -100]\n     &gt;&gt; [](auto subject, auto v) {\n        return fmt::format(\"negative value: {} (subject: {})\", v, subject);\n    })\n    .otherwise(\"no match\");\n</code></pre>"},{"location":"changelog/v0.5.3/#internal-improvements","title":"Internal Improvements","text":""},{"location":"changelog/v0.5.3/#pattern-framework-extensions","title":"Pattern Framework Extensions","text":"<p>Enhanced: Advanced pattern matching infrastructure: - Guard predicate evaluation system - Enhanced binding pattern composition - Structural pattern validation - Type-safe predicate combinators</p>"},{"location":"changelog/v0.5.3/#type-system-improvements","title":"Type System Improvements","text":"<p>Added: Comprehensive type support for: - Member pointer validation in <code>has&lt;&gt;</code> - Guard predicate type detection - Binding contract forwarding - Template parameter deduction</p>"},{"location":"changelog/v0.5.3/#performance-optimizations","title":"Performance Optimizations","text":"<p>Maintained: Zero-overhead guarantees: - Compile-time guard predicate evaluation where possible - Inlined pattern matching - Optimal struct field access - Efficient tuple composition for binding</p>"},{"location":"changelog/v0.5.3/#architecture-changes","title":"Architecture Changes","text":""},{"location":"changelog/v0.5.3/#guard-system-architecture","title":"Guard System Architecture","text":"<p>Added: Comprehensive guard framework: - <code>guard_predicate_tag</code> for type detection - <code>placeholder_t</code> with comparison operator overloads - <code>binary_predicate</code> for standard comparisons - <code>range_predicate</code> with configurable modes - <code>guarded_pattern</code> wrapper for pattern composition</p>"},{"location":"changelog/v0.5.3/#enhanced-binding-system","title":"Enhanced Binding System","text":"<p>Expanded: Binding pattern capabilities: - <code>binding_pattern</code> for subject capture - <code>binding_as_pattern</code> for subpattern composition - Tuple concatenation for multi-value binding - Forwarding binding contracts to inner patterns</p>"},{"location":"changelog/v0.5.3/#structural-pattern-framework","title":"Structural Pattern Framework","text":"<p>Added: Member pointer-based decomposition: - Compile-time member pointer validation - <code>has_pattern</code> for field presence checking - Integration with existing pattern ecosystem - Zero-overhead field access</p>"},{"location":"changelog/v0.5.3/#usage-examples","title":"Usage Examples","text":""},{"location":"changelog/v0.5.3/#guard-with-placeholders","title":"Guard with Placeholders","text":"<pre><code>match(score)\n    .when(bind()[_ &gt;= 90] &gt;&gt; \"excellent\")\n    .when(bind()[_ &gt;= 80 &amp;&amp; _ &lt; 90] &gt;&gt; \"good\")\n    .when(bind()[_ &gt;= 70 &amp;&amp; _ &lt; 80] &gt;&gt; \"average\")\n    .otherwise(\"needs improvement\");\n</code></pre>"},{"location":"changelog/v0.5.3/#range-matching-with-different-modes","title":"Range Matching with Different Modes","text":"<pre><code>match(temperature)\n    .when(bind()[rng(18.0, 22.0)] &gt;&gt; \"comfortable\")           // [18, 22]\n    .when(bind()[rng(22.0, 30.0, open)] &gt;&gt; \"warm\")            // (22, 30)\n    .when(bind()[rng(30.0, 40.0, open_closed)] &gt;&gt; \"hot\")      // (30, 40]\n    .when(bind()[rng(-10.0, 18.0, closed_open)] &gt;&gt; \"cool\")   // [-10, 18)\n    .otherwise(\"extreme temperature\");\n</code></pre>"},{"location":"changelog/v0.5.3/#structural-pattern-with-guards","title":"Structural Pattern with Guards","text":"<pre><code>struct Employee {\n    std::string name;\n    int age;\n    double salary;\n    bool active;\n};\n\nmatch(employee)\n    .when(\n        has&lt;&amp;Employee::age, &amp;Employee::salary, &amp;Employee::active&gt; &gt;&gt;\n        bind()[[](auto e) { return e.active &amp;&amp; e.age &gt;= 25; }]\n     &gt;&gt; [](auto e, auto age, auto salary, auto active) {\n        return fmt::format(\"active employee: {} ({} years, ${:.2f})\", \n                          e.name, age, salary);\n    })\n    .when(\n        has&lt;&amp;Employee::age&gt; &gt;&gt;\n        bind([](auto age) { return age &lt; 25; })[_ &gt;= 18]\n     &gt;&gt; [](auto subject, auto age) {\n        return fmt::format(\"young employee: {} years old\", age);\n    })\n    .otherwise(\"no match\");\n</code></pre>"},{"location":"changelog/v0.5.3/#complex-pattern-composition","title":"Complex Pattern Composition","text":"<pre><code>match(container)\n    .when(\n        has&lt;&amp;Container::size&gt; &gt;&gt;\n        bind()[[](auto c) { return c.size() &gt; 0; } &amp;&amp; [](auto c) { return c.size() &lt;= 100; }]\n     &gt;&gt; [](auto c, auto size) {\n        return fmt::format(\"container with {} items\", size);\n    })\n    .when(\n        has&lt;&amp;Container::size&gt; &gt;&gt;\n        bind()[[](auto c) { return c.size() == 0; }]\n     &gt;&gt; [](auto c) {\n        return \"empty container\";\n    })\n    .otherwise(\"large or invalid container\");\n</code></pre>"},{"location":"changelog/v0.5.3/#bug-fixes","title":"Bug Fixes","text":""},{"location":"changelog/v0.5.3/#pattern-validation","title":"Pattern Validation","text":"<p>Fixed: Edge cases in pattern matching: - Guard predicate type deduction for complex expressions - Binding contract forwarding for nested patterns - Member pointer validation in <code>has&lt;&gt;</code> patterns - Range boundary evaluation edge cases</p>"},{"location":"changelog/v0.5.3/#compilation-issues","title":"Compilation Issues","text":"<p>Resolved: Template compilation problems: - Guard predicate instantiation failures - Binding pattern type deduction - Structural pattern member access validation - Predicate combinator type resolution</p>"},{"location":"guide/getting-started/","title":"Getting Started","text":"<p>Patternia is a header-only library. Once installed or fetched into your project, you can start using pattern matching immediately.</p> <p>Below is minimal working example demonstrating the core DSL:</p>"},{"location":"guide/getting-started/#optional-recommended-code-style","title":"Optional: Recommended Code Style","text":"<p>To keep your chained <code>.when()</code> and <code>.otherwise()</code> expressions visually aligned and easy to scan, you can add a minimal <code>.clang-format</code> to your project root:</p> <pre><code># patternia .clang-format (minimal)\nBasedOnStyle: LLVM\nIndentWidth: 2            # or 4\nContinuationIndentWidth: 4 # or 6\nColumnLimit: 0\nBinPackArguments: false\nBinPackParameters: false\nBreakBeforeBinaryOperators: None\n</code></pre> <p>With this style, multi-line match expressions remain clean and consistent:</p> <pre><code>auto out =\n    match(5)\n      .when(lit(0) &gt;&gt; \"zero\")\n      .when(lit(5) &gt;&gt; \"five\")\n      .otherwise(\"other\");\n</code></pre>"},{"location":"guide/getting-started/#basic-example","title":"Basic Example","text":"<pre><code>#include &lt;ptn/patternia.hpp&gt;\n#include &lt;iostream&gt;\nusing namespace ptn;\n\nint main() {\n  int x = 42;\n\n  auto result =\n    match(x)\n      .when(lit(0)       &gt;&gt; \"zero\")\n      .when(lit(42)      &gt;&gt; \"answer to everything\")\n      .otherwise(\"other\");\n\n  std::cout &lt;&lt; result &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>answer to everything\n</code></pre>"},{"location":"guide/getting-started/#case-insensitive-matching","title":"Case-insensitive matching","text":"<pre><code>std::string s = \"Ok\";\n\nauto out = match(s)\n  .when(lit_ci(\"OK\") &gt;&gt; \"accepted\")\n  .otherwise(\"rejected\");\n</code></pre>"},{"location":"guide/getting-started/#no-macros-no-reflection-no-magic","title":"No macros. No reflection. No magic","text":"<p>Patternia compiles down to normal C++ control flow using inlined pattern objects. There is no runtime overhead beyond executing the selected handler.</p>"},{"location":"guide/installation/","title":"Installation","text":"<p>Patternia is a header-only C++ library. There is no build system, no linking step, and no external dependency.</p> <p>You can integrate Patternia into your project in any of the following ways.</p>"},{"location":"guide/installation/#1-recommended-fetch-patternia-automatically","title":"1. Recommended: Fetch Patternia automatically","text":"<p>You may choose to fetch Patternia as a remote dependency during configuration.</p> <p>FetchContent:</p> <pre><code>include(FetchContent)\nFetchContent_Declare(patternia\n  GIT_REPOSITORY https://github.com/sentomk/patternia.git\n  GIT_TAG main\n)\nFetchContent_MakeAvailable(patternia)\n\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>CPM.cmake:</p> <pre><code>CPMAddPackage(\"gh:sentomk/patternia@main\")\n</code></pre> <p>This fits well in reproducible CI pipelines and modern CMake workflows.</p>"},{"location":"guide/installation/#2-install-and-consume-via-find_package","title":"2. Install and consume via <code>find_package()</code>","text":"<p>Patternia provides full CMake package export support.</p> <p>Install:</p> <pre><code>cmake -B build\ncmake --build build\ncmake --install build --prefix /path/to/install\n</code></pre> <p>Use in any project:</p> <pre><code>find_package(patternia REQUIRED)\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>This is the recommended method for system-wide integration, packaging, and distribution.</p>"},{"location":"guide/installation/#3-add-patternia-as-a-git-submodule","title":"3. Add Patternia as a Git submodule","text":"<pre><code>git submodule add https://github.com/sentomk/patternia extern/patternia\n</code></pre> <p>Then in your CMake project:</p> <pre><code>add_subdirectory(extern/patternia)\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>This approach keeps Patternia version-controlled inside your repository and works well for mid- to large-scale projects.</p>"},{"location":"guide/installation/#4-include-the-include-directory-directly","title":"4. Include the <code>include/</code> directory directly","text":"<p>This is the simplest approach. Just add Patternia\u2019s header path to your target:</p> <pre><code>target_include_directories(your_target\n  PRIVATE /path/to/patternia/include\n)\n</code></pre> <p>No configuration, no installation, immediately usable.</p>"},{"location":"patterns/foreword/","title":"Pattern System Architecture","text":"<p>Patternia is built around a single architectural idea: matching should be a first-class, composable, zero-overhead operation in C++.</p> <p>Most C++ projects rely heavily on hand-written branching logic\u2014nested <code>if</code> statements, large <code>switch</code> blocks, duplicated comparisons, and one-off helper functions. These mechanisms are powerful but structurally limited:</p> <ul> <li>Logic becomes scattered across functions.  </li> <li>Conditions cannot be abstracted or composed easily.  </li> <li>Type-dependent paths require RTTI or explicit <code>dynamic_cast</code>.  </li> <li>Value-dependent paths become deeply imperative and repetitive.  </li> <li>Maintenance requires editing many disconnected branches.</li> </ul> <p>Patternia introduces a dedicated Pattern System to unify these forms of branching under a single semantic model.</p> <p>At its core, a Pattern is an object that describes a condition, and the system determines how to evaluate that condition safely and efficiently. All patterns\u2014whether they describe a value, a predicate, or a type\u2014share the same conceptual role:</p> <ol> <li> <p>Describe a match rule.    A pattern encapsulates the logic for deciding whether a subject satisfies a condition.</p> </li> <li> <p>Compose into larger rules.    Patterns form an algebra: they can be combined into richer logic without changing control flow.</p> </li> <li> <p>Participate in the matching pipeline.    The system evaluates patterns in sequence and invokes handlers for the first matching rule.</p> </li> </ol> <p>The Pattern System is not an auxiliary feature. It is the architectural foundation on which the entire library\u2014value dispatch, type dispatch, and later variant dispatch\u2014is built.</p> <p>This chapter examines the architectural model of the Pattern System and clarifies how different pattern categories cooperate to define matching behavior. The discussion begins with value patterns and type patterns as foundational components.</p> <ul> <li>Value Patterns </li> <li>Type Patterns</li> </ul> <p>Their APIs appear elsewhere; here we focus on their design purpose, abstraction model, and role within the match pipeline.</p>"},{"location":"patterns/type/","title":"Type Patterns \u2014 Architectural Perspective","text":"<p>Type Patterns define the part of the Pattern System dedicated to type-level dispatch. They describe conditions about what a value is, rather than how it behaves or what its runtime value contains.</p> <p>They solve a central architectural problem in C++ codebases:</p> <p>How do we express type-dependent logic without RTTI, virtual inheritance, or manual <code>if constexpr</code> chains?</p> <p>Type Patterns provide a unified answer.</p>"},{"location":"patterns/type/#1-type-level-semantics-as-first-class-objects","title":"1. Type-Level Semantics as First-Class Objects","text":"<p>In typical C++ systems, type-specific logic is embedded in:</p> <ul> <li>Template specializations  </li> <li><code>std::variant</code> visitor lambdas  </li> <li>Chains of <code>if constexpr (std::is_same_v&lt;T, ...&gt;)</code> </li> <li>RTTI (<code>typeid</code>, <code>dynamic_cast</code>)  </li> </ul> <p>These mechanisms work but lack a uniform abstraction for type conditions.</p> <p>Type Patterns elevate type checks to first-class pattern objects, enabling the same:</p> <ul> <li>Composition  </li> <li>Reuse  </li> <li>Declarative structure  </li> </ul> <p>that Value Patterns provide for runtime data.</p>"},{"location":"patterns/type/#2-zero-cost-type-dispatch","title":"2. Zero-Cost Type Dispatch","text":"<p>All type decisions in Patternia are resolved through normal C++ type inspection and inlining. The Pattern System introduces:</p> <ul> <li>No RTTI  </li> <li>No virtual calls  </li> <li>No runtime type discrimination  </li> <li>No dynamic polymorphism  </li> </ul> <p>By making type checks structural (not reflective), Patternia provides the performance profile needed for high-throughput or low-latency applications.</p>"},{"location":"patterns/type/#3-unifying-value-and-type-domains","title":"3. Unifying Value and Type Domains","text":"<p>A key architectural goal is that Value Patterns and Type Patterns participate in the same matching pipeline.</p> <p>This allows rules such as:</p> <ul> <li>\"If the subject is an <code>int</code> and greater than zero\u2026\"  </li> <li>\"If the subject is a <code>std::string</code> and equals 'start'\u2026\"  </li> <li>\"If the subject is from this template family and satisfies a numeric guard\u2026\"</li> </ul> <p>The system does not treat type and value as separate languages. They are part of one cohesive pattern algebra.</p>"},{"location":"patterns/type/#4-foundation-for-variant-dispatch","title":"4. Foundation for Variant Dispatch","text":"<p>The upcoming Variant Layer relies directly on Type Patterns.</p> <p>Matching an active alternative of <code>std::variant</code> is fundamentally a type-level operation:</p> <ul> <li>If the active type is <code>T</code>\u2026  </li> <li>If the active type belongs to <code>{A, B, C}</code>\u2026  </li> <li>If the alternative is any specialization of a template family\u2026</li> </ul> <p>Type Patterns make these decisions explicit and reusable.</p> <p>In other words, they are not an optional feature; they are a structural part of the library\u2019s dispatch model.</p>"},{"location":"patterns/type/#summary","title":"Summary","text":"<p>Architecturally, Type Patterns:</p> <ul> <li>Represent type-based semantics independently of runtime values  </li> <li>Provide a uniform abstraction for type dispatch  </li> <li>Integrate with the same compositional model used by Value Patterns  </li> <li>Enable zero-overhead matching  </li> <li>Form the basis for variant-aware pattern layers</li> </ul> <p>They are the type-theoretic pillar of Patternia\u2019s Pattern System.</p>"},{"location":"patterns/value/","title":"Value Patterns \u2014 Architectural Perspective","text":"<p>Value Patterns represent the part of the Pattern System concerned with runtime values. They describe conditions on concrete data: numbers, strings, states, commands, and any object that can be inspected without involving its type structure.</p> <p>From an architectural perspective, Value Patterns serve three core roles:</p>"},{"location":"patterns/value/#1-unifying-value-level-logic","title":"1. Unifying Value-Level Logic","text":"<p>In conventional C++, comparisons and conditions are expressed through imperative constructs:</p> <ul> <li><code>if (x == 42)</code> </li> <li><code>if (name == \"start\")</code> </li> <li><code>if (name == \"START\")</code> (case-insensitive)</li> </ul> <p>Each condition is tied to surrounding control flow. Value Patterns decouple the expression of conditions from the control structure that uses them.</p> <p>As a result:</p> <ul> <li>Value conditions become reusable units.</li> <li>Complex value logic becomes declarative\u2014described, not executed.</li> <li>Matching rules become centralized and maintainable.</li> </ul>"},{"location":"patterns/value/#2-enabling-compositional-semantics","title":"2. Enabling Compositional Semantics","text":"<p>Patterns obey a formal algebra. Value Patterns can be combined with logical operators to describe richer semantics without duplicating comparisons or control logic.</p> <p>This provides architectural benefits:</p> <ul> <li>Conditions become first-class objects.  </li> <li>Rules can be assembled, reused, refined, or shared across modules.  </li> <li>Large matching systems can be built from small, orthogonal components.</li> </ul> <p>This capability is essential as the library grows toward supporting predicate guards, custom user-defined patterns, and domain-specific pattern sets.</p>"},{"location":"patterns/value/#3-integrating-with-the-match-pipeline","title":"3. Integrating with the Match Pipeline","text":"<p>At match time, Value Patterns participate in a common evaluation pipeline:</p> <ol> <li>The subject is passed to each pattern.  </li> <li>The pattern decides, independently, whether the subject satisfies its rule.  </li> <li>A matching pattern triggers a handler and short-circuits evaluation.</li> </ol> <p>Value Patterns do not influence the structure of evaluation\u2014only the semantics of the condition. This separation of responsibilities keeps the system modular and allows different pattern families to coexist imperatively.</p>"},{"location":"patterns/value/#current-implementation","title":"Current Implementation","text":"<p>The current implementation provides:</p>"},{"location":"patterns/value/#literal-patterns","title":"Literal Patterns","text":"<ul> <li><code>lit(value)</code> - Exact value matching</li> <li><code>lit_ci(value)</code> - Case-insensitive string matching (ASCII only)</li> </ul>"},{"location":"patterns/value/#supported-types","title":"Supported Types","text":"<ul> <li>Arithmetic types (int, double, float, etc.)</li> <li>Enum types  </li> <li>Strings (std::string, std::string_view, const char*)</li> <li>User-defined types (must support operator==)</li> </ul>"},{"location":"patterns/value/#dsl-operators","title":"DSL Operators","text":"<ul> <li><code>&gt;&gt;</code> - Pattern-handler binding operator</li> </ul>"},{"location":"patterns/value/#summary","title":"Summary","text":"<p>Architecturally, Value Patterns:</p> <ul> <li>Represent value-level semantics in declarative form  </li> <li>Promote reusable, composable conditions  </li> <li>Integrate seamlessly into the shared match pipeline  </li> <li>Prepare the ground for higher-level constructs (predicates, guards, domain-specific rules)</li> </ul> <p>They are the foundational layer of runtime data dispatch in Patternia.</p>"}]}