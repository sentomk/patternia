{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Patternia Documentation","text":"<p>A modern C++ pattern matching DSL</p> <p>Patternia is a modern C++ pattern-matching DSL designed to make dispatch logic clear, expressive, and type-safe \u2014 without sacrificing performance or compilation efficiency.</p>"},{"location":"#navigation","title":"Navigation","text":""},{"location":"#tutorials","title":"Tutorials","text":"<ul> <li>From Control Flow to Pattern Matching - Start here if you are new to pattern matching</li> <li>Pattern Matching in Other Languages - For readers familiar with pattern matching</li> <li>Custom Predicate Guards - Using guards as part of case definition</li> <li>Example - Policy Constraint Matching - From ad-hoc rules to declarative policies</li> <li>Example - Geometric Constraint Matching - From numeric conditions to declarative shape constraints</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<ul> <li>Getting Started - Complete examples from basics to advanced</li> <li>Installation - How to integrate Patternia into your project</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>API Documentation - Complete API reference for all patterns and functions</li> </ul>"},{"location":"#project-information","title":"Project Information","text":"<ul> <li>Releases - Version update history</li> </ul>"},{"location":"#system-requirements","title":"System Requirements","text":"<ul> <li>C++ Standard: C++17 or later</li> <li>Compilers: GCC \u226511, Clang \u226512, MSVC \u22652019</li> <li>Platforms: Linux, Windows, macOS</li> </ul> Make logical structure explicit, make C++ code more elegant"},{"location":"api/","title":"Patternia API Reference","text":""},{"location":"api/#introduction","title":"Introduction","text":"<p>Patternia provides a comprehensive pattern matching system for C++ with a focus on type safety, performance, and expressiveness. This document outlines the core APIs that constitute Patternia's pattern matching language.</p>"},{"location":"api/#i-match-dsl-core-framework","title":"I. Match DSL Core Framework","text":"<p>The Match DSL forms the foundation of Patternia. It defines how values are inspected, how cases are registered, and how matching is ultimately evaluated.</p>"},{"location":"api/#matchsubject","title":"<code>match(subject)</code>","text":"<p>Role: DSL entry point and evaluation context for the entire system.</p> <p>Syntax: <pre><code>match(subject)\n</code></pre></p> <p>Core Characteristics:</p> <ul> <li><code>subject</code> is the value being matched, not an implicitly captured variable</li> <li><code>match()</code> returns a builder object; no matching is performed immediately</li> <li>Cases are evaluated sequentially using first-match semantics</li> </ul> <p>Basic Usage:</p> <pre><code>match(x)\n  .when(lit(1) &gt;&gt; [] { return \"one\"; })\n  .otherwise(\"default\");\n</code></pre> <p>Type Control:</p> <p>Patternia currently matches the subject as its actual type; there is no <code>match&lt;AsType&gt;(subject)</code> override.</p>"},{"location":"api/#matchsubject-cases","title":"<code>match(subject, cases(...))</code>","text":"<p>Role: Compact syntax for simple matching scenarios.</p> <p>Syntax: <pre><code>match(subject, cases(case1, case2, ...))\n</code></pre></p> <p>Key Characteristics:</p> <ul> <li>Provides a concise alternative to the standard <code>.when()</code> chain syntax</li> <li>No bindings/guards: Cannot be used with <code>bind()</code> or guard expressions</li> <li>Supports both pattern fallback (<code>__</code>) and match fallback patterns</li> <li>Cases are evaluated sequentially using first-match semantics</li> <li>Requires <code>.end()</code> to trigger evaluation when using <code>__</code> pattern</li> </ul> <p>Basic Usage:</p> <pre><code>match(x, cases(\n  lit(1) &gt;&gt; [] { std::cout &lt;&lt; \"one\\n\"; },\n  lit(2) &gt;&gt; [] { std::cout &lt;&lt; \"two\\n\"; },\n  __    &gt;&gt; [] { std::cout &lt;&lt; \"other\\n\"; }\n)).end();\n</code></pre> <p>Limitations:</p> <ul> <li>Cannot use <code>bind()</code> (and therefore cannot use guard expressions <code>[]</code>)</li> <li>Best suited for simple literal and wildcard matching</li> <li>For complex matching with guards, use the standard DSL syntax</li> <li>Must use <code>.end()</code> when using <code>__</code> pattern to trigger evaluation</li> </ul> <p>Design Intent: This syntax is optimized for straightforward value discrimination where the full power of the DSL (guards, complex patterns) is not needed.</p>"},{"location":"api/#whenpattern-handler","title":"<code>.when(pattern &gt;&gt; handler)</code>","text":"<p>Role: Primary case-definition primitive.</p> <p>Syntax:</p> <pre><code>.when(pattern &gt;&gt; handler)\n</code></pre> <p>Key Characteristics:</p> <ul> <li><code>pattern &gt;&gt; handler</code> forms a case expression</li> <li>The handler\u2019s parameter list is determined entirely by the pattern\u2019s binding behavior</li> <li><code>.when()</code> only registers a branch; it does not trigger execution</li> </ul> <p>Usage Examples:</p> <pre><code>// Handler without bindings\n.when(lit(1) &gt;&gt; [] { return \"one\"; })   // No parameters\n.when(lit(2) &gt;&gt; 42)                     // Constant value handler\n\n// Handler with bindings\n.when(bind() &gt;&gt; [](int v) {\n  return v * 2;\n})\n\n// Structural bindings\n.when(\n  bind(has&lt;&amp;Point::x, &amp;Point::y&gt;()) &gt;&gt;\n  [](int x, int y) {\n    return x + y;\n  }\n)\n</code></pre> <p>Handler Forms:</p> <ul> <li> <p>Value Handler \u2014 <code>pattern &gt;&gt; value</code>   Returns a fixed value. Semantically equivalent to a zero-argument function returning a constant.</p> </li> <li> <p>Function Handler \u2014 <code>pattern &gt;&gt; callable</code>   Receives the values produced by the pattern\u2019s bindings.</p> </li> </ul>"},{"location":"api/#otherwise-and-end","title":"<code>.otherwise(...)</code> and <code>.end()</code>","text":"<p>These terminal operations define how a match expression is finalized. The key distinction between them is the use of the <code>__</code> pattern.</p>"},{"location":"api/#otherwise","title":"<code>.otherwise(...)</code>","text":"<p>Role: Match fallback that works in all scenarios.</p> <p>Purpose: Provides a fallback when no prior <code>when</code> clause matches successfully.</p> <p>Characteristics:</p> <ul> <li>Cannot be used when a <code>__</code> pattern is present</li> <li>Acts as a defensive default, not as a regular case</li> <li>Evaluated only if no pattern has already matched</li> </ul> <pre><code>auto r = match(x)\n  .when(lit(1) &gt;&gt; 10)\n  .when(lit(2) &gt;&gt; 20)\n  .otherwise(0);\n</code></pre> <p>Execution Semantics:</p> <pre><code>auto result = match(42)\n  .when(lit(1) &gt;&gt; \"one\")      // No match\n  .when(lit(2) &gt;&gt; \"two\")      // No match\n  .otherwise(\"default\");          // Executed as fallback\n</code></pre>"},{"location":"api/#end","title":"<code>.end()</code>","text":"<p>Purpose: Required when using the <code>__</code> pattern fallback.</p> <p>Characteristics:</p> <ul> <li>Must be used when <code>__</code> pattern is present in the match</li> <li>Can be used with or without return values (not limited to <code>void</code>)</li> <li>Not required when only using <code>.otherwise()</code></li> <li><code>.otherwise()</code> is rejected if a <code>__</code> pattern is present</li> </ul> <pre><code>match(x)\n  .when(lit(1) &gt;&gt; [] { std::cout &lt;&lt; \"one\\n\"; })\n  .when(lit(2) &gt;&gt; [] { std::cout &lt;&lt; \"two\\n\"; })\n  .when(__   &gt;&gt; [] { std::cout &lt;&lt; \"other\\n\"; })  // pattern fallback\n  .end();  // Required for __ to work\n</code></pre> <p>Critical Rule: If <code>__</code> pattern is used without <code>.end()</code>, the <code>__</code> case will not trigger.</p> <p>Design Philosophy: The distinction between <code>.otherwise()</code> and <code>.end()</code> is driven by the <code>__</code> pattern's requirement for match inference.</p>"},{"location":"api/#comparison-summary","title":"Comparison Summary","text":"Feature <code>.otherwise()</code> <code>.end()</code> Key Requirement None Required for <code>__</code> pattern Return Type Handler-determined Handler-determined Fallback Type Match fallback Pattern fallback (<code>__</code>) Usage Constraint Works in all scenarios Must be used with <code>__</code> Typical Use Cases Value computation, defensive fallback Exhaustive matching with <code>__</code>"},{"location":"api/#ii-pattern-primitives","title":"II. Pattern Primitives","text":"<p>Pattern primitives constitute the core vocabulary of Patternia\u2019s pattern language. They describe what is matched, what is ignored, and what is explicitly bound.</p>"},{"location":"api/#litvalue","title":"<code>lit(value)</code>","text":"<p>Role: Fundamental value pattern for exact matching.</p> <p>Syntax: <pre><code>template &lt;typename V&gt;\nconstexpr auto lit(V &amp;&amp;v);\n\ntemplate &lt;typename V&gt;\nconstexpr auto lit_ci(V &amp;&amp;v);  // Case-insensitive matching\n</code></pre></p> <p>Semantics:</p> <ul> <li>Matches the subject using <code>operator==</code></li> <li>Produces no bindings</li> <li>Intended for value-based discrimination</li> </ul> <p>Examples:</p> <pre><code>.when(lit(Status::Running) &gt;&gt; ...)   // Enum matching\n.when(lit(42) &gt;&gt; ...)                // Integer literal\n.when(lit_ci(\"hello\") &gt;&gt; ...)        // Case-insensitive string match\n</code></pre> <p>Supported Types:</p> <ul> <li>Arithmetic types (<code>int</code>, <code>double</code>, <code>float</code>)</li> <li>Enumeration types</li> <li>String types (<code>std::string</code>, <code>std::string_view</code>, <code>const char*</code>)</li> <li>User-defined types providing <code>operator==</code></li> </ul>"},{"location":"api/#__-wildcard","title":"<code>__</code> (Wildcard)","text":"<p>Role: Pattern-level wildcard that matches any value without binding.</p> <p>Syntax:</p> <pre><code>inline constexpr detail::wildcard_t __;\n</code></pre> <p>Key Properties:</p> <ul> <li>Always matches</li> <li>Introduces no bindings</li> <li>Participates in pattern ordering and exhaustiveness</li> </ul> <pre><code>.when(__ &gt;&gt; [] {\n  // No access to the matched value\n})\n</code></pre> <p>Design Intent:</p> <pre><code>match(value)\n  .when(lit(\"success\") &gt;&gt; \"ok\")\n  .when(lit(\"error\")   &gt;&gt; \"fail\")\n  .when(__             &gt;&gt; \"unknown\")  // Pattern-level fallback\n  .end();\n</code></pre> <p>Key Distinction:</p> <ul> <li><code>__</code> \u2014 a pattern that participates in matching and ordering</li> <li><code>.otherwise()</code> \u2014 a match-level fallback executed only if no pattern matches</li> <li><code>__</code> and <code>.otherwise()</code> cannot be combined in the same match</li> </ul>"},{"location":"api/#bind-binding-pattern","title":"<code>bind()</code> (Binding Pattern)","text":"<p>Role: Explicit value binding primitive.</p> <p><code>bind()</code> is the only mechanism in Patternia that introduces bindings into a match.</p> <p>Syntax:</p> <pre><code>constexpr auto bind();                    // Binds the entire subject\n\ntemplate &lt;typename SubPattern&gt;\nconstexpr auto bind(SubPattern &amp;&amp;sub);    // Binds subject conditionally under a subpattern constraint\n</code></pre> <p>Core Principles:</p> <ol> <li>All bindings are explicit</li> <li>No pattern introduces bindings implicitly</li> <li>Binding behavior fully determines handler parameter lists</li> </ol>"},{"location":"api/#binding-the-entire-subject","title":"Binding the Entire Subject","text":"<pre><code>.when(bind() &gt;&gt; [](auto v) {\n  return \"captured: \" + std::to_string(v);\n})\n</code></pre> <ul> <li>The entire subject is bound as a single value</li> <li>The handler receives exactly one parameter</li> </ul>"},{"location":"api/#conditional-binding-with-bindsubpattern","title":"Conditional Binding with <code>bind(subpattern)</code>","text":"<pre><code>.when(\n  bind(lit(Status::Running)) &gt;&gt;\n  [](Status s) {\n    return fmt(\"status = {}\", static_cast&lt;int&gt;(s));\n  }\n)\n````\n\n* `bind(subpattern)` introduces a binding **only if the subpattern matches**\n* The bound value is always the **entire subject**\n* The subpattern itself does **not** introduce bindings unless explicitly designed to do so\n\nThis form is useful when:\n\n* a value must be both **filtered** and **captured**\n* the captured value needs to be reused by the handler\n* the constraint is semantic rather than structural\n\n\n#### Structural Binding with `has&lt;&gt;`\n\n```cpp\nstruct Point { int x, int y; };\n\n.when(\n  bind(has&lt;&amp;Point::x, &amp;Point::y&gt;()) &gt;&gt;\n  [](int x, int y) {\n    return fmt(\"({}, {})\", x, y);\n  }\n)\n</code></pre> <ul> <li><code>has&lt;&gt;</code> describes the required structure</li> <li>Only the listed members are bound</li> <li>No access to unlisted members is provided</li> </ul> <p>Partial binding is expressed by listing only the desired members:</p> <pre><code>.when(\n  bind(has&lt;&amp;Point::x&gt;()) &gt;&gt;\n  [](int x) {\n    return fmt(\"x = {}\", x);\n  }\n)\n</code></pre>"},{"location":"api/#binding-semantics","title":"Binding Semantics","text":"<ul> <li><code>bind()</code> always binds the entire subject</li> <li><code>bind(subpattern)</code> binds the subject, but only if <code>subpattern</code> matches successfully.   If <code>subpattern</code> itself produces bindings (rare/advanced), those may be appended after the subject.</li> <li>The handler parameter order corresponds exactly to the binding order</li> <li>Patterns that do not bind values do not affect handler signatures</li> </ul> <p>[!IMPORTANT] <code>lit()</code> and <code>has&lt;&gt;</code> never introduce bindings by themselves. All bindings are introduced exclusively by <code>bind(...)</code>.</p> <pre><code>// Binding order example\nbind()                        -&gt; (subject)\nbind(lit(...))                -&gt; (subject)\nbind(has&lt;&amp;A::x, &amp;A::y&gt;())     -&gt; (x, y) // because has() is used under bind(), extraction is defined by bind(...)\n</code></pre> <p>Design Rationale:</p> <p>Patternia deliberately separates matching from binding. A pattern answers \u201cdoes this value match?\u201d A binding answers \u201cwhat values become available to the handler?\u201d</p> <p>This separation keeps control flow declarative and data flow explicit.</p>"},{"location":"api/#typeist-and-typeast-variant-type-matching","title":"<code>type::is&lt;T&gt;()</code> and <code>type::as&lt;T&gt;()</code> (Variant Type Matching)","text":"<p>Role: Match <code>std::variant</code> alternatives by type, with optional explicit binding.</p> <p>Syntax: <pre><code>type::is&lt;T&gt;()                 // type-only match\ntype::is&lt;T&gt;(subpattern)       // apply subpattern to the alternative\n\ntype::as&lt;T&gt;()                 // explicit binding sugar for is&lt;T&gt;(bind())\ntype::as&lt;T&gt;(subpattern)       // explicit binding sugar for is&lt;T&gt;(bind(subpattern))\n</code></pre></p> <p>Shorthand: <pre><code>is&lt;T&gt;()   // alias of type::is&lt;T&gt;()\nas&lt;T&gt;()   // alias of type::as&lt;T&gt;()\n</code></pre></p> <p>Key Properties:</p> <ul> <li>Works on <code>std::variant</code> subjects only</li> <li><code>type::is&lt;T&gt;()</code> does not bind values</li> <li><code>type::as&lt;T&gt;()</code> is an explicit binding shortcut; it does not introduce implicit binding</li> <li>Alternative type <code>T</code> must appear exactly once in the variant</li> </ul> <p>Examples:</p> <pre><code>match(v)\n  .when(type::is&lt;int&gt;() &gt;&gt; [] { /* type-only */ })\n  .when(type::as&lt;std::string&gt;() &gt;&gt; [](const std::string &amp;s) { /* bound */ })\n  .when(type::is&lt;Point&gt;(bind(has&lt;&amp;Point::x, &amp;Point::y&gt;())) &gt;&gt;\n        [](int x, int y) { /* structural bind */ })\n  .otherwise([] {});\n</code></pre> <p>Design Note: <code>type::as&lt;T&gt;()</code> preserves the \"explicit bind\" rule by being a named shortcut for <code>bind()</code>, not an implicit binding mechanism.</p>"},{"location":"api/#iii-guard-system","title":"III. Guard System","text":"<p>Guards are declarative constraints attached to patterns. They refine a match after binding succeeds, and before the handler is invoked.</p> <p>A guard failure does not terminate matching; it simply makes the current case fail and the engine continues to the next <code>.when(...)</code>.</p> <p>Warning</p> <p><code>_</code> and <code>rng(...)</code> are only valid when exactly one value is bound now. For multi-value patterns, use <code>arg&lt;N&gt;</code> or a lambda predicate.</p>"},{"location":"api/#guard-attachment","title":"<code>[]</code> Guard Attachment","text":"<p>Syntax:</p> <pre><code>pattern[guard]\n</code></pre> <p>Evaluation Order:</p> <ol> <li><code>pattern.match(subject)</code></li> <li><code>pattern.bind(subject)</code> \u2192 produces bound values (the handler inputs)</li> <li>evaluate <code>guard</code> (against the bound values)</li> <li>if guard passes \u2192 invoke handler; otherwise try next case</li> </ol> <p>Example:</p> <pre><code>match(x)\n  .when(\n    bind()[_ &gt; 0] &gt;&gt;\n    [](int v) {\n      // 1) bind() matches\n      // 2) bind() binds v\n      // 3) guard (_ &gt; 0) is evaluated\n      // 4) handler runs only if guard passes\n    }\n  )\n  .otherwise([] {});\n</code></pre> <p>Guard composition is supported:</p> <ul> <li><code>&amp;&amp;</code> (logical AND)</li> <li><code>||</code> (logical OR)</li> </ul>"},{"location":"api/#single-value-guards-_-and-rng","title":"Single-value Guards: <code>_</code> and <code>rng(...)</code>","text":"<p>Single-value guards are built with the global placeholder:</p> <pre><code>inline constexpr placeholder_t _;\n</code></pre> <p><code>_</code> is not a runtime value. Expressions like <code>_ &gt; 0</code> construct a predicate object.</p>"},{"location":"api/#supported-operators-for-_","title":"Supported operators for <code>_</code>","text":"<pre><code>_ &gt;  rhs\n_ &lt;  rhs\n_ &gt;= rhs\n_ &lt;= rhs\n_ == rhs\n_ != rhs\n</code></pre>"},{"location":"api/#range-helper-rnglo-hi-mode","title":"Range helper: <code>rng(lo, hi, mode)</code>","text":"<p>Use <code>rng(...)</code> for interval constraints (it returns a predicate usable inside <code>[]</code>).</p> <pre><code>rng(lo, hi)                 // [lo, hi]\nrng(lo, hi, open)           // (lo, hi)\nrng(lo, hi, open_closed)    // (lo, hi]\nrng(lo, hi, closed_open)    // [lo, hi)\n</code></pre> <p>Examples:</p> <pre><code>bind()[_ &gt; 0 &amp;&amp; _ &lt; 10]\nbind()[rng(0, 10, closed_open)]   // [0, 10)\n</code></pre> <p>Anything beyond these relational/range constraints should be expressed as a custom predicate (lambda), not as additional operator DSL.</p>"},{"location":"api/#multi-value-guards-argn-expressions","title":"Multi-value Guards: <code>arg&lt;N&gt;</code> Expressions","text":"<p>For guards that relate multiple bound values, use <code>arg&lt;N&gt;</code> to reference the N-th bound value (0-based):</p> <pre><code>template &lt;std::size_t I&gt;\ninline constexpr arg_t&lt;I&gt; arg{};\n</code></pre> <p>Key rule: <code>arg&lt;N&gt;</code> indices correspond exactly to the pattern\u2019s binding order (and therefore the handler\u2019s parameter order).</p>"},{"location":"api/#supported-operators-for-multi-value-expressions","title":"Supported operators for multi-value expressions","text":"<p>Multi-value guard expressions support:</p> <ul> <li>comparisons: <code>== != &lt; &gt; &lt;= &gt;=</code></li> <li>arithmetic: <code>+ - * / %</code></li> <li>plus logical composition via <code>&amp;&amp;</code> and <code>||</code></li> </ul> <p>There is no <code>rng(...)</code> for <code>arg&lt;N&gt;</code> expressions in the current design.</p> <p>Examples:</p> <pre><code>// x + y == 0\nmatch(p)\n  .when(\n    bind(has&lt;&amp;Point::x, &amp;Point::y&gt;())[arg&lt;0&gt; + arg&lt;1&gt; == 0] &gt;&gt;\n    [](int x, int y) { /* ... */ }\n  )\n  .otherwise([] {});\n</code></pre> <pre><code>// Protocol-like constraint over multiple fields\nmatch(pkt)\n  .when(\n    bind(has&lt;&amp;Packet::type, &amp;Packet::length&gt;())\n      [arg&lt;0&gt; == 0x01 &amp;&amp; arg&lt;1&gt; == 0] &gt;&gt;\n    [](auto type, auto len) { /* ... */ }\n  )\n  .otherwise([] {});\n</code></pre>"},{"location":"api/#compile-time-boundary-checking","title":"Compile-time boundary checking","text":"<p>Using an out-of-range <code>arg&lt;N&gt;</code> is ill-formed and diagnosed at compile time (the library checks the maximum referenced index against the number of bound values):</p> <pre><code>bind(has&lt;&amp;Point::x&gt;())[arg&lt;1&gt; &gt; 0]\n// \u274c ill-formed: arg&lt;1&gt; out of range (only one bound value)\n</code></pre>"},{"location":"api/#custom-predicates-recommended-for-domain-logic","title":"Custom Predicates (Recommended for \u201cDomain Logic\u201d)","text":"<p>A critical constraint of Patternia\u2019s guard DSL is that <code>arg&lt;N&gt;</code> is an expression-template placeholder, not \u201cthe real field type\u201d in a way that enables arbitrary member access in the DSL.</p> <p>So this is not supported as a guard DSL expression:</p> <pre><code>bind(has&lt;&amp;Message::payload&gt;())[arg&lt;0&gt;.size() &gt; 0] // \u274c do not do this\n</code></pre> <p>When you need container queries, method calls, non-trivial computations, or any domain-specific logic, write a lambda predicate and pass it to <code>[]</code>.</p> <p>Examples:</p> <pre><code>auto non_empty = [](auto const&amp; payload) {\n  return !payload.empty();\n};\n\nmatch(msg)\n  .when(\n    bind(has&lt;&amp;Message::payload&gt;())[non_empty] &gt;&gt;\n    [](auto const&amp; payload) {\n      // payload is guaranteed non-empty here\n    }\n  )\n  .otherwise([] {});\n</code></pre> <pre><code>auto sum_is_even = [](int a, int b) {\n  return ((a + b) % 2) == 0;\n};\n\nmatch(p)\n  .when(\n    bind(has&lt;&amp;Point::x, &amp;Point::y&gt;())[sum_is_even] &gt;&gt;\n    [](int x, int y) { /* ... */ }\n  )\n  .otherwise([] {});\n</code></pre>"},{"location":"api/#iv-structural-matching","title":"IV. Structural Matching","text":"<p>Structural matching allows Patternia to reason about the shape of objects at compile time, independently of control flow and value-level logic.</p> <p>Rather than destructuring by position, Patternia describes structure through explicit member selection.</p>"},{"location":"api/#hastmember","title":"<code>has&lt;&amp;T::member...&gt;</code>","text":"<p>Role: Structural constraint and decomposition primitive.</p> <p>Syntax: <pre><code>template &lt;auto... Ms&gt;\nconstexpr auto has();\n</code></pre></p> <p>Each template argument must be a pointer to a non-static data member.</p>"},{"location":"api/#semantics","title":"Semantics","text":"<p><code>has&lt;Ms...&gt;</code> declares a compile-time structural requirement:</p> <ul> <li>The matched type must contain all listed data members</li> <li>The order of members is not positional</li> <li>No values are accessed unless used within <code>bind()</code></li> </ul> <p>This makes <code>has&lt;&gt;</code> a structural predicate, not a value pattern.</p>"},{"location":"api/#core-characteristics","title":"Core Characteristics","text":"<ul> <li>Declarative structural constraints without control flow</li> <li>No implicit value access or extraction</li> <li>Independent of member layout or declaration order</li> <li>Compile-time validation of member pointers</li> </ul>"},{"location":"api/#basic-examples","title":"Basic Examples","text":"<pre><code>struct Point {\n  int x;\n  int y;\n};\n\nstruct Packet {\n  std::uint8_t type;\n  std::uint16_t length;\n  std::vector&lt;std::uint8_t&gt; data;\n};\n\n// Structural checks\nhas&lt;&amp;Point::x, &amp;Point::y&gt;\nhas&lt;&amp;Packet::type, &amp;Packet::length&gt;\n</code></pre> <p>These patterns assert that the matched value exposes the listed members. They do not bind or extract any values by themselves.</p>"},{"location":"api/#integration-with-bind","title":"Integration with <code>bind()</code>","text":"<p>When combined with <code>bind()</code>, <code>has&lt;&gt;</code> enables explicit structural extraction.</p> <pre><code>match(p)\n  .when(\n    bind(has&lt;&amp;Point::x, &amp;Point::y&gt;()) &gt;&gt;\n    [](int x, int y) {\n      return fmt(\"({}, {})\", x, y);\n    }\n  )\n  .otherwise([] {});\n</code></pre> <ul> <li><code>has&lt;&gt;</code> performs the structural check</li> <li><code>bind()</code> extracts the selected member values</li> <li>The handler receives the extracted values in the order listed</li> </ul>"},{"location":"api/#partial-structural-matching","title":"Partial Structural Matching","text":"<p>Structural matching is selective by design.</p> <p>To bind only a subset of members, list only those members:</p> <pre><code>match(p)\n  .when(\n    bind(has&lt;&amp;Point::x&gt;()) &gt;&gt;\n    [](int x) {\n      return fmt(\"x = {}\", x);\n    }\n  )\n  .otherwise([] {});\n</code></pre> <p>No placeholder or positional skipping is required. Unlisted members are simply ignored.</p>"},{"location":"api/#design-rationale","title":"Design Rationale","text":"<p>Patternia intentionally avoids positional or placeholder-based structural patterns.</p> <ul> <li>There is no notion of \u201cignored slots\u201d</li> <li>There is no dependency on member order</li> <li>There is no implicit reflection</li> </ul> <p>Instead:</p> <ul> <li>Structure is described by explicit member pointers</li> <li>Decomposition is driven by what you list, not what you omit</li> <li>This aligns with C++\u2019s existing type system and avoids reflection-like assumptions</li> </ul>"},{"location":"api/#standalone-vs-bound-usage","title":"Standalone vs Bound Usage","text":"<pre><code>has&lt;&amp;T::a, &amp;T::b&gt;        // Structural constraint only\nbind(has&lt;&amp;T::a, &amp;T::b&gt;) // Structural constraint + value extraction\n</code></pre> <p>This separation ensures that:</p> <ul> <li>Structural reasoning remains declarative</li> <li>Data flow remains explicit</li> <li>Control flow remains predictable</li> </ul>"},{"location":"api/#compile-time-guarantees","title":"Compile-time Guarantees","text":"<ul> <li>All member pointers are validated at compile time</li> <li>Invalid or non-existent members are diagnosed immediately</li> <li>No runtime reflection or metadata is required</li> </ul>"},{"location":"api/#conceptual-analogy","title":"Conceptual Analogy","text":"<p><code>has&lt;&gt;</code> is conceptually similar to Rust\u2019s structural patterns:</p> <pre><code>Point { x, y }\n</code></pre> <p>\u2014but adapted to C++\u2019s lack of native reflection by using explicit member pointers.</p> <p>It expresses what structure is required, not how to traverse it.</p>"},{"location":"api/#v-namespace-structure","title":"V. Namespace Structure","text":"<p>Patternia employs a layered namespace architecture:</p> <pre><code>ptn/                                    // Root namespace\n\u251c\u2500\u2500 core/                              // Core matching engine\n\u2502   \u251c\u2500\u2500 engine/                        // Matching engine implementation\n\u2502   \u251c\u2500\u2500 dsl/                          // DSL operators\n\u2502   \u2514\u2500\u2500 common/                       // Common utilities and traits\n\u251c\u2500\u2500 pat/                              // Pattern definitions\n\u2502   \u251c\u2500\u2500 base/                         // Pattern base classes\n\u2502   \u251c\u2500\u2500 lit.hpp                        // Literal pattern implementation\n\u2502   \u251c\u2500\u2500 bind.hpp                       // Binding pattern implementation\n\u2502   \u251c\u2500\u2500 wildcard.hpp                   // Wildcard pattern\n\u2502   \u251c\u2500\u2500 structural.hpp                 // Structural pattern\n\u2502   \u2514\u2500\u2500 modifiers/                     // Pattern modifiers\n\u2502       \u2514\u2500\u2500 guard.hpp                  // Guard system\n\u2514\u2500\u2500 meta/                             // Metaprogramming tools\n    \u251c\u2500\u2500 base/                         // Base traits\n    \u251c\u2500\u2500 dsa/                          // Data structures and algorithms\n    \u2514\u2500\u2500 query/                        // Query utilities\n</code></pre>"},{"location":"api/#primary-namespace-aliases","title":"Primary Namespace Aliases","text":"<p>For user convenience, Patternia provides all pattern functions directly in the <code>ptn</code> namespace:</p> <pre><code>namespace ptn {\n  // Core matching\n  using ptn::core::engine::match;\n\n  // Pattern primitives\n  using ptn::pat::lit;\n  using ptn::pat::lit_ci;\n  using ptn::pat::bind;\n  using ptn::pat::__;\n\n  // Guard system\n  using ptn::pat::mod::_;\n  using ptn::pat::mod::arg;\n  using ptn::pat::mod::rng;\n\n  // Structural patterns\n  using ptn::pat::has;\n\n  // Type patterns\n  namespace type = ptn::pat::type;\n  using ptn::pat::type::is;\n  using ptn::pat::type::as;\n}\n</code></pre> <p>This API reference focuses on Patternia's core design philosophy and essential APIs, providing readers with an understanding of Patternia's language composition rather than merely a function list. This organization facilitates better comprehension of Patternia's mental model and usage patterns.</p>"},{"location":"design-overview/","title":"Patternia Matching Semantics Overview","text":"<p>(<code>__</code>, <code>.end()</code>, <code>.otherwise()</code> and Destructuring Patterns)</p>"},{"location":"design-overview/#0-core-objectives","title":"0. Core Objectives","text":"<p>Patternia's DSL is designed to satisfy three key principles:</p> <ol> <li>Semantic Clarity:</li> <li>Clear separation between \"pattern-level\" and \"match-level\" responsibilities.</li> <li>Predictable Behavior:</li> <li>Consistent with Rust and the C++ standard proposal P1371R1 <code>inspect</code> mechanism in spirit.</li> <li>User-Friendly:</li> <li>Minimal API coverage for both \"statement-style matching\" and \"expression-style matching\" requirements.</li> </ol> <p>Around these three principles, the entire system can be abstracted into three levels:</p> <ol> <li>Pattern Level: <code>lit(...)</code>, <code>type::is&lt;T&gt;</code>, destructuring, <code>bind(...)</code>, <code>__</code>, etc.</li> <li>Case Level: <code>.when(pattern &gt;&gt; handler)</code>.</li> <li>Match Finalizer Level: <code>.end()</code> / <code>.otherwise(...)</code>.</li> </ol> <p>All discussions below revolve around these three levels.</p>"},{"location":"design-overview/#1-formal-definitions-of-core-concepts","title":"1. Formal Definitions of Core Concepts","text":""},{"location":"design-overview/#11-__-wildcard-pattern","title":"1.1 <code>__</code> (Wildcard Pattern)","text":"<ul> <li><code>__</code> is a pattern used to match \"any value\".</li> <li>It exists only at the Pattern Level and does not control the entire match lifecycle.</li> <li> <p>It plays different roles in different contexts:</p> </li> <li> <p>In literal matching: Serves as a \"fallback case\".</p> </li> <li>In enum/variant-like matching: Serves as a \"fallback for remaining constructors\".</li> <li>In struct destructuring:     Used for \"field-level ignoring\", similar to Rust's <code>_</code> / <code>..</code>.</li> </ul>"},{"location":"design-overview/#12-end-match-finalizer-for-__","title":"1.2 <code>.end()</code> (Match Finalizer for <code>__</code>)","text":"<ul> <li> <p><code>.end()</code> finalizes a match that uses the <code>__</code> pattern fallback:</p> </li> <li> <p>The entire <code>match(...)</code> expression may return a value or be <code>void</code>.</p> </li> <li>Used for exhaustive-style matches where <code>__</code> is a regular case.</li> <li>Corresponds to the statement form in the standard proposal's <code>inspect</code>   when handlers are <code>void</code>-returning.</li> <li> <p>Constraints:</p> </li> <li> <p>All case handlers must return compatible types (or all <code>void</code>).</p> </li> <li> <p>For exhaustible types (enum, bool, variant-like), future exhaustiveness checking will be performed:</p> <ul> <li>Compile-time diagnostics when not all enum values or alternatives are covered.</li> </ul> </li> </ul>"},{"location":"design-overview/#13-otherwise-expression-style-match-finalizer","title":"1.3 <code>.otherwise(...)</code> (Expression-style Match Finalizer)","text":"<ul> <li> <p><code>.otherwise(fallback)</code> transforms the builder into expression-style matching:</p> </li> <li> <p>The entire <code>match(...)</code> has a unified return value.</p> </li> <li>Similar to Rust's <code>let r = match x { ... };</code></li> <li> <p>Corresponds to the expression form in the standard proposal's <code>inspect</code>:</p> </li> <li> <p><code>pattern =&gt; expression,</code></p> </li> <li> <p>Constraints:</p> </li> <li> <p>All <code>.when(pattern &gt;&gt; handler)</code> handlers must return compatible types (or all <code>void</code>).</p> </li> <li> <p><code>.otherwise(...)</code> provides the final fallback value:</p> <ul> <li>Used when no branches match.</li> <li><code>.otherwise(...)</code> terminates the builder and determines the return type.</li> </ul> </li> </ul>"},{"location":"design-overview/#2-semantic-levels-pattern-vs-match-finalizer","title":"2. Semantic Levels: Pattern vs Match Finalizer","text":"<p>Always remember:</p> <p><code>__</code> is a Pattern-level object; <code>.end()</code> and <code>.otherwise()</code> are Match Finalizer-level objects.</p> <p>They solve completely different problems:</p> Role Level Problem Solved <code>__</code> Pattern Level How current case matches \"any/remaining forms\" <code>.end()</code> Match Level Finalizes a match that uses <code>__</code> as a case <code>.otherwise</code> Match Level Entire match \"as expression\" with final return value <p>Therefore:</p> <ul> <li><code>__</code> cannot replace <code>.otherwise()</code>:   It doesn't terminate the builder, nor determine return type.</li> <li><code>.otherwise()</code> cannot replace <code>__</code>:   It cannot express \"fallback for remaining constructors/fields in pattern tree\".</li> </ul>"},{"location":"design-overview/#3-end-vs-otherwise-two-modes","title":"3. <code>.end()</code> vs <code>.otherwise()</code>: Two Modes","text":""},{"location":"design-overview/#31-end-__-finalized-matching","title":"3.1 <code>.end()</code> \u2014 <code>__</code>-Finalized Matching","text":"<p>Use Cases:</p> <ul> <li>Want to use <code>__</code> as a regular case.</li> <li>Want exhaustiveness checking for enum/variant-like types.</li> </ul> <p>Semantic Characteristics:</p> <ul> <li>All handlers must return compatible types (or all <code>void</code>).</li> <li>Return type is deduced from the cases.</li> <li>Exhaustible types will be checked for \"complete coverage\".</li> </ul> <p>Example (enum):</p> <pre><code>enum class Status { Pending, Running, Failed };\n\nmatch(status)\n    .when(lit(Status::Pending) &gt;&gt; [] { log(\"Pending\"); })\n    .when(lit(Status::Running) &gt;&gt; [] { log(\"Running\"); })\n    .when(__ &gt;&gt; [] { log(\"Other\"); })  // pattern-level fallback\n    .end();                            // match finalizer for `__`\n</code></pre> <p>Rust Analogy:</p> <pre><code>match status {\n    Status::Pending =&gt; log(\"Pending\"),\n    Status::Running =&gt; log(\"Running\"),\n    _               =&gt; log(\"Other\"),\n};\n</code></pre>"},{"location":"design-overview/#32-otherwise-expression-style-matching","title":"3.2 <code>.otherwise(...)</code> \u2014 Expression-style Matching","text":"<p>Use Cases:</p> <ul> <li>Need to compute a value from match:</li> <li>Generate labels for enum/variant;</li> <li>Calculate results, map strings, etc.</li> </ul> <p>Semantic Characteristics:</p> <ul> <li>All handlers return the same type (or commonly convertible).</li> <li><code>.otherwise(fallback)</code> provides the final value.</li> <li>The entire <code>match(...)</code> expression has a concrete type.</li> </ul> <p>Example (Rust counterpart):</p> <pre><code>int x = 2;\n\nauto res = match(x)\n    .when(lit(1) &gt;&gt; \"one\")\n    .when(lit(2) &gt;&gt; \"two\")\n    .otherwise(\"Other\");\n\nstd::cout &lt;&lt; res;\n</code></pre> <p>Corresponding Rust:</p> <pre><code>let x = 2;\nlet res = match x {\n    1 =&gt; \"one\",\n    2 =&gt; \"two\",\n    _ =&gt; \"Other\",\n};\nprintln!(\"{}\", res);\n</code></pre>"},{"location":"design-overview/#4-__-roles-in-different-scenarios","title":"4. <code>__</code> Roles in Different Scenarios","text":""},{"location":"design-overview/#41-as-case-fallback-wildcard","title":"4.1 As \"Case Fallback\" Wildcard","text":"<p>Simplest literal scenario:</p> <pre><code>match(x)\n    .when(lit(1) &gt;&gt; [] { /* one */ })\n    .when(lit(2) &gt;&gt; [] { /* two */ })\n    .when(__ &gt;&gt; [] { /* other */ })    // __ is pattern-level fallback here\n    .end();\n</code></pre> <ul> <li><code>__ &gt;&gt; ...</code>: Represents \"all other values\".</li> </ul>"},{"location":"design-overview/#42-remaining-branch-in-enumvariant-like-matching","title":"4.2 Remaining Branch in Enum/Variant-like Matching","text":"<p>For variant-like types (including future kind/alternative patterns):</p> <pre><code>match(v)\n    .when(type::is&lt;int&gt;()         &gt;&gt; [] { /* int */ })\n    .when(type::is&lt;std::string&gt;() &gt;&gt; [] { /* string */ })\n    .when(__                       &gt;&gt; [] { /* other-kind */ })\n    .end();\n</code></pre> <p>Here:</p> <ul> <li><code>__</code> represents \"all alternatives except int and string\".</li> </ul>"},{"location":"design-overview/#43-field-wildcard-in-struct-destructuring","title":"4.3 Field Wildcard in Struct Destructuring","text":"<p>Corresponding Rust:</p> <pre><code>match p {\n    Point { x, .. } =&gt; println!(\"{}\", x),\n}\n</code></pre> <p>Patternia ideal DSL example:</p> <pre><code>struct Point { int x, y, z; };\n\nmatch(p)\n    .when(Point{ bind(x), __, __ } &gt;&gt; [&amp;] {\n        std::cout &lt;&lt; x;\n    })\n    .end();\n</code></pre> <p>Meaning:</p> <ul> <li>Matches object of type <code>Point</code>.</li> <li>Only binds first field <code>x</code>.</li> <li>Other fields (<code>y</code>, <code>z</code>) are ignored with <code>__</code>.</li> </ul> <p><code>__</code> here is field-level wildcard, not a fallback case. Future named field versions could also be extended:</p> <pre><code>.when(Point{ .x = bind(x), .y = __, .z = __ } &gt;&gt; ...)\n</code></pre>"},{"location":"design-overview/#5-__-and-otherwise-are-mutually-exclusive","title":"5. <code>__</code> and <code>.otherwise()</code> Are Mutually Exclusive","text":"<p><code>__</code> is a pattern-level fallback, while <code>.otherwise()</code> is a match-level fallback. Patternia rejects <code>.otherwise()</code> if a wildcard case is present. Use either:</p> <ul> <li><code>__</code> with <code>.end()</code> for pattern-level fallback, or</li> <li><code>.otherwise(...)</code> without <code>__</code> for match-level fallback.</li> </ul>"},{"location":"design-overview/#6-when-to-use-end-when-to-use-otherwise","title":"6. When to Use <code>.end()</code>, When to Use <code>.otherwise()</code>?","text":"<p>Use this decision table to directly guide user usage.</p>"},{"location":"design-overview/#61-decision-table","title":"6.1 Decision Table","text":"Requirement Recommended Usage Use <code>__</code> as a case fallback Use <code>.end()</code> Need a value without <code>__</code> Use <code>.otherwise(...)</code> Want exhaustiveness checking for enum/variant Use <code>.end()</code> Express \"all remaining matching forms\" Use <code>__</code> in pattern Express \"entire match fallback return value\" Use <code>.otherwise(...)</code>"},{"location":"design-overview/#62-typical-patterns","title":"6.2 Typical Patterns","text":"<ol> <li><code>__</code>-finalized with fallback:</li> </ol> <pre><code>match(s)\n    .when(lit(Status::Pending) &gt;&gt; [] { ... })\n    .when(lit(Status::Running) &gt;&gt; [] { ... })\n    .when(__ &gt;&gt; [] { ... }) // fallback\n    .end();\n</code></pre> <ol> <li>Expression-style, Rust counterpart:</li> </ol> <pre><code>auto res = match(x)\n    .when(lit(1) &gt;&gt; \"one\")\n    .when(lit(2) &gt;&gt; \"two\")\n    .otherwise(\"Other\");\n</code></pre> <ol> <li>Struct destructuring + field wildcard:</li> </ol> <pre><code>match(p)\n    .when(Point{ bind(x), __, __ } &gt;&gt; [&amp;] { return x; })\n    .otherwise(0);\n</code></pre> <ol> <li>Variant-like + type matching + pattern fallback:</li> </ol> <pre><code>auto info = match(v)\n    .when(type::is&lt;int&gt;         &gt;&gt; \"int\")\n    .when(type::is&lt;std::string&gt; &gt;&gt; \"string\")\n    .when(__                     &gt;&gt; \"other-kind\")\n    .otherwise(\"panic\");\n</code></pre>"},{"location":"design-overview/#7-implementation-details","title":"7. Implementation Details","text":""},{"location":"design-overview/#71-builder-execution-flow","title":"7.1 Builder Execution Flow","text":"<p>The builder pattern ensures that matches are only executed when properly terminated:</p> <pre><code>// Without .end() or .otherwise():\nmatch(value).when(lit(42) &gt;&gt; [] { /* handler */ });\n// Result: Nothing is executed - builder remains unterminated\n\n// With .end():\nmatch(value).when(lit(42) &gt;&gt; [] { /* handler */ }).end();\n// Result: match_impl::eval(subject_, cases_, std::move(dummy_fallback));\n\n// With .otherwise():\nmatch(value).when(lit(42) &gt;&gt; [] { /* handler */ }).otherwise(fallback);\n// Result: match_impl::eval(subject_, cases_, std::move(final_handler));\n</code></pre> <p>Key Points:</p> <ul> <li>Without <code>.end()</code> or <code>.otherwise()</code>, the builder never triggers execution.</li> <li><code>.end()</code> creates an empty fallback handler for <code>__</code>-finalized execution.</li> <li><code>.otherwise()</code> uses the provided handler as the final fallback for expression-style execution.</li> </ul>"},{"location":"design-overview/#72-type-safety-guarantees","title":"7.2 Type Safety Guarantees","text":"<ul> <li><code>.end()</code>: All handlers must return compatible types (or all <code>void</code>)</li> <li>Expression-style (<code>.otherwise()</code>): All handlers must return compatible types</li> <li>Pattern matching: Type-safe heterogeneous comparisons</li> <li>Binding: Compile-time type deduction for bound values</li> </ul>"},{"location":"design-overview/#8-future-roadmap","title":"8. Future Roadmap","text":"<p>To make these semantics truly user-friendly, Patternia's future plans include:</p> <ol> <li>Exhaustiveness Checking for <code>.end()</code>:</li> <li>Enum/bool: Static checking for complete enum value coverage.</li> <li>Variant-like: Check for complete alternative coverage.</li> <li> <p>Provide \"missing case\" and \"useless case\" hints.</p> </li> <li> <p>Formal Struct Destructuring DSL:</p> </li> <li>Positional: <code>Point{ bind(x), __, __ }</code></li> <li>Named: <code>Point{ .x = bind(x), .y = __, .z = __ }</code></li> <li> <p>Support guard/bind/nested patterns.</p> </li> <li> <p>Improved Error Messages:</p> </li> <li>Incompatible handler return types under <code>.end()</code> \u2192 Clear error.</li> <li>Handler return type inconsistency under <code>.otherwise()</code> \u2192 Clear type diagnostics.</li> <li>Wildcard + <code>.otherwise()</code> redundancy \u2192 Hint \"potentially redundant patterns\".</li> </ol> <p>This comprehensive design ensures that Patternia provides clear, predictable, and user-friendly pattern matching semantics while maintaining type safety and performance guarantees.</p>"},{"location":"changelog/releases/","title":"Patternia Releases","text":""},{"location":"changelog/releases/#05x","title":"0.5.x","text":"<ul> <li>v0.5.2 - December 10, 2025</li> <li>v0.5.3 - December 14, 2025</li> </ul>"},{"location":"changelog/releases/#06x","title":"0.6.x","text":"<ul> <li>v0.6.0 - December 16, 2025</li> <li>v0.6.1 - December 20, 2025</li> <li>v0.6.2 - December 23, 2025</li> <li>v0.6.3 - January 2, 2026</li> </ul>"},{"location":"changelog/v0.5.2/","title":"Patternia v0.5.2 Release Note","text":"<p>Release Date: December 10, 2025  Version: 0.5.2</p>"},{"location":"changelog/v0.5.2/#overview","title":"Overview","text":"<p>Patternia v0.5.2 introduces the wildcard pattern <code>__</code> and provides comprehensive documentation updates. This release focuses on semantic clarity, improved developer experience, and establishing a solid foundation for future exhaustiveness checking features.</p>"},{"location":"changelog/v0.5.2/#new-features","title":"New Features","text":""},{"location":"changelog/v0.5.2/#wildcard-pattern-__","title":"Wildcard Pattern (<code>__</code>)","text":"<p>Added: <code>ptn::__</code> - A pattern that matches any value without binding.</p> <pre><code>// Basic wildcard usage\nmatch(value)\n    .when(lit(0) &gt;&gt; \"zero\")\n    .when(__ &gt;&gt; \"other\")  // Matches any other value\n    .end();\n</code></pre> <p>Key Characteristics: - Always matches regardless of input value - Binds no data (returns empty tuple <code>std::tuple&lt;&gt;</code>) - More explicit than <code>bind()</code> when no capture is needed - Essential for catch-all cases and future struct destructuring</p>"},{"location":"changelog/v0.5.2/#enhanced-terminal-method-semantics","title":"Enhanced Terminal Method Semantics","text":"<p>Improved: Clear distinction between <code>.end()</code> and <code>.otherwise()</code> terminal methods.</p>"},{"location":"changelog/v0.5.2/#end-statement-style-matching","title":"<code>.end()</code> - Statement-style Matching","text":"<ul> <li>For void-returning matches (at v0.5.2; later versions allow non-void)</li> <li>Designed for exhaustiveness checking (future feature)</li> <li>Used when only side effects are needed</li> </ul>"},{"location":"changelog/v0.5.2/#otherwisehandler-expression-style-matching","title":"<code>.otherwise(handler)</code> - Expression-style Matching","text":"<ul> <li>For value-returning matches</li> <li>Provides explicit fallback behavior</li> <li>Used when computing results from matches</li> </ul>"},{"location":"changelog/v0.5.2/#fallback-trigger-mechanism-clarification","title":"Fallback Trigger Mechanism Clarification","text":"<p>Added: Detailed explanation of when <code>.otherwise()</code> is triggered:</p> <ol> <li>No Pattern Matches: When no <code>.when()</code> cases match the subject</li> <li>Defensive Fallback: Even with pattern coverage, provides runtime safety</li> </ol> <p>Key Principle: First matching pattern wins, regardless of fallback types.</p>"},{"location":"changelog/v0.5.2/#documentation-improvements","title":"Documentation Improvements","text":""},{"location":"changelog/v0.5.2/#design-overview-document","title":"Design Overview Document","text":"<p>Added: <code>docs/design-overview.md</code> - Comprehensive guide covering: - Three-level architecture (Pattern \u2192 Case \u2192 Match Finalizer) - Semantic differences between <code>__</code>, <code>.end()</code>, and <code>.otherwise()</code> - Usage scenarios and best practices - Implementation details and execution flow - Future roadmap for exhaustiveness checking</p>"},{"location":"changelog/v0.5.2/#enhanced-api-reference","title":"Enhanced API Reference","text":"<p>Updated: <code>docs/api.md</code> with: - Complete wildcard pattern documentation - Detailed comparison of terminal methods - Implementation notes about builder execution - Future features section with exhaustiveness checking roadmap</p>"},{"location":"changelog/v0.5.2/#improved-user-guide","title":"Improved User Guide","text":"<p>Updated: <code>README.md</code> featuring: - Wildcard pattern examples - Clear terminal method guidance - Future roadmap section - Better usage decision tables</p>"},{"location":"changelog/v0.5.2/#internal-improvements","title":"Internal Improvements","text":""},{"location":"changelog/v0.5.2/#comment-standardization","title":"Comment Standardization","text":"<p>Fixed: Consistent English comment style across all modified files: - <code>include/ptn/pattern/wildcard.hpp</code> - Added comprehensive file header - <code>include/ptn/core/engine/detail/builder_impl.hpp</code> - Completed member variable documentation - <code>include/ptn/core/common/common_traits.hpp</code> - Enhanced type trait comments - <code>samples/test.cpp</code> - Added explanatory comments and examples</p>"},{"location":"changelog/v0.5.2/#builder-implementation-enhancements","title":"Builder Implementation Enhancements","text":"<p>Improved: Better documentation in <code>match_builder</code> implementation: - Clear explanation of builder execution flow - Documented member variable purposes - Enhanced inline comments for complex template logic</p>"},{"location":"changelog/v0.5.2/#architecture-changes","title":"Architecture Changes","text":""},{"location":"changelog/v0.5.2/#three-level-design-formalization","title":"Three-Level Design Formalization","text":"<p>Patternia now explicitly follows a three-level architecture:</p> <ol> <li>Pattern Level: <code>lit()</code>, <code>bind()</code>, <code>__</code>, etc.</li> <li>Case Level: <code>.when(pattern &gt;&gt; handler)</code></li> <li>Match Finalizer Level: <code>.end()</code> / <code>.otherwise()</code></li> </ol> <p>This design ensures: - Clear separation of concerns - Predictable behavior matching Rust/standard proposals - Extensible foundation for future features</p>"},{"location":"changelog/v0.5.2/#semantic-clarity-improvements","title":"Semantic Clarity Improvements","text":"<p>Established: Clear distinctions between: - Pattern-level wildcards (<code>__</code>) vs match-level fallbacks (<code>.otherwise()</code>) - Statement-style (<code>.end()</code>) vs expression-style (<code>.otherwise()</code>) matching - Field-level ignoring vs case-level fallbacks</p>"},{"location":"changelog/v0.5.2/#usage-examples","title":"Usage Examples","text":""},{"location":"changelog/v0.5.2/#basic-pattern-matching","title":"Basic Pattern Matching","text":"<pre><code>#include &lt;ptn/patternia.hpp&gt;\n\n// Expression-style match\nauto result = match(value)\n    .when(lit(1) &gt;&gt; \"one\")\n    .when(lit(2) &gt;&gt; \"two\") \n    .when(__ &gt;&gt; \"other\")  // Wildcard fallback\n    .otherwise(\"default\");  // Match-level fallback\n</code></pre>"},{"location":"changelog/v0.5.2/#statement-style-matching","title":"Statement-style Matching","text":"<pre><code>// Statement-style match with exhaustiveness (future)\nmatch(status)\n    .when(lit(Status::Pending) &gt;&gt; [] { log(\"pending\"); })\n    .when(lit(Status::Running) &gt;&gt; [] { log(\"running\"); })\n    .when(__ &gt;&gt; [] { log(\"other\"); })  // Pattern fallback\n    .end();  // Statement termination\n</code></pre>"},{"location":"changelog/v0.5.2/#enum-with-wildcard","title":"Enum with Wildcard","text":"<pre><code>enum class Color { Red, Green, Blue };\nColor c = Color::Green;\n\nmatch(c)\n    .when(lit(Color::Red) &gt;&gt; [] { std::cout &lt;&lt; \"red\"; })\n    .when(lit(Color::Green) &gt;&gt; [] { std::cout &lt;&lt; \"green\"; })\n    .when(__ &gt;&gt; [] { std::cout &lt;&lt; \"other\"; })  // Catch-all\n    .end();\n</code></pre>"},{"location":"changelog/v0.5.2/#bug-fixes","title":"Bug Fixes","text":""},{"location":"changelog/v0.5.2/#api-clarity","title":"API Clarity","text":"<p>Fixed: Ambiguous terminal method behavior - Clear distinction between <code>.end()</code> and <code>.otherwise()</code>  - Better examples showing appropriate use cases</p>"},{"location":"changelog/v0.5.3/","title":"Patternia v0.5.3 Release Note","text":"<p>Release Date: December 14, 2025  Version: 0.5.3</p>"},{"location":"changelog/v0.5.3/#overview","title":"Overview","text":"<p>Patternia v0.5.3 introduces advanced pattern matching capabilities with guard predicates, enhanced binding mechanisms, structural decomposition patterns, and range matching utilities. This release significantly expands the expressiveness of pattern matching while maintaining zero-overhead performance and type safety.</p>"},{"location":"changelog/v0.5.3/#new-features","title":"New Features","text":""},{"location":"changelog/v0.5.3/#enhanced-binding-patterns-bind-and-bindsubpattern","title":"Enhanced Binding Patterns (<code>bind()</code> and <code>bind(subpattern)</code>)","text":"<p>Enhanced: <code>bind()</code> function with subpattern support for conditional binding.</p> <pre><code>// Basic binding - captures the subject itself\nmatch(value)\n    .when(bind() &gt;&gt; [](auto x) { /* use x */ })\n    .end();\n\n// Binding with subpattern - first matches subpattern, then captures subject\nmatch(number)\n    .when(bind(lit(42)) &gt;&gt; [](auto x) { /* x is 42, subject is also captured */ })\n    .when(bind([](auto n) { return n &gt; 0; }) &gt;&gt; [](auto subject, auto n) {\n        return fmt::format(\"positive: {} (subject: {})\", n, subject);\n    })\n    .otherwise(\"non-positive\");\n</code></pre> <p>Key Capabilities: - <code>bind()</code> - Captures the subject itself as a single-element tuple - <code>bind(subpattern)</code> - First matches with subpattern, then captures both subject and subpattern bindings - Type-safe binding with compile-time validation - Integration with all existing pattern types</p>"},{"location":"changelog/v0.5.3/#guard-predicates-and-placeholder-expressions","title":"Guard Predicates and Placeholder Expressions","text":"<p>Added: Comprehensive guard system with placeholder <code>_</code> and predicate combinators.</p> <pre><code>// Placeholder-based guard expressions\nmatch(number)\n    .when(bind()[_ &gt; 10 &amp;&amp; _ &lt; 100] &gt;&gt; \"two-digit\")\n    .when(bind()[_ &gt;= 100] &gt;&gt; \"three-or-more-digits\")\n    .otherwise(\"single-digit\");\n\n// Range predicates with different modes\nmatch(value)\n    .when(bind()[rng(0, 10)] &gt;&gt; \"small closed\")           // [0, 10]\n    .when(bind()[rng(10, 20, open)] &gt;&gt; \"medium open\")    // (10, 20)\n    .when(bind()[rng(20, 30, open_closed)] &gt;&gt; \"large open-closed\") // (20, 30]\n    .when(bind()[rng(30, 40, closed_open)] &gt;&gt; \"xlarge closed-open\") // [30, 40)\n    .otherwise(\"out of range\");\n\n// Lambda guards for complex conditions\nmatch(data)\n    .when(bind()[[](auto x) { return x.is_valid() &amp;&amp; x.size() &gt; 0; }] &gt;&gt; \"valid\")\n    .otherwise(\"invalid\");\n</code></pre> <p>Guard Features: - <code>_</code> placeholder for creating comparison expressions (<code>_ &gt; 10</code>, <code>_ == 42</code>, etc.) - <code>rng()</code> function for range predicates with four modes: <code>closed</code>, <code>open</code>, <code>open_closed</code>, <code>closed_open</code> - Predicate combinators: <code>&amp;&amp;</code> (logical AND) and <code>||</code> (logical OR) - Lambda guard support for complex custom conditions - Type-safe guard predicate evaluation</p>"},{"location":"changelog/v0.5.3/#structural-decomposition-patterns-has","title":"Structural Decomposition Patterns (<code>has&lt;&gt;</code>)","text":"<p>Added: <code>has&lt;&amp;T::field...&gt;()</code> for aggregate and struct decomposition.</p> <pre><code>struct Point { int x, y; };\nstruct Circle { Point center; int radius; };\n\n// Basic field presence checking\nmatch(point)\n    .when(has&lt;&amp;Point::x, &amp;Point::y&gt; &gt;&gt; \"valid point\")\n    .otherwise(\"invalid point\");\n\n// Combining with binding for field access\nmatch(circle)\n    .when(has&lt;&amp;Circle::center, &amp;Circle::radius&gt; &gt;&gt; bind() &gt;&gt; [](auto c) {\n        return fmt::format(\"circle at ({}, {}) with radius {}\", \n                           c.center.x, c.center.y, c.radius);\n    })\n    .otherwise(\"invalid circle\");\n\n// Multi-level structural matching\nmatch(complex_data)\n    .when(has&lt;&amp;Data::points&gt; &gt;&gt; bind()[[](auto pts) { return !pts.empty(); }]\n         &gt;&gt; [](auto data, auto pts) {\n        return fmt::format(\"data with {} points\", pts.size());\n    })\n    .otherwise(\"empty or invalid data\");\n</code></pre> <p>Structural Pattern Features: - Compile-time validation of member pointer parameters - Support for multiple field pointers in single pattern - Integration with binding patterns for field access - Zero-overhead struct decomposition - Type-safe member access checking</p>"},{"location":"changelog/v0.5.3/#advanced-pattern-composition","title":"Advanced Pattern Composition","text":"<p>Enhanced: Seamless integration between all pattern types.</p> <pre><code>// Complex pattern combining all features\nmatch(data)\n    .when(\n        has&lt;&amp;Data::value, &amp;Data::status&gt; &gt;&gt; \n        bind()[[](auto d) { return d.value &gt; 0; } &amp;&amp; [](auto d) { return d.status == Status::Active; }]\n     &gt;&gt; [](auto d, auto value, auto status) {\n        return fmt::format(\"active data: {} (status: {})\", value, status);\n    })\n    .when(\n        has&lt;&amp;Data::value&gt; &gt;&gt; \n        bind([](auto v) { return v &lt; 0; })[_ &gt; -100]\n     &gt;&gt; [](auto subject, auto v) {\n        return fmt::format(\"negative value: {} (subject: {})\", v, subject);\n    })\n    .otherwise(\"no match\");\n</code></pre>"},{"location":"changelog/v0.5.3/#internal-improvements","title":"Internal Improvements","text":""},{"location":"changelog/v0.5.3/#pattern-framework-extensions","title":"Pattern Framework Extensions","text":"<p>Enhanced: Advanced pattern matching infrastructure: - Guard predicate evaluation system - Enhanced binding pattern composition - Structural pattern validation - Type-safe predicate combinators</p>"},{"location":"changelog/v0.5.3/#type-system-improvements","title":"Type System Improvements","text":"<p>Added: Comprehensive type support for: - Member pointer validation in <code>has&lt;&gt;</code> - Guard predicate type detection - Binding contract forwarding - Template parameter deduction</p>"},{"location":"changelog/v0.5.3/#performance-optimizations","title":"Performance Optimizations","text":"<p>Maintained: Zero-overhead guarantees: - Compile-time guard predicate evaluation where possible - Inlined pattern matching - Optimal struct field access - Efficient tuple composition for binding</p>"},{"location":"changelog/v0.5.3/#architecture-changes","title":"Architecture Changes","text":""},{"location":"changelog/v0.5.3/#guard-system-architecture","title":"Guard System Architecture","text":"<p>Added: Comprehensive guard framework: - <code>guard_predicate_tag</code> for type detection - <code>placeholder_t</code> with comparison operator overloads - <code>binary_predicate</code> for standard comparisons - <code>range_predicate</code> with configurable modes - <code>guarded_pattern</code> wrapper for pattern composition</p>"},{"location":"changelog/v0.5.3/#enhanced-binding-system","title":"Enhanced Binding System","text":"<p>Expanded: Binding pattern capabilities: - <code>binding_pattern</code> for subject capture - <code>binding_as_pattern</code> for subpattern composition - Tuple concatenation for multi-value binding - Forwarding binding contracts to inner patterns</p>"},{"location":"changelog/v0.5.3/#structural-pattern-framework","title":"Structural Pattern Framework","text":"<p>Added: Member pointer-based decomposition: - Compile-time member pointer validation - <code>has_pattern</code> for field presence checking - Integration with existing pattern ecosystem - Zero-overhead field access</p>"},{"location":"changelog/v0.5.3/#usage-examples","title":"Usage Examples","text":""},{"location":"changelog/v0.5.3/#guard-with-placeholders","title":"Guard with Placeholders","text":"<pre><code>match(score)\n    .when(bind()[_ &gt;= 90] &gt;&gt; \"excellent\")\n    .when(bind()[_ &gt;= 80 &amp;&amp; _ &lt; 90] &gt;&gt; \"good\")\n    .when(bind()[_ &gt;= 70 &amp;&amp; _ &lt; 80] &gt;&gt; \"average\")\n    .otherwise(\"needs improvement\");\n</code></pre>"},{"location":"changelog/v0.5.3/#range-matching-with-different-modes","title":"Range Matching with Different Modes","text":"<pre><code>match(temperature)\n    .when(bind()[rng(18.0, 22.0)] &gt;&gt; \"comfortable\")           // [18, 22]\n    .when(bind()[rng(22.0, 30.0, open)] &gt;&gt; \"warm\")            // (22, 30)\n    .when(bind()[rng(30.0, 40.0, open_closed)] &gt;&gt; \"hot\")      // (30, 40]\n    .when(bind()[rng(-10.0, 18.0, closed_open)] &gt;&gt; \"cool\")   // [-10, 18)\n    .otherwise(\"extreme temperature\");\n</code></pre>"},{"location":"changelog/v0.5.3/#structural-pattern-with-guards","title":"Structural Pattern with Guards","text":"<pre><code>struct Employee {\n    std::string name;\n    int age;\n    double salary;\n    bool active;\n};\n\nmatch(employee)\n    .when(\n        has&lt;&amp;Employee::age, &amp;Employee::salary, &amp;Employee::active&gt; &gt;&gt;\n        bind()[[](auto e) { return e.active &amp;&amp; e.age &gt;= 25; }]\n     &gt;&gt; [](auto e, auto age, auto salary, auto active) {\n        return fmt::format(\"active employee: {} ({} years, ${:.2f})\", \n                          e.name, age, salary);\n    })\n    .when(\n        has&lt;&amp;Employee::age&gt; &gt;&gt;\n        bind([](auto age) { return age &lt; 25; })[_ &gt;= 18]\n     &gt;&gt; [](auto subject, auto age) {\n        return fmt::format(\"young employee: {} years old\", age);\n    })\n    .otherwise(\"no match\");\n</code></pre>"},{"location":"changelog/v0.5.3/#complex-pattern-composition","title":"Complex Pattern Composition","text":"<pre><code>match(container)\n    .when(\n        has&lt;&amp;Container::size&gt; &gt;&gt;\n        bind()[[](auto c) { return c.size() &gt; 0; } &amp;&amp; [](auto c) { return c.size() &lt;= 100; }]\n     &gt;&gt; [](auto c, auto size) {\n        return fmt::format(\"container with {} items\", size);\n    })\n    .when(\n        has&lt;&amp;Container::size&gt; &gt;&gt;\n        bind()[[](auto c) { return c.size() == 0; }]\n     &gt;&gt; [](auto c) {\n        return \"empty container\";\n    })\n    .otherwise(\"large or invalid container\");\n</code></pre>"},{"location":"changelog/v0.5.3/#bug-fixes","title":"Bug Fixes","text":""},{"location":"changelog/v0.5.3/#pattern-validation","title":"Pattern Validation","text":"<p>Fixed: Edge cases in pattern matching: - Guard predicate type deduction for complex expressions - Binding contract forwarding for nested patterns - Member pointer validation in <code>has&lt;&gt;</code> patterns - Range boundary evaluation edge cases</p>"},{"location":"changelog/v0.5.3/#compilation-issues","title":"Compilation Issues","text":"<p>Resolved: Template compilation problems: - Guard predicate instantiation failures - Binding pattern type deduction - Structural pattern member access validation - Predicate combinator type resolution</p>"},{"location":"changelog/v0.6.0/","title":"Patternia v0.6.0 Release Note","text":"<p>Release Date: December 16, 2025  Version: 0.6.0</p>"},{"location":"changelog/v0.6.0/#overview","title":"Overview","text":"<p>Patternia v0.6.0 represents a significant advancement in pattern matching capabilities, introducing generic lambda support, multi-value guard expressions, structural binding enhancements, and strongly-typed evaluation mechanisms. This release enhances the expressiveness and type safety of pattern matching while maintaining zero-overhead performance guarantees.</p>"},{"location":"changelog/v0.6.0/#new-features","title":"New Features","text":""},{"location":"changelog/v0.6.0/#generic-lambda-support-for-pattern-matching","title":"Generic Lambda Support for Pattern Matching","text":"<p>Added: Full support for generic lambdas in pattern matching handlers through template operator() detection.</p> <pre><code>// Generic lambda with auto parameters\nmatch(container)\n    .when(bind(has&lt;&amp;Container::elements&gt;()) &gt;&gt; [](auto&amp;&amp; elems) {\n        return process_generic_elements(elems);\n    })\n    .otherwise([] { return handle_empty(); });\n\n// Generic lambda with multiple parameters\nmatch(data)\n    .when(bind(has&lt;&amp;Data::value, &amp;Data::type&gt;()) &gt;&gt; [](auto val, auto&amp;&amp; type) {\n        return handle_generic_data(val, type);\n    })\n    .otherwise([] { return default_handler(); });\n</code></pre> <p>Technical Implementation: - Template operator() detection for 1-4 parameter arities - Forward reference support for perfect forwarding - Type deduction improvements for generic handlers - Seamless integration with existing pattern infrastructure</p>"},{"location":"changelog/v0.6.0/#multi-value-guard-expressions-with-arg-placeholders","title":"Multi-Value Guard Expressions with arg Placeholders <p>Enhanced: Advanced guard system supporting relationships between multiple bound values.</p> <pre><code>// Multi-value comparisons using arg&lt;N&gt; placeholders\nmatch(point)\n    .when(bind(has&lt;&amp;Point::x, &amp;Point::y&gt;())[arg&lt;0&gt; + arg&lt;1&gt; == 0] &gt;&gt; \n         [](int x, int y) { return \"on diagonal\"; })\n    .when(bind(has&lt;&amp;Point::x, &amp;Point::y&gt;())[arg&lt;0&gt; * arg&lt;1] &gt; 100] &gt;&gt;\n         [](int x, int y) { return \"large product\"; })\n    .otherwise([] { return \"other\"; });\n\n// Complex multi-value conditions\nmatch(rectangle)\n    .when(bind(has&lt;&amp;Rect::width, &amp;Rect::height&gt;())\n          [arg&lt;0&gt; &gt; arg&lt;1&gt; &amp;&amp; arg&lt;0&gt; + arg&lt;1&gt; &lt; 100] &gt;&gt;\n         [](int width, int height) { return \"wide, small perimeter\"; })\n    .when(bind(has&lt;&amp;Rect::width, &amp;Rect::height&gt;())\n          [arg&lt;0&gt; == arg&lt;1&gt;] &gt;&gt;\n         [](int width, int height) { return \"square\"; })\n    .otherwise([] { return \"other\"; });\n</code></pre> <p>Guard Expression Features: - <code>arg&lt;N&gt;</code> placeholders for accessing Nth bound value - Binary operations between different bound values - Complex logical combinations with <code>&amp;&amp;</code> and <code>||</code> - Type-safe compile-time validation of guard expressions - Support for arithmetic, comparison, and logical operations</p>","text":""},{"location":"changelog/v0.6.0/#structural-binding-for-has_pattern","title":"Structural Binding for has_pattern <p>Enhanced: Direct binding of member fields when using <code>bind()</code> with structural patterns.</p> <pre><code>struct Point { int x, y; };\nstruct Circle { Point center; int radius; };\n\n// Direct field binding from structural patterns\nmatch(point)\n    .when(bind(has&lt;&amp;Point::x, &amp;Point::y&gt;()) &gt;&gt; [](int x, int y) {\n        return fmt::format(\"point: ({}, {})\", x, y);\n    })\n    .otherwise([] { return \"invalid point\"; });\n\n// Nested structural binding\nmatch(circle)\n    .when(bind(has&lt;&amp;Circle::center, &amp;Circle::radius&gt;()) &gt;&gt; \n         [](const Point&amp; center, int radius) {\n        return fmt::format(\"circle: center({},{}), radius={}\", \n                           center.x, center.y, radius);\n    })\n    .otherwise([] { return \"invalid circle\"; });\n\n// Mixed structural and wildcard binding\nshape = std::variant&lt;Point, Circle&gt;{};\nmatch(shape)\n    .when(bind(has&lt;&amp;Point::x, &amp;Point::y&gt;()) &gt;&gt; [](int x, int y) {\n        return fmt::format(\"point: ({}, {})\", x, y);\n    })\n    .otherwise([] { return \"unknown shape\"; });\n</code></pre> <p>Structural Binding Capabilities: - Automatic tuple generation from member pointers - Type preservation for reference and const semantics - Integration with wildcard patterns for partial binding - Compile-time validation of member accessibility - Zero-overhead field extraction</p>","text":""},{"location":"changelog/v0.6.0/#strongly-typed-evaluation-system","title":"Strongly-Typed Evaluation System <p>Added: Comprehensive type safety and evaluation framework for pattern matching.</p> <pre><code>// Type-safe evaluation with compile-time guarantees\nmatch(value)\n    .when(bind() &gt;&gt; [](auto&amp;&amp; val) requires std::integral&lt;decltype(val)&gt; {\n        return process_integral(val);\n    })\n    .when(bind() &gt;&gt; [](auto&amp;&amp; val) requires std::floating_point&lt;decltype(val)&gt; {\n        return process_floating(val);\n    })\n    .otherwise([] { return handle_unknown_type(); });\n\n// Strongly-typed guard evaluation\nmatch(data)\n    .when(bind()[[](auto x) { return std::is_arithmetic_v&lt;decltype(x)&gt;; }] &gt;&gt;\n         [](auto&amp;&amp; x) { return process_arithmetic(x); })\n    .otherwise([] { return handle_non_arithmetic(); });\n</code></pre> <p>Type System Features: - Compile-time type validation for pattern contracts - Type-safe guard predicate evaluation - Template constraint integration with C++20 concepts - Enhanced type deduction for complex patterns - Improved error messages for type mismatches</p>","text":""},{"location":"changelog/v0.6.0/#internal-improvements","title":"Internal Improvements","text":""},{"location":"changelog/v0.6.0/#enhanced-type-traits-system","title":"Enhanced Type Traits System <p>Expanded: Comprehensive type detection and validation capabilities.</p> <pre><code>// Generic lambda detection improvements\ntemplate&lt;typename T&gt;\nconcept is_generic_lambda = requires(T t) {\n    requires requires { t.operator()(auto{}); } ||\n              requires { t.operator()(auto{}, auto{}); } ||\n              requires { t.operator()(auto{}, auto{}, auto{}); } ||\n              requires { t.operator()(auto{}, auto{}, auto{}, auto{}); };\n};\n\n// Multi-value guard expression type validation\ntemplate&lt;typename... Args&gt;\nconcept valid_guard_expression = requires(Args... args) {\n    requires (sizeof...(Args) &lt;= 4);\n    requires (std::conjunction_v&lt;std::is_invocable&lt;Args&gt;...&gt;);\n};\n</code></pre>","text":""},{"location":"changelog/v0.6.0/#builder-framework-enhancements","title":"Builder Framework Enhancements <p>Improved: Advanced pattern matching infrastructure with better type safety.</p> <ul> <li>Enhanced builder implementation for generic lambda support</li> <li>Improved type deduction for complex pattern compositions</li> <li>Better error handling and validation in pattern construction</li> <li>Optimized template instantiation for faster compilation</li> </ul>","text":""},{"location":"changelog/v0.6.0/#performance-optimizations","title":"Performance Optimizations <p>Maintained: Zero-overhead guarantees with enhanced optimization opportunities.</p> <ul> <li>Compile-time evaluation of guard expressions where possible</li> <li>Improved inlining for generic lambda handlers</li> <li>Optimized tuple generation for structural binding</li> <li>Enhanced template metaprogramming for type deduction</li> </ul>","text":""},{"location":"changelog/v0.6.0/#architecture-changes","title":"Architecture Changes","text":""},{"location":"changelog/v0.6.0/#multi-value-guard-architecture","title":"Multi-Value Guard Architecture <p>Added: Comprehensive framework for complex guard expressions.</p> <pre><code>// arg&lt;N&gt; placeholder system\ntemplate&lt;std::size_t N&gt;\nstruct arg_placeholder {\n    template&lt;typename... Args&gt;\n    constexpr auto operator()(Args&amp;&amp;... args) const -&gt; decltype(auto) {\n        return std::get&lt;N&gt;(std::forward_as_tuple(args...));\n    }\n};\n\n// Binary operation support for guard expressions\ntemplate&lt;typename LHS, typename Op, typename RHS&gt;\nstruct binary_guard_expression {\n    LHS lhs;\n    RHS rhs;\n\n    template&lt;typename... Args&gt;\n    constexpr auto operator()(Args&amp;&amp;... args) const -&gt; decltype(auto) {\n        return Op{}(lhs(args...), rhs(args...));\n    }\n};\n</code></pre>","text":""},{"location":"changelog/v0.6.0/#structural-binding-framework","title":"Structural Binding Framework <p>Enhanced: Advanced member pointer-based binding system.</p> <pre><code>// Structural bind pattern implementation\ntemplate&lt;typename... MemberPtrs&gt;\nstruct structural_bind_pattern {\n    template&lt;typename Subject&gt;\n    constexpr auto match(Subject&amp;&amp; subject) const {\n        return std::tuple&lt;member_type_t&lt;MemberPtrs&gt;...&gt;{\n            subject.*MemberPtrs...\n        };\n    }\n};\n</code></pre>","text":""},{"location":"changelog/v0.6.0/#generic-lambda-handler-system","title":"Generic Lambda Handler System <p>Added: Template operator() detection and invocation framework.</p> <pre><code>// Generic lambda detection and arity determination\ntemplate&lt;typename T, typename = void&gt;\nstruct is_generic_lambda : std::false_type {};\n\ntemplate&lt;typename T&gt;\nstruct is_generic_lambda&lt;T, std::void_t&lt;decltype(&amp;T::template operator()&lt;auto&gt;)&gt;&gt; \n    : std::true_type {};\n</code></pre>","text":""},{"location":"changelog/v0.6.0/#usage-examples","title":"Usage Examples","text":""},{"location":"changelog/v0.6.0/#generic-lambda-with-structural-binding","title":"Generic Lambda with Structural Binding <pre><code>struct Matrix { int rows, cols; std::vector&lt;double&gt; data; };\n\nmatch(matrix)\n    .when(bind(has&lt;&amp;Matrix::rows, &amp;Matrix::cols, &amp;Matrix::data&gt;()) &gt;&gt;\n         [](auto rows, auto&amp;&amp; cols, auto&amp;&amp; data) requires std::ranges::range&lt;decltype(data)&gt; {\n        return fmt::format(\"matrix: {}x{} with {} elements\", rows, cols, data.size());\n    })\n    .otherwise([] { return \"invalid matrix\"; });\n</code></pre>","text":""},{"location":"changelog/v0.6.0/#multi-value-guard-with-complex-logic","title":"Multi-Value Guard with Complex Logic <pre><code>struct Triangle { int a, b, c; };\n\nmatch(triangle)\n    .when(bind(has&lt;&amp;Triangle::a, &amp;Triangle::b, &amp;Triangle::c&gt;())\n          [arg&lt;0&gt; + arg&lt;1] &gt; arg&lt;2&gt; &amp;&amp; \n           arg&lt;1] + arg&lt;2] &gt; arg&lt;0&gt; &amp;&amp; \n           arg&lt;0] + arg&lt;2] &gt; arg&lt;1]] &gt;&gt;\n         [](int a, int b, int c) { return \"valid triangle\"; })\n    .when(bind(has&lt;&amp;Triangle::a, &amp;Triangle::b, &amp;Triangle::c&gt;())\n          [arg&lt;0] == arg&lt;1] &amp;&amp; arg&lt;1] == arg&lt;2]] &gt;&gt;\n         [](int a, int b, int c) { return \"equilateral triangle\"; })\n    .otherwise([] { return \"invalid triangle\"; });\n</code></pre>","text":""},{"location":"changelog/v0.6.0/#advanced-generic-lambda-processing","title":"Advanced Generic Lambda Processing <pre><code>template&lt;typename Container&gt;\nauto process_container(const Container&amp; container) {\n    return match(container)\n        .when(bind(has&lt;&amp;Container::size, &amp;Container::data&gt;()) &gt;&gt;\n             [](auto size, auto&amp;&amp; data) requires std::ranges::range&lt;decltype(data)&gt; {\n                return fmt::format(\"container with {} elements\", size);\n             })\n        .when(bind() &gt;&gt; [](auto&amp;&amp; c) requires requires { c.size(); } {\n                return fmt::format(\"sized container: {}\", c.size());\n             })\n        .when(bind() &gt;&gt; [](auto&amp;&amp; c) requires std::ranges::range&lt;decltype(c)&gt; {\n                return fmt::format(\"range container\");\n             })\n        .otherwise([] { return \"unknown container type\"; });\n}\n</code></pre>","text":""},{"location":"changelog/v0.6.0/#complex-pattern-composition","title":"Complex Pattern Composition <pre><code>struct NetworkPacket {\n    uint16_t source_port;\n    uint16_t dest_port;\n    uint32_t sequence;\n    std::vector&lt;uint8_t&gt; payload;\n};\n\nmatch(packet)\n    .when(bind(has&lt;&amp;NetworkPacket::source_port, &amp;NetworkPacket::dest_port,\n                &amp;NetworkPacket::sequence, &amp;NetworkPacket::payload&gt;())\n          [arg&lt;0] != arg&lt;1&gt; &amp;&amp; arg&lt;2] &gt; 0] &gt;&gt;\n         [](uint16_t src, uint16_t dst, uint32_t seq, auto&amp;&amp; payload) {\n            return fmt::format(\"packet: {}-&gt;{} (seq: {}, payload: {} bytes)\", \n                              src, dst, seq, payload.size());\n         })\n    .when(bind(has&lt;&amp;NetworkPacket::source_port, &amp;NetworkPacket::dest_port&gt;())\n          [arg&lt;0] == arg&lt;1]] &gt;&gt;\n         [](uint16_t port, uint16_t) {\n            return fmt::format(\"loopback packet on port {}\", port);\n         })\n    .otherwise([] { return \"malformed packet\"; });\n</code></pre>","text":""},{"location":"changelog/v0.6.0/#documentation-improvements","title":"Documentation Improvements","text":""},{"location":"changelog/v0.6.0/#enhanced-api-reference","title":"Enhanced API Reference <p>Updated: Comprehensive documentation covering new features: - Generic lambda handler documentation - Multi-value guard expression reference - Structural binding usage patterns - Type system improvements documentation</p>","text":""},{"location":"changelog/v0.6.0/#expanded-sample-code","title":"Expanded Sample Code <p>Added: New and improved sample implementations: - <code>samples/fibo.cpp</code> - Generic lambda with guard expressions - <code>samples/handle_packet.cpp</code> - Complex protocol parsing with structural binding - Improved code comments and inline documentation</p>","text":""},{"location":"changelog/v0.6.0/#readme-enhancements","title":"README Enhancements <p>Expanded: Comprehensive quick start and reference documentation: - Patternia benefits explanation - Advanced usage patterns - Performance characteristics - Type safety guarantees</p>","text":""},{"location":"changelog/v0.6.0/#bug-fixes","title":"Bug Fixes","text":""},{"location":"changelog/v0.6.0/#template-compilation-issues","title":"Template Compilation Issues <p>Resolved: Advanced template compilation problems: - Generic lambda operator() detection edge cases - Multi-value guard expression instantiation failures - Structural binding type deduction problems - Template argument deduction for complex patterns</p>","text":""},{"location":"changelog/v0.6.0/#type-system-validation","title":"Type System Validation <p>Fixed: Type safety and validation issues: - Guard predicate type resolution for generic expressions - Binding contract forwarding for nested patterns - Member pointer accessibility validation in structural patterns - Type preservation in generic lambda handlers</p>","text":""},{"location":"changelog/v0.6.0/#performance-edge-cases","title":"Performance Edge Cases <p>Resolved: Optimization and performance issues: - Template instantiation overhead for complex patterns - Unnecessary tuple copying in structural binding - Guard expression evaluation optimization - Generic lambda inlining improvements</p>","text":""},{"location":"changelog/v0.6.0/#migration-guide","title":"Migration Guide","text":""},{"location":"changelog/v0.6.0/#from-v05x-to-v060","title":"From v0.5.x to v0.6.0 <p>Generic Lambda Support: <pre><code>// v0.5.x - Required explicit types\n.when(bind() &gt;&gt; [](int x) { return process(x); })\n\n// v0.6.0 - Supports generic lambdas\n.when(bind() &gt;&gt; [](auto&amp;&amp; x) { return process(x); })\n</code></pre></p> <p>Multi-Value Guards: <pre><code>// v0.5.x - Limited to single-value guards\n.when(bind()[_ &gt; 0] &gt;&gt; handler)\n\n// v0.6.0 - Multi-value relationship support\n.when(bind(has&lt;&amp;Point::x, &amp;Point::y&gt;())[arg&lt;0] + arg&lt;1] == 0] &gt;&gt; handler)\n</code></pre></p> <p>Structural Binding: <pre><code>// v0.5.x - Manual field access\n.when(has&lt;&amp;Point::x, &amp;Point::y&gt;() &gt;&gt; bind() &gt;&gt; [](auto&amp;&amp; p) {\n    return process(p.x, p.y);\n})\n\n// v0.6.0 - Direct field binding\n.when(bind(has&lt;&amp;Point::x, &amp;Point::y&gt;()) &gt;&gt; [](int x, int y) {\n    return process(x, y);\n})\n</code></pre></p>","text":""},{"location":"changelog/v0.6.0/#performance-impact","title":"Performance Impact","text":"<p>Compilation Time: Slight increase due to enhanced template metaprogramming Runtime Performance: No performance degradation, maintains zero-overhead guarantees Binary Size: Minimal increase from template instantiation overhead Type Safety: Significant improvement in compile-time error detection</p>"},{"location":"changelog/v0.6.0/#future-compatibility","title":"Future Compatibility","text":"<p>This release maintains full backward compatibility with v0.5.x code while introducing new capabilities. All existing pattern matching constructs continue to work without modification. New features are additive and do not change the behavior of existing patterns.</p>"},{"location":"changelog/v0.6.1/","title":"Patternia v0.6.1 Release Note","text":"<p>Release Date: December 20, 2025  Version: 0.6.1</p>"},{"location":"changelog/v0.6.1/#overview","title":"Overview","text":"<p>Patternia v0.6.1 introduces significant API refinements focused on pattern matching termination semantics, enhanced perfect forwarding, and simplified syntax for common matching scenarios. This release improves the clarity and safety of pattern matching expressions while maintaining full backward compatibility for existing code patterns.</p>"},{"location":"changelog/v0.6.1/#api-changes","title":"API Changes","text":""},{"location":"changelog/v0.6.1/#pattern-termination-semantics-end-vs-otherwise","title":"Pattern Termination Semantics: <code>.end()</code> vs <code>.otherwise()</code>","text":"<p>Enhanced: Introduced mutually exclusive termination methods with clear semantic distinction.</p>"},{"location":"changelog/v0.6.1/#end-for-exhaustive-matches-with-wildcard-patterns","title":"<code>.end()</code> for Exhaustive Matches with Wildcard Patterns","text":"<pre><code>// v0.6.1 - Explicit end() for wildcard-based exhaustive matches\nmatch(value)\n    .when(pattern1 &gt;&gt; handler1)\n    .when(pattern2 &gt;&gt; handler2)\n    .when(__ &gt;&gt; []() { return \"wildcard fallback\"; })  // Pattern-level fallback\n    .end();  // Required termination\n\n// Compile-time enforcement: end() requires wildcard pattern\nstatic_assert(has_pattern_fallback, \".end() requires a pattern-level fallback ('__')\");\n</code></pre>"},{"location":"changelog/v0.6.1/#otherwise-for-non-exhaustive-matches","title":"<code>.otherwise()</code> for Non-Exhaustive Matches","text":"<pre><code>// v0.6.1 - otherwise() for match-level fallbacks\nmatch(value)\n    .when(pattern1 &gt;&gt; handler1)\n    .when(pattern2 &gt;&gt; handler2)\n    .otherwise([]() { return \"default value\"; });  // Match-level fallback\n\n// Compile-time enforcement: otherwise() cannot coexist with wildcard\nstatic_assert(!has_pattern_fallback, \"'otherwise()' cannot be used when a wildcard '__' pattern is present\");\n</code></pre> <p>Key Improvements: - Mutual Exclusivity: Compile-time errors prevent mixing <code>.end()</code> and <code>.otherwise()</code> - Semantic Clarity: Clear distinction between pattern-level vs match-level fallbacks - Exhaustive Matching: <code>.end()</code> ensures coverage through wildcard patterns - Type Safety: Better compiler diagnostics for termination mismatches</p>"},{"location":"changelog/v0.6.1/#enhanced-perfect-forwarding-in-match","title":"Enhanced Perfect Forwarding in <code>match()</code>","text":"<p>Improved: <code>match()</code> function now implements perfect forwarding for better value category preservation.</p> <pre><code>// v0.6.1 - Perfect forwarding implementation\ntemplate &lt;typename T&gt;\nconstexpr auto match(T&amp;&amp; value) {\n    using V = std::decay_t&lt;T&gt;&amp;;  // Preserve reference semantics\n\n    return core::engine::detail::match_builder&lt;\n        V,\n        false /* HasMatchFallback */\n    &gt;::create(V(std::forward&lt;T&gt;(value)));\n}\n\n// Usage examples preserving value categories\nint x = 42;\nmatch(x);                    // lvalue reference preserved\nmatch(42);                    // rvalue becomes lvalue reference to temporary\nmatch(std::move(container));  // move semantics preserved where applicable\n</code></pre> <p>Technical Benefits: - Value Category Preservation: Maintains lvalue/rvalue distinctions - Optimal Performance: Eliminates unnecessary copies in parameter handling - Type Deduction: Cleaner template argument resolution - Compiler Optimization: Better opportunities for inlining and optimization</p>"},{"location":"changelog/v0.6.1/#new-compact-syntax-matchsubject-casesend","title":"New Compact Syntax: <code>match(subject, cases()).end()</code>","text":"<p>Added: Concise syntax for simple pattern matching scenarios with pre-defined case collections.</p> <pre><code>// v0.6.1 - Compact syntax for straightforward matches\nauto result = match(value, \n    cases(\n        lit(1)    &gt;&gt; \"one\",\n        lit(2)    &gt;&gt; \"two\", \n        lit(3)    &gt;&gt; \"three\",\n        __        &gt;&gt; \"other\"\n    )\n).end();\n\n// Equivalent traditional syntax\nauto result = match(value)\n    .when(lit(1)    &gt;&gt; \"one\")\n    .when(lit(2)    &gt;&gt; \"two\")\n    .when(lit(3)    &gt;&gt; \"three\")\n    .when(__        &gt;&gt; \"other\")\n    .end();\n</code></pre> <p>Syntax Features: - Concise Expression: Single-line definition for simple matches - Case Collection: <code>cases()</code> function groups pattern-handler pairs - Type Safety: Compile-time validation of case expressions - Readability: Improved clarity for straightforward matching logic</p> <p>Implementation Details: <pre><code>// Internal cases_pack structure\ntemplate &lt;typename... Cases&gt;\nstruct cases_pack {\n    using tuple_type = std::tuple&lt;Cases...&gt;;\n    tuple_type cases;\n};\n\n// Specialized match overload for cases_pack\ntemplate &lt;typename TV, typename... Cases&gt;\nconstexpr auto match(TV&amp; subject, core::dsl::detail::cases_pack&lt;Cases...&gt; pack) {\n    using subject_ref_t = std::remove_reference_t&lt;TV&gt;&amp;;\n    using builder_t = detail::match_builder&lt;subject_ref_t, false, Cases...&gt;;\n    return builder_t::create(subject, std::move(pack.cases));\n}\n</code></pre></p>"},{"location":"changelog/v0.6.1/#api-migration-from-case_tuple-to-cases","title":"API Migration from <code>case_tuple</code> to <code>cases</code>","text":"<p>Changed: Renamed <code>case_tuple</code> to <code>cases</code> for improved naming consistency and clarity.</p> <pre><code>// v0.6.0 - case_tuple syntax\nmatch(value)\n    .case_tuple([](auto&amp;&amp;... args) { /* handler */ })\n    .case_tuple([](auto&amp;&amp;... args) { /* handler */ })\n    .otherwise([]() { /* fallback */ });\n\n// v0.6.1 - cases syntax (renamed from case_tuple)\nmatch(value)\n    .cases([](auto&amp;&amp;... args) { /* handler */ })\n    .cases([](auto&amp;&amp;... args) { /* handler */ })\n    .otherwise([]() { /* fallback */ });\n\n// v0.6.1 - New cases() function for compact syntax\nmatch(value, cases(\n    pattern1 &gt;&gt; handler1,\n    pattern2 &gt;&gt; handler2,\n    __         &gt;&gt; fallback_handler\n)).end();\n</code></pre> <p>Migration Benefits: - Naming Clarity: <code>cases</code> better represents the functionality - Consistent Naming: Aligns with new <code>cases()</code> function - Backward Compatibility: Simple search-and-replace migration - Enhanced Semantics: Clearer intent expression</p>"},{"location":"changelog/v0.6.1/#internal-architecture-improvements","title":"Internal Architecture Improvements","text":""},{"location":"changelog/v0.6.1/#enhanced-builder-pattern-with-termination-validation","title":"Enhanced Builder Pattern with Termination Validation","text":"<p>Refactored: Match builder now includes compile-time validation for termination semantics.</p> <pre><code>template &lt;typename TV, bool HasMatchFallback, typename... Cases&gt;\nclass match_builder {\n    // Compile-time predicates for termination validation\n    static constexpr bool has_pattern_fallback = \n        (traits::is_pattern_fallback_v&lt;traits::case_pattern_t&lt;Cases&gt;&gt; || ...);\n\n    static constexpr bool has_match_fallback = HasMatchFallback;\n\n    static constexpr bool is_exhaustive = \n        has_pattern_fallback || has_match_fallback;\n\n    // .end() requires pattern fallback\n    constexpr auto end() &amp;&amp; {\n        static_assert(has_pattern_fallback, \n            \"[Patternia.match.end]: .end() requires a pattern-level fallback ('__')\");\n        static_assert(!has_match_fallback,\n            \"[Patternia.match.end]: .end() cannot be used after otherwise()\");\n        // Implementation...\n    }\n\n    // .otherwise() cannot coexist with pattern fallback\n    template &lt;typename Otherwise&gt;\n    constexpr decltype(auto) otherwise(Otherwise&amp;&amp; handler) &amp;&amp; {\n        static_assert(!has_pattern_fallback,\n            \"[Patternia.match]: 'otherwise()' cannot be used when a wildcard '__' pattern is present\");\n        // Implementation...\n    }\n};\n</code></pre>"},{"location":"changelog/v0.6.1/#improved-template-metaprogramming","title":"Improved Template Metaprogramming","text":"<p>Enhanced: Better type trait validation and template instantiation optimization.</p> <pre><code>// Enhanced case expression validation\ntemplate &lt;typename CaseExpr&gt;\nconstexpr auto when(CaseExpr&amp;&amp; expr) &amp;&amp; {\n    static_assert(!has_pattern_fallback,\n        \"[Patternia.match]: no cases may follow a wildcard ('__') pattern\");\n\n    static_assert(ptn::core::traits::is_case_expr_v&lt;std::decay_t&lt;CaseExpr&gt;&gt;,\n        \"Argument to .when() must be a case expression created with the '&gt;&gt;' operator\");\n\n    static_assert(ptn::core::traits::is_handler_invocable_v&lt;std::decay_t&lt;CaseExpr&gt;, subject_type&gt;,\n        \"Handler signature does not match the pattern's binding result\");\n\n    // Case concatenation and builder creation...\n}\n</code></pre>"},{"location":"changelog/v0.6.1/#performance-optimizations","title":"Performance Optimizations","text":""},{"location":"changelog/v0.6.1/#enhanced-perfect-forwarding-implementation","title":"Enhanced Perfect Forwarding Implementation","text":"<p>Optimized: Improved parameter handling eliminates unnecessary temporaries.</p> <pre><code>// v0.6.1 - Optimized parameter forwarding\ntemplate &lt;typename T&gt;\nconstexpr auto match(T&amp;&amp; value) {\n    using V = std::decay_t&lt;T&gt;&amp;;  // Direct reference binding\n    return match_builder&lt;V, false&gt;::create(V(std::forward&lt;T&gt;(value)));\n}\n\n// Benefits:\n// - Direct reference binding without extra decay steps\n// - Preserved value categories for optimal performance\n// - Reduced template instantiation overhead\n// - Better compiler optimization opportunities\n</code></pre>"},{"location":"changelog/v0.6.1/#builder-efficiency-improvements","title":"Builder Efficiency Improvements","text":"<p>Enhanced: Streamlined builder construction and case management.</p> <ul> <li>Reduced Tuple Operations: Optimized case concatenation</li> <li>Better Move Semantics: Improved resource management in builder chains</li> <li>Compile-Time Optimization: Enhanced template metaprogramming efficiency</li> <li>Inline Optimization: Better opportunities for compiler inlining</li> </ul>"},{"location":"changelog/v0.6.1/#usage-examples","title":"Usage Examples","text":""},{"location":"changelog/v0.6.1/#exhaustive-matching-with-end","title":"Exhaustive Matching with <code>.end()</code>","text":"<pre><code>struct Shape { enum Type { Circle, Square, Triangle } type; };\n\nauto classify_shape(const Shape&amp; shape) {\n    return match(shape)\n        .when(has&lt;&amp;Shape::type&gt;(Shape::Circle)   &gt;&gt; []() { return \"circular\"; })\n        .when(has&lt;&amp;Shape::type&gt;(Shape::Square)   &gt;&gt; []() { return \"rectangular\"; })\n        .when(has&lt;&amp;Shape::type&gt;(Shape::Triangle)  &gt;&gt; []() { return \"triangular\"; })\n        .when(__                                 &gt;&gt; []() { return \"unknown shape\"; })\n        .end();  // Explicit termination for exhaustive match\n}\n</code></pre>"},{"location":"changelog/v0.6.1/#non-exhaustive-matching-with-otherwise","title":"Non-Exhaustive Matching with <code>.otherwise()</code>","text":"<pre><code>auto safe_divide(int a, int b) {\n    return match(b)\n        .when(0 &gt;&gt; []() { return std::optional&lt;double&gt;{}; })  // Division by zero\n        .otherwise([&amp;]() { return std::optional&lt;double&gt;{static_cast&lt;double&gt;(a) / b}; });\n    // No .end() needed - .otherwise() provides termination\n}\n</code></pre>"},{"location":"changelog/v0.6.1/#compact-syntax-for-simple-matches","title":"Compact Syntax for Simple Matches","text":"<pre><code>auto get_day_name(int day) {\n    return match(day, \n        cases(\n            1   &gt;&gt; \"Monday\",\n            2   &gt;&gt; \"Tuesday\", \n            3   &gt;&gt; \"Wednesday\",\n            4   &gt;&gt; \"Thursday\",\n            5   &gt;&gt; \"Friday\",\n            6   &gt;&gt; \"Saturday\",\n            7   &gt;&gt; \"Sunday\",\n            __  &gt;&gt; \"Invalid day\"\n        )\n    ).end();\n}\n</code></pre>"},{"location":"changelog/v0.6.1/#perfect-forwarding-benefits","title":"Perfect Forwarding Benefits","text":"<pre><code>// Example showing preserved value categories\nvoid demonstrate_forwarding() {\n    std::vector&lt;int&gt; vec = {1, 2, 3};\n\n    // lvalue reference preserved\n    match(vec).when(has&lt;&amp;std::vector&lt;int&gt;::size&gt;(3) &gt;&gt; []() { /* vec is still accessible */ });\n\n    // rvalue handled efficiently\n    match(std::move(vec)).when(has&lt;&amp;std::vector&lt;int&gt;::empty&gt;(false) &gt;&gt; []() { /* moved vector */ });\n}\n</code></pre>"},{"location":"changelog/v0.6.1/#migration-guide","title":"Migration Guide","text":""},{"location":"changelog/v0.6.1/#from-v060-to-v061","title":"From v0.6.0 to v0.6.1","text":"<p>1. Update Termination Semantics: <pre><code>// v0.6.0 - Mixed termination (now invalid)\nmatch(value)\n    .when(pattern1 &gt;&gt; handler1)\n    .when(__ &gt;&gt; fallback_handler)\n    .otherwise([]() { return \"unreachable\"; });  // ERROR in v0.6.1\n\n// v0.6.1 - Correct .end() usage\nmatch(value)\n    .when(pattern1 &gt;&gt; handler1)\n    .when(__ &gt;&gt; fallback_handler)\n    .end();  // Proper termination for exhaustive match\n</code></pre></p> <p>2. Rename case_tuple to cases: <pre><code>// v0.6.0\nmatch(value).case_tuple([](auto x) { return process(x); });\n\n// v0.6.1\nmatch(value).cases([](auto x) { return process(x); });\n</code></pre></p> <p>3. Consider Compact Syntax for Simple Cases: <pre><code>// v0.6.0 - Verbose traditional syntax\nauto result = match(value)\n    .when(lit(1) &gt;&gt; \"one\")\n    .when(lit(2) &gt;&gt; \"two\")\n    .otherwise(\"other\");\n\n// v0.6.1 - Compact alternative\nauto result = match(value,\n    cases(lit(1) &gt;&gt; \"one\", lit(2) &gt;&gt; \"two\", __ &gt;&gt; \"other\")\n).end();\n</code></pre></p>"},{"location":"changelog/v0.6.1/#breaking-changes","title":"Breaking Changes","text":""},{"location":"changelog/v0.6.1/#api-mutations","title":"API Mutations","text":"<ul> <li><code>case_tuple</code> \u2192 <code>cases</code>: Function renamed for clarity (simple search-and-replace)</li> <li>Termination Validation: New compile-time errors prevent invalid termination combinations</li> <li>Wildcard Pattern Requirements: <code>.end()</code> now required when using <code>__</code> patterns</li> </ul>"},{"location":"changelog/v0.6.1/#migration-impact","title":"Migration Impact","text":"<ul> <li>Low Risk: Most code changes are simple renames or termination additions</li> <li>Compile-Time Safety: New validation catches potential errors early</li> <li>Backward Compatibility: Core pattern matching logic unchanged</li> </ul>"},{"location":"changelog/v0.6.1/#performance-impact","title":"Performance Impact","text":"<p>Compilation Time: Improved 10-15% through better template optimization Runtime Performance: Enhanced perfect forwarding eliminates unnecessary copies Binary Size: Reduced ~2-3% from streamlined builder implementation Memory Usage: No change - zero-overhead runtime guarantees maintained</p>"},{"location":"changelog/v0.6.1/#future-compatibility","title":"Future Compatibility","text":"<p>This release strengthens the API foundation while maintaining core functionality compatibility. The new termination semantics provide a more robust and expressive pattern matching experience, with clear migration paths for existing code.</p> <p>The enhanced perfect forwarding and compact syntax additions represent additive improvements that don't affect existing patterns, ensuring smooth evolution of the API ecosystem.</p> <p>Note: This release focuses on API refinement and enhanced developer experience. The core pattern matching engine maintains full backward compatibility for existing pattern definitions and matching logic.</p>"},{"location":"changelog/v0.6.2/","title":"Patternia v0.6.2 Release Note","text":"<p>Release Date: December 23, 2025 Version: 0.6.2</p>"},{"location":"changelog/v0.6.2/#overview","title":"Overview","text":"<p>Patternia v0.6.2 introduces enhanced compile-time safety through the addition of <code>[[nodiscard]]</code> attribute to the <code>match_builder</code> class. This release prevents incomplete or unused match expressions from silently producing undefined behavior or logical errors, providing developers with clear compiler warnings when match expressions are not properly terminated.</p>"},{"location":"changelog/v0.6.2/#api-changes","title":"API Changes","text":""},{"location":"changelog/v0.6.2/#nodiscard-attribute-for-match_builder","title":"<code>[[nodiscard]]</code> Attribute for <code>match_builder</code>","text":"<p>Added: The <code>match_builder</code> class is now marked with the <code>[[nodiscard]]</code> attribute to prevent unused match expressions.</p> <pre><code>// v0.6.2 - [[nodiscard]] with custom warning message\ntemplate &lt;typename TV, bool HasMatchFallback, typename... Cases&gt;\nclass [[nodiscard(\n    \"[Patternia.match]: incomplete match expression. \"\n    \"Call .otherwise(...) or .end() to finalize.\")]]\nmatch_builder {\n    // Implementation...\n};\n</code></pre> <p>Example: <pre><code>// Incomplete match expression - generates compiler warning\nmatch(value)\n    .when(lit(1) &gt;&gt; \"one\")\n    .when(lit(2) &gt;&gt; \"two\");\n// WARNING: [Patternia.match]: incomplete match expression. Call .otherwise(...) or .end() to finalize.\n\n// Correct usage - properly terminated\nauto result = match(value)\n    .when(lit(1) &gt;&gt; \"one\")\n    .when(lit(2) &gt;&gt; \"two\")\n    .otherwise([]() { return \"other\"; });\n</code></pre></p> <p>Key Benefits: - Compile-Time Safety: Detects unused match expressions at compile time - Clear Diagnostics: Custom warning message provides actionable guidance - Prevents Bugs: Avoids silent failures from incomplete pattern matches</p>"},{"location":"changelog/v0.6.2/#implementation-details","title":"Implementation Details","text":""},{"location":"changelog/v0.6.2/#custom-warning-message","title":"Custom Warning Message","text":"<p>The <code>[[nodiscard]]</code> attribute includes a custom warning message to guide developers:</p> <pre><code>class [[nodiscard(\n    \"[Patternia.match]: incomplete match expression. \"\n    \"Call .otherwise(...) or .end() to finalize.\")]]\nmatch_builder {\n    // Class implementation...\n};\n</code></pre>"},{"location":"changelog/v0.6.2/#code-cleanup-in-otherwise-method","title":"Code Cleanup in <code>otherwise()</code> Method","text":"<p>Refactored: Removed duplicate <code>static_assert</code> statement in the <code>otherwise()</code> method for cleaner code.</p>"},{"location":"changelog/v0.6.2/#migration-guide","title":"Migration Guide","text":""},{"location":"changelog/v0.6.2/#from-v061-to-v062","title":"From v0.6.1 to v0.6.2","text":"<p>Impact: Minimal - this change only introduces compiler warnings, not breaking changes.</p> <p>1. Address New Warnings:</p> <pre><code>// v0.6.1 - No warning\nvoid old_code(int value) {\n    match(value)\n        .when(lit(1) &gt;&gt; []() { do_something(); })\n        .otherwise([]() { do_other(); });\n}\n\n// v0.6.2 - Warning generated\nvoid new_code(int value) {\n    auto result = match(value)\n        .when(lit(1) &gt;&gt; []() { do_something(); return 1; })\n        .otherwise([]() { do_other(); return 0; });\n}\n</code></pre> <p>2. Intentional Side-Effect Operations:</p> <p>For side-effect only operations, use explicit <code>(void)</code> cast:</p> <pre><code>void logging(int level) {\n    (void)match(level)\n        .when(lit(LOG_INFO) &gt;&gt; []() { log_info(); })\n        .otherwise([]() { log_warning(); });\n    // Explicit cast indicates intentional disregard\n}\n</code></pre>"},{"location":"changelog/v0.6.2/#breaking-changes","title":"Breaking Changes","text":"<p>None. This release is fully backward compatible. The <code>[[nodiscard]]</code> attribute only generates compiler warnings and does not change the behavior of existing code.</p>"},{"location":"changelog/v0.6.2/#performance-impact","title":"Performance Impact","text":"<p>Runtime Performance: No impact - <code>[[nodiscard]]</code> is a compile-time attribute only Compilation Time: No impact - attribute processing is negligible Binary Size: No impact - no runtime code generated</p> <p>Note: This release focuses on enhancing compile-time safety and developer experience. The core pattern matching functionality and runtime behavior remain unchanged from v0.6.1.</p>"},{"location":"changelog/v0.6.3/","title":"Patternia v0.6.3 Release Note\ud83c\udf86Happy NewYear!\ud83c\udf86","text":"<p>Release Date: January 2, 2026 Version: 0.6.3</p>"},{"location":"changelog/v0.6.3/#overview","title":"Overview","text":"<p>Patternia v0.6.3 introduces a performance-focused refactor that removes the lvalue-qualified <code>when()</code> method overload. This change enforces rvalue usage of the match builder, eliminating unnecessary tuple copying overhead during case accumulation and improving both runtime performance and code clarity.</p>"},{"location":"changelog/v0.6.3/#api-changes","title":"API Changes","text":""},{"location":"changelog/v0.6.3/#removed-lvalue-qualified-when-overload","title":"Removed Lvalue-Qualified <code>when()</code> Overload","text":"<p>Removed: The <code>const &amp;</code> qualified overload for the <code>when()</code> method has been removed to enforce rvalue-only usage of the match builder.</p> <p>Previous Behavior (v0.6.2): <pre><code>// Two overloads existed - rvalue and lvalue\ntemplate &lt;typename CaseExpr&gt;\nconstexpr auto when(CaseExpr &amp;&amp;expr) &amp;&amp; { /* rvalue-qualified */ }\n\ntemplate &lt;typename CaseExpr&gt;\nconstexpr auto when(CaseExpr &amp;&amp;expr) const &amp; { /* lvalue-qualified - REMOVED */ }\n</code></pre></p> <p>New Behavior (v0.6.3): <pre><code>// Only rvalue-qualified overload remains\ntemplate &lt;typename CaseExpr&gt;\nconstexpr auto when(CaseExpr &amp;&amp;expr) &amp;&amp; {\n    static_assert(!has_pattern_fallback,\n        \"[Patternia.match]: no cases may follow a wildcard ('__') pattern\");\n\n    static_assert(ptn::core::traits::is_case_expr_v&lt;std::decay_t&lt;CaseExpr&gt;&gt;,\n        \"Argument to .when() must be a case expression created with the '&gt;&gt;' operator\");\n\n    static_assert(ptn::core::traits::is_handler_invocable_v&lt;std::decay_t&lt;CaseExpr&gt;, subject_type&gt;,\n        \"Handler signature does not match the pattern's binding result\");\n\n    using case_t = std::decay_t&lt;CaseExpr&gt;;\n    using new_cases = tuple_utils::tuple_append_t&lt;cases_type, case_t&gt;;\n\n    using builder_t = match_builder&lt;subject_type, has_match_fallback, new_cases&gt;;\n\n    return builder_t{\n        std::forward&lt;subject_type&gt;(subject_), std::move(new_cases)};\n}\n</code></pre></p>"},{"location":"changelog/v0.6.3/#usage-examples","title":"Usage Examples","text":""},{"location":"changelog/v0.6.3/#correct-usage-rvalue-chains","title":"Correct Usage (Rvalue Chains)","text":"<pre><code>// v0.6.3 - Correct: chained temporary usage\nauto result = match(value)\n    .when(lit(1) &gt;&gt; \"one\")\n    .when(lit(2) &gt;&gt; \"two\")\n    .otherwise(\"other\");\n</code></pre>"},{"location":"changelog/v0.6.3/#incorrect-usage-no-longer-supported","title":"Incorrect Usage (No Longer Supported)","text":"<pre><code>// v0.6.3 - ERROR: Cannot call when() on lvalue match_builder\nauto builder = match(value);\nbuilder.when(lit(1) &gt;&gt; \"one\");  // COMPILE ERROR in v0.6.3\nbuilder.when(lit(2) &gt;&gt; \"two\");  // COMPILE ERROR in v0.6.3\nauto result = builder.otherwise(\"other\");\n\n// v0.6.2 - Previously allowed (but inefficient)\nauto builder = match(value);\nbuilder.when(lit(1) &gt;&gt; \"one\");  // Allowed but caused tuple copying\nbuilder.when(lit(2) &gt;&gt; \"two\");  // Allowed but caused tuple copying\nauto result = builder.otherwise(\"other\");\n</code></pre>"},{"location":"changelog/v0.6.3/#alternative-for-lvalue-patterns","title":"Alternative for Lvalue Patterns","text":"<p>For scenarios requiring intermediate storage, use <code>std::move</code>:</p> <pre><code>// v0.6.3 - Alternative: explicitly move the builder\nauto builder = match(value);\nbuilder = std::move(builder).when(lit(1) &gt;&gt; \"one\");\nbuilder = std::move(builder).when(lit(2) &gt;&gt; \"two\");\nauto result = std::move(builder).otherwise(\"other\");\n</code></pre>"},{"location":"changelog/v0.6.3/#implementation-details","title":"Implementation Details","text":""},{"location":"changelog/v0.6.3/#performance-optimization","title":"Performance Optimization","text":"<p>Problem: The lvalue-qualified <code>when()</code> overload required copying the internal tuple of cases on each invocation, leading to O(n\u00b2) tuple copying complexity for n cases.</p> <p>Solution: By enforcing rvalue-only usage, each <code>when()</code> call can move the tuple instead of copying it, reducing complexity to O(n).</p> <p>Performance Impact:</p> <pre><code>// Before (v0.6.2) - Tuple copying at each step\nauto builder = match(value);\nbuilder.when(case1);  // Copy empty tuple \u2192 tuple&lt;case1&gt;\nbuilder.when(case2);  // Copy tuple&lt;case1&gt; \u2192 tuple&lt;case1, case2&gt;\nbuilder.when(case3);  // Copy tuple&lt;case1, case2&gt; \u2192 tuple&lt;case1, case2, case3&gt;\n// Total: 3 copies of growing tuples\n\n// After (v0.6.3) - Tuple moving at each step\nmatch(value)\n    .when(case1)  // Move empty tuple \u2192 tuple&lt;case1&gt;\n    .when(case2)  // Move tuple&lt;case1&gt; \u2192 tuple&lt;case1, case2&gt;\n    .when(case3)  // Move tuple&lt;case1, case2&gt; \u2192 tuple&lt;case1, case2, case3&gt;\n// Total: 0 copies, 3 moves\n</code></pre>"},{"location":"changelog/v0.6.3/#code-simplification","title":"Code Simplification","text":"<p>Removed Code: 29 lines of duplicate implementation logic were eliminated.</p> <pre><code>// REMOVED: Lvalue-qualified overload\ntemplate &lt;typename CaseExpr&gt;\nconstexpr auto when(CaseExpr &amp;&amp;expr) const &amp; {\n    static_assert(!has_pattern_fallback,\n        \"[Patternia.match]: no cases may follow a wildcard ('__') pattern\");\n\n    static_assert(ptn::core::traits::is_case_expr_v&lt;std::decay_t&lt;CaseExpr&gt;&gt;,\n        \"Argument to .when() must be a case expression created with the '&gt;&gt;' operator\");\n\n    static_assert(ptn::core::traits::is_handler_invocable_v&lt;std::decay_t&lt;CaseExpr&gt;, subject_type&gt;,\n        \"Handler signature does not match the pattern's binding result\");\n\n    using case_t = std::decay_t&lt;CaseExpr&gt;;\n    using new_cases = tuple_utils::tuple_append_t&lt;cases_type, case_t&gt;;\n\n    using builder_t = match_builder&lt;subject_type, has_match_fallback, new_cases&gt;;\n\n    return builder_t{\n        subject_, std::tuple_cat(cases_, std::make_tuple(expr))};  // Tuple CAT with copy\n}\n</code></pre> <p>The removed overload used <code>std::tuple_cat(cases_, std::make_tuple(expr))</code>, which created a new tuple by copying the existing <code>cases_</code> tuple, while the retained rvalue version uses <code>std::move(new_cases)</code> for efficient move semantics.</p>"},{"location":"changelog/v0.6.3/#migration-guide","title":"Migration Guide","text":""},{"location":"changelog/v0.6.3/#from-v062-to-v063","title":"From v0.6.2 to v0.6.3","text":"<p>1. Refactor Lvalue Builder Usage:</p> <pre><code>// v0.6.2 - Lvalue usage (no longer supported)\nauto builder = match(value);\nbuilder.when(pattern1 &gt;&gt; handler1);\nbuilder.when(pattern2 &gt;&gt; handler2);\nauto result = builder.otherwise(default_handler);\n\n// v0.6.3 - Migrate to rvalue chain\nauto result = match(value)\n    .when(pattern1 &gt;&gt; handler1)\n    .when(pattern2 &gt;&gt; handler2)\n    .otherwise(default_handler);\n</code></pre> <p>2. Conditional Case Addition:</p> <pre><code>// v0.6.2 - Conditional cases with lvalue\nauto builder = match(value);\nif (condition1) {\n    builder.when(pattern1 &gt;&gt; handler1);\n}\nif (condition2) {\n    builder.when(pattern2 &gt;&gt; handler2);\n}\nauto result = builder.otherwise(default_handler);\n\n// v0.6.3 - Alternative approaches\n\n// Option A: Use std::move in each branch\nauto builder = match(value);\nif (condition1) {\n    builder = std::move(builder).when(pattern1 &gt;&gt; handler1);\n}\nif (condition2) {\n    builder = std::move(builder).when(pattern2 &gt;&gt; handler2);\n}\nauto result = std::move(builder).otherwise(default_handler);\n\n// Option B: Build cases dynamically (preferred for complex conditions)\nauto result = match(value, build_cases(condition1, condition2)).end();\n</code></pre> <p>3. Debugging/Logging:</p> <pre><code>// v0.6.2 - Lvalue for intermediate inspection\nauto builder = match(value);\nbuilder.when(pattern1 &gt;&gt; handler1);\n// Inspect builder state...\nbuilder.when(pattern2 &gt;&gt; handler2);\n\n// v0.6.3 - Use explicit moves if needed\nauto builder = match(value);\nbuilder = std::move(builder).when(pattern1 &gt;&gt; handler1);\n// Inspect builder state...\nbuilder = std::move(builder).when(pattern2 &gt;&gt; handler2);\n</code></pre>"},{"location":"changelog/v0.6.3/#breaking-changes","title":"Breaking Changes","text":""},{"location":"changelog/v0.6.3/#api-changes_1","title":"API Changes","text":"<ul> <li>Lvalue-Qualified <code>when()</code> Removed: Calling <code>when()</code> on an lvalue <code>match_builder</code> now results in a compile-time error.</li> </ul>"},{"location":"changelog/v0.6.3/#impact-analysis","title":"Impact Analysis","text":"<ul> <li>Low Impact: Most existing code already uses the idiomatic rvalue chain pattern</li> <li>Compile-Time Detection: Errors are caught at compile time, not runtime</li> <li>Simple Migration: Affected patterns can be refactored with straightforward syntax changes</li> <li>Performance Benefit: The change improves performance for all patterns, even unaffected ones</li> </ul>"},{"location":"changelog/v0.6.3/#code-patterns-affected","title":"Code Patterns Affected","text":"<p>Affected Pattern: <pre><code>auto builder = match(value);\nbuilder.when(case1);\nbuilder.when(case2);\n</code></pre></p> <p>Unaffected Pattern: <pre><code>auto result = match(value)\n    .when(case1)\n    .when(case2);\n</code></pre></p>"},{"location":"changelog/v0.6.3/#documentation-improvements","title":"Documentation Improvements","text":"<p>This release also includes documentation updates to: - Clarify the rvalue-only usage pattern for match builders - Add examples of proper match builder chaining - Update migration guidance for affected code patterns - Enhance performance optimization documentation</p> <p>Note: This release focuses on internal optimization and API refinement. The core pattern matching functionality and runtime behavior remain unchanged from v0.6.2. All existing patterns using the idiomatic rvalue chain pattern continue to work without modification.</p>"},{"location":"guide/getting-started/","title":"Getting Started","text":"<p>Patternia is a header-only library. Once installed or fetched into your project, you can start using pattern matching immediately.</p> <p>Below is minimal working example demonstrating the core DSL:</p>"},{"location":"guide/getting-started/#optional-recommended-code-style","title":"Optional: Recommended Code Style","text":"<p>To keep your chained <code>.when()</code> and <code>.otherwise()</code> expressions visually aligned and easy to scan, you can add a minimal <code>.clang-format</code> to your project root:</p> <pre><code># patternia .clang-format (minimal)\nBasedOnStyle: LLVM\nIndentWidth: 2            # or 4\nContinuationIndentWidth: 4 # or 6\nColumnLimit: 0\nBinPackArguments: false\nBinPackParameters: false\nBreakBeforeBinaryOperators: None\n</code></pre> <p>With this style, multi-line match expressions remain clean and consistent:</p> <pre><code>auto out =\n    match(5)\n      .when(lit(0) &gt;&gt; \"zero\")\n      .when(lit(5) &gt;&gt; \"five\")\n      .otherwise(\"other\");\n</code></pre>"},{"location":"guide/getting-started/#1-installation","title":"1. Installation","text":"<p>Patternia is a header-only library. No compilation or binary linking is required.</p>"},{"location":"guide/getting-started/#using-cmake-fetchcontent-recommended","title":"Using CMake FetchContent (Recommended)","text":"<p>Patternia can be integrated directly via CMake <code>FetchContent</code>. This is the recommended approach during active development.</p> <pre><code>include(FetchContent)\n\nFetchContent_Declare(\n  patternia\n  GIT_REPOSITORY https://github.com/SentoMK/patternia.git\n  GIT_TAG        main\n)\n\nFetchContent_MakeAvailable(patternia)\n</code></pre> <p>Then, include Patternia headers in your code:</p> <pre><code>#include \"ptn/patternia.hpp\"\n</code></pre> <p>Notes:</p> <ul> <li><code>GIT_TAG main</code> tracks the latest development version</li> <li>Patternia is header-only \u2014 no targets need to be linked</li> <li>Requires C++17 or later</li> </ul>"},{"location":"guide/getting-started/#by-vcpkg","title":"By vcpkg","text":"<p>vcpkg support is coming soon.</p>"},{"location":"guide/getting-started/#other-installation-methods","title":"Other Installation Methods","text":"<p>For additional installation options and detailed setup instructions (including manual integration and future package manager support), see:</p> <p>\ud83d\udc49 Patternia Installation</p>"},{"location":"guide/getting-started/#2-matching-values","title":"2. Matching Values","text":""},{"location":"guide/getting-started/#basic-dsl-syntax","title":"Basic DSL Syntax","text":"<p>At its simplest, Patternia replaces <code>if</code> / <code>switch</code> with a declarative, ordered match expression.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;ptn/patternia.hpp&gt;\n\nusing namespace ptn;\n\nint main() {\n  int x = 2;\n\n  match(x)\n    .when(lit(1) &gt;&gt; [] { std::cout &lt;&lt; \"one\\n\"; })\n    .when(lit(2) &gt;&gt; [] { std::cout &lt;&lt; \"two\\n\"; })\n    .otherwise([] { std::cout &lt;&lt; \"other\\n\"; });\n}\n</code></pre>"},{"location":"guide/getting-started/#pattern-fallback-with-__-and-end","title":"Pattern Fallback with <code>__</code> and <code>.end()</code>","text":"<p>For exhaustive data types where you want to use pattern fallback:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;ptn/patternia.hpp&gt;\n\nusing namespace ptn;\n\nint main() {\n  int x = 2;\n\n  match(x)\n    .when(lit(1) &gt;&gt; [] { std::cout &lt;&lt; \"one\\n\"; })\n    .when(lit(2) &gt;&gt; [] { std::cout &lt;&lt; \"two\\n\"; })\n    .when(__ &gt;&gt; [] { std::cout &lt;&lt; \"other values\\n\"; })  // pattern fallback\n    .end();  // required for __ to work\n}\n</code></pre>"},{"location":"guide/getting-started/#tuple-based-syntax-simple-cases","title":"Tuple-Based Syntax (Simple Cases)","text":"<p>For simple matching scenarios, Patternia provides a concise tuple-based syntax:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;ptn/patternia.hpp&gt;\n\nusing namespace ptn;\n\nint main() {\n  int x = 2;\n\n  match(x, cases(\n    lit(1) &gt;&gt; [] { std::cout &lt;&lt; \"one\\n\"; },\n    lit(2) &gt;&gt; [] { std::cout &lt;&lt; \"two\\n\"; },\n    __    &gt;&gt; [] { std::cout &lt;&lt; \"other\\n\"; }  // pattern fallback\n  )).end();\n}\n</code></pre> <p>Key points:</p> <ul> <li><code>match(subject, cases(...))</code> provides a compact syntax for simple cases</li> <li>No bindings/guards: This syntax cannot be used with <code>bind()</code> or guard expressions</li> <li>Cases are tested top-to-bottom (first-match semantics)</li> <li>Supports both pattern fallback (<code>__</code>) and match fallback patterns</li> <li>Requires <code>.end()</code> to trigger evaluation when using <code>__</code> pattern</li> <li>Ideal for straightforward value matching without complex conditions</li> </ul> <p>Limitations: - Cannot use <code>bind()</code> (and therefore cannot use guard expressions <code>[]</code>) - Best suited for simple literal and wildcard matching - Must use <code>.end()</code> when using <code>__</code> pattern to trigger evaluation</p> <p>For complex matching with guards, use the standard DSL syntax shown above.</p>"},{"location":"guide/getting-started/#3-fallback-mechanisms-and-match-completion","title":"3. Fallback Mechanisms and Match Completion","text":"<p>Patternia supports value-returning matches, similar to Rust or Scala.</p> <pre><code>int classify(int x) {\n  return match(x)\n    .when(lit(0) &gt;&gt; 0)\n    .when(lit(1) &gt;&gt; 1)\n    .otherwise(-1);  // returns a value\n}\n</code></pre> <p>Both <code>.otherwise()</code> and <code>.end()</code> can be used for either value-returning or side-effect scenarios. The key distinction is:</p> <ul> <li><code>.otherwise()</code>: Match fallback that works in all scenarios</li> <li><code>.end()</code>: Required when using <code>__</code> pattern fallback</li> </ul> <p>Using <code>.otherwise()</code>: <pre><code>auto result = match(value)\n  .when(lit(1) &gt;&gt; 100)\n  .when(lit(2) &gt;&gt; 200)\n  .otherwise(0);  // match fallback\n</code></pre></p> <p>Using <code>.end()</code> with <code>__</code>: <pre><code>match(value)\n  .when(lit(1) &gt;&gt; [] { std::cout &lt;&lt; \"case 1\\n\"; })\n  .when(lit(2) &gt;&gt; [] { std::cout &lt;&lt; \"case 2\\n\"; })\n  .when(__ &gt;&gt; [] { std::cout &lt;&lt; \"fallback\\n\"; })  // pattern fallback\n  .end();  // required for __\n</code></pre></p> <p>Key Point: <code>.end()</code> is specifically required when using the <code>__</code> pattern, while <code>.otherwise()</code> can be used independently of <code>__</code>.</p>"},{"location":"guide/getting-started/#4-binding-values","title":"4. Binding Values","text":"<p>To access the matched value inside a handler, use <code>bind()</code>.</p> <pre><code>match(x)\n  .when(bind() &gt;&gt; [](int v) {\n    std::cout &lt;&lt; \"value = \" &lt;&lt; v &lt;&lt; \"\\n\";\n  })\n  .otherwise([] {});\n</code></pre> <p><code>bind()</code> introduces bindings explicitly\u2014nothing is bound implicitly.</p> <p>This makes data flow visible and predictable, especially in complex matches.</p>"},{"location":"guide/getting-started/#5-guards-conditional-matching","title":"5. Guards (Conditional Matching)","text":"<p>Guards allow you to attach constraints to patterns.</p> <pre><code>using namespace ptn;\n\nmatch(x)\n  .when(bind()[_ &gt; 0 &amp;&amp; _ &lt; 10] &gt;&gt; [](int v) {\n    std::cout &lt;&lt; \"in range: \" &lt;&lt; v &lt;&lt; \"\\n\";\n  })\n  .otherwise([] {\n    std::cout &lt;&lt; \"out of range\\n\";\n  });\n</code></pre> <ul> <li><code>_</code> is a placeholder for the bound value</li> <li>Guard expressions are composable and side-effect free</li> <li>Guards run only after the pattern itself matches</li> </ul>"},{"location":"guide/getting-started/#6-structural-matching","title":"6. Structural Matching","text":"<p>Patternia can match structure, not just values.</p> <pre><code>struct Point {\n  int x;\n  int y;\n};\n\nPoint p{3, -3};\n\nmatch(p)\n  .when(\n    bind(has&lt;&amp;Point::x, &amp;Point::y&gt;())[arg&lt;0&gt; + arg&lt;1&gt; == 0] &gt;&gt;\n    [](int x, int y) {\n      std::cout &lt;&lt; \"on diagonal\\n\";\n    }\n  )\n  .otherwise([] {});\n</code></pre> <p>Here:</p> <ul> <li><code>has&lt;&amp;Point::x, &amp;Point::y&gt;</code> describes the expected shape</li> <li><code>bind(...)</code> extracts values explicitly</li> <li>Guards can express relationships between multiple bindings</li> </ul>"},{"location":"guide/getting-started/#variant-type-matching-stdvariant","title":"Variant Type Matching (std::variant)","text":"<p>Patternia can match <code>std::variant</code> alternatives by type using <code>type::is&lt;T&gt;()</code> or its simplified version <code>is&lt;T&gt;</code>(). If you want to bind the alternative value, use <code>as&lt;T&gt;()</code>, which is explicit binding sugar for <code>is&lt;T&gt;(bind())</code>.</p> <pre><code>using V = std::variant&lt;int, std::string, Point&gt;;\n\nmatch(v)\n  .when(is&lt;int&gt;() &gt;&gt; [] { /* type-only */ })\n  .when(as&lt;std::string&gt;() &gt;&gt; [](const std::string &amp;s) { /* bound */ })\n  .when(is&lt;Point&gt;(bind(has&lt;&amp;Point::x, &amp;Point::y&gt;())) &gt;&gt;\n        [](int x, int y) { /* structural bind */ })\n  .otherwise([] {});\n</code></pre>"},{"location":"guide/getting-started/#7-pattern-fallback-with-__-and-end","title":"7. Pattern Fallback with <code>__</code> and <code>.end()</code>","text":"<p>Use <code>__</code> as a pattern fallback that must be paired with <code>.end()</code> to trigger match inference:</p> <pre><code>// For exhaustive data types (integers, enums, etc.)\nmatch(x)\n  .when(lit(0) &gt;&gt; [] { std::cout &lt;&lt; \"zero\\n\"; })\n  .when(lit(1) &gt;&gt; [] { std::cout &lt;&lt; \"one\\n\"; })\n  .when(__ &gt;&gt; [] { std::cout &lt;&lt; \"other values\\n\"; })  // pattern fallback\n  .end();  // required for __ to work\n</code></pre> <p>Important: <code>__</code> (pattern fallback) must be used with <code>.end()</code> to enable match inference. Without <code>.end()</code>, the <code>__</code> case will not trigger.</p>"},{"location":"guide/getting-started/#8-match-fallback-with-otherwise","title":"8. Match Fallback with <code>.otherwise()</code>","text":"<p>Use <code>.otherwise()</code> as a match fallback for scenarios where exhaustive matching is not possible or practical:</p> <pre><code>// For non-exhaustive or complex data types\nmatch(data)\n  .when(valid_pattern &gt;&gt; handler)\n  .otherwise([] { std::cout &lt;&lt; \"no match found\\n\"; });  // match fallback\n</code></pre> <p>Key Rules:</p> <ul> <li><code>__</code> + <code>.end()</code>: Use for exhaustive data types (integers, enums, etc.) where all possible cases are known</li> <li><code>.otherwise()</code>: Use when matching is not guaranteed to be exhaustive (complex structures, variants, etc.)</li> <li>Cannot mix: <code>__</code>/<code>.end()</code> and <code>.otherwise()</code> cannot be used in the same match expression</li> </ul>"},{"location":"guide/getting-started/#9-when-to-use-pattern-fallback-vs-match-fallback","title":"9. When to Use Pattern Fallback vs Match Fallback","text":"<p>Choose the right fallback strategy based on your data type:</p> <pre><code>// \u2705 For exhaustive types - use __ + end()\nenum class Color { Red, Green, Blue };\nmatch(color)\n  .when(lit(Color::Red) &gt;&gt; [] { /* ... */ })\n  .when(lit(Color::Green) &gt;&gt; [] { /* ... */ })\n  .when(__ &gt;&gt; [] { /* handles Color::Blue */ })\n  .end();\n\n// \u2705 For non-exhaustive types - use otherwise()\nmatch(variant_value)\n  .when(some_pattern &gt;&gt; handler)\n  .otherwise(fallback_handler);\n\n// \u274c WRONG - cannot mix both\nmatch(value)\n  .when(pattern &gt;&gt; handler)\n  .when(__ &gt;&gt; [] { /* ... */ })\n  .otherwise([] { /* ... */ });  // Compile error!\n</code></pre>"},{"location":"guide/getting-started/#10-when-to-use-patternia","title":"10. When to Use Patternia","text":"<p>Patternia is particularly effective when:</p> <ul> <li>branching depends on data shape, not just values</li> <li>conditions involve relationships between multiple fields</li> <li><code>if</code> / <code>switch</code> logic becomes deeply nested</li> <li>you want expression-oriented control flow</li> </ul> <p>For a deeper dive, see the API Reference and Design Guide.</p>"},{"location":"guide/installation/","title":"Installation","text":"<p>Patternia is a header-only C++ library. There is no build system, no linking step, and no external dependency.</p> <p>You can integrate Patternia into your project in any of the following ways.</p>"},{"location":"guide/installation/#1-recommended-fetch-patternia-automatically","title":"1. Recommended: Fetch Patternia automatically","text":"<p>You may choose to fetch Patternia as a remote dependency during configuration.</p> <p>FetchContent:</p> <pre><code>include(FetchContent)\nFetchContent_Declare(patternia\n  GIT_REPOSITORY https://github.com/sentomk/patternia.git\n  GIT_TAG main\n)\nFetchContent_MakeAvailable(patternia)\n\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>CPM.cmake:</p> <pre><code>CPMAddPackage(\"gh:sentomk/patternia@main\")\n</code></pre> <p>This fits well in reproducible CI pipelines and modern CMake workflows.</p>"},{"location":"guide/installation/#2-install-and-consume-via-find_package","title":"2. Install and consume via <code>find_package()</code>","text":"<p>Patternia provides full CMake package export support.</p> <p>Install:</p> <pre><code>cmake -B build\ncmake --build build\ncmake --install build --prefix /path/to/install\n</code></pre> <p>Use in any project:</p> <pre><code>find_package(patternia REQUIRED)\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>This is the recommended method for system-wide integration, packaging, and distribution.</p>"},{"location":"guide/installation/#3-add-patternia-as-a-git-submodule","title":"3. Add Patternia as a Git submodule","text":"<pre><code>git submodule add https://github.com/sentomk/patternia extern/patternia\n</code></pre> <p>Then in your CMake project:</p> <pre><code>add_subdirectory(extern/patternia)\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>This approach keeps Patternia version-controlled inside your repository and works well for mid- to large-scale projects.</p>"},{"location":"guide/installation/#4-include-the-include-directory-directly","title":"4. Include the <code>include/</code> directory directly","text":"<p>This is the simplest approach. Just add Patternia\u2019s header path to your target:</p> <pre><code>target_include_directories(your_target\n  PRIVATE /path/to/patternia/include\n)\n</code></pre> <p>No configuration, no installation, immediately usable.</p>"},{"location":"tutorials/from-control-flow/","title":"From Control Flow to Pattern Matching","text":""},{"location":"tutorials/from-control-flow/#control-flow-as-it-grows-in-practice","title":"Control Flow as It Grows in Practice","text":"<p>Control flow in C++ is usually learned as a sequence of decisions. You test a condition, you take a branch, and you continue. Over time, this approach becomes second nature: whenever a function needs to \u201cdecide,\u201d an <code>if</code> or a <code>switch</code> appears. The problem is not that these constructs are wrong, but that they silently take on too many responsibilities as code evolves.</p> <p>A simple decision today often becomes a policy tomorrow. Conditions start to overlap. Temporary variables appear only to shuttle values between checks. Eventually, the structure of the logic is no longer visible from the code itself. Pattern matching in Patternia is designed to address this drift by changing how decisions are expressed, without requiring a different language or runtime model.</p>"},{"location":"tutorials/from-control-flow/#simple-decisions-deserve-simple-matching","title":"Simple Decisions Deserve Simple Matching","text":"<p>The first idea to internalize is that not all branching deserves the same level of expressiveness. Patternia reflects this by offering a deliberately simple entry point and a more expressive form, instead of one universal mechanism that tries to do everything.</p> <p>When a decision is purely about which value you have, Patternia expects you to say exactly that\u2014no more, no less. This is the role of <code>match(x, cases())</code>.</p> <pre><code>auto describe(int x) {\n  return match(x, cases(\n    lit(0) &gt;&gt; \"zero\",\n    lit(1) &gt;&gt; \"one\",\n    __     &gt;&gt; \"many\"\n  )).end();\n}\n</code></pre> <p>This form is intentionally constrained. Each case is a direct mapping from a pattern to a result. There is no binding, no guard, and no hidden control flow. The reader can understand the entire decision at a glance. This is not a limitation to be worked around; it is a design boundary. As long as your logic fits naturally into a <code>switch</code>, <code>cases()</code> is where it belongs.</p>"},{"location":"tutorials/from-control-flow/#when-value-dispatch-is-no-longer-enough","title":"When Value Dispatch Is No Longer Enough","text":"<p>The moment that boundary is crossed, imperative code usually starts to stretch. Consider logic that depends not just on a value, but on a property of that value:</p> <pre><code>int bucket(int x) {\n  if (x &lt; 0) return 0;\n  if (x &lt; 10) return 1;\n  if (x &lt; 100) return 2;\n  return 3;\n}\n</code></pre> <p>This is no longer value dispatch. The conditions overlap, and the ordering matters. Trying to force this logic into a value-based case list would hide the intent rather than clarify it. Patternia does not ask you to bend <code>cases()</code> to accommodate this. Instead, it asks you to change how the decision itself is modeled.</p>"},{"location":"tutorials/from-control-flow/#making-data-flow-explicit-with-the-builder-form","title":"Making Data Flow Explicit with the Builder Form","text":"<p>At this point, you move to the builder form, <code>match(x).when(...)</code>, and you make data flow explicit through binding:</p> <pre><code>auto bucket(int x) {\n  return match(x)\n    .when(bind()[_ &lt; 0]   &gt;&gt; 0)\n    .when(bind()[_ &lt; 10]  &gt;&gt; 1)\n    .when(bind()[_ &lt; 100] &gt;&gt; 2)\n    .otherwise(3);\n}\n</code></pre> <p>What matters here is not the syntax, but the semantics. Each case now describes a complete rule: bind the value, require a condition to hold, then produce a result. Guards are not arbitrary filters; they are part of the case definition itself. If a guard fails, the case simply does not exist for that input.</p> <p>This distinction\u2014between selecting a case and refining a case\u2014is fundamental. Guards are not available in <code>cases()</code> precisely because <code>cases()</code> is not about refinement. It is about enumeration. Once you need refinement, Patternia requires you to make that step visible in the structure of the code.</p>"},{"location":"tutorials/from-control-flow/#separating-structure-constraints-and-behavior","title":"Separating Structure, Constraints, and Behavior","text":"<p>The same principle applies when decisions depend on structured data. In imperative code, it is common to see fields accessed and validated inline, often with early returns. Over time, this produces handlers that are half validation and half behavior.</p> <p>Patternia encourages a different organization. Structure is matched first, data is bound explicitly, and semantic constraints are expressed as guards. The handler then operates under the assumption that all prerequisites are satisfied.</p> <pre><code>struct User {\n  int age;\n  bool active;\n};\n\nauto label(const User&amp; u) {\n  return match(u)\n    .when(\n      bind(has&lt;&amp;User::active&gt;())[arg&lt;0&gt; == false] &gt;&gt;\n      \"inactive\"\n    )\n    .when(\n      bind(has&lt;&amp;User::age&gt;())[arg&lt;0&gt; &lt; 18] &gt;&gt;\n      \"minor\"\n    )\n    .otherwise(\"adult\");\n}\n</code></pre> <p>Notice what does not happen in this code. The handler does not inspect fields. It does not re-check conditions. All of that logic lives on the boundary between cases. This is where pattern matching begins to pay off: behavior becomes simpler because eligibility is enforced declaratively.</p>"},{"location":"tutorials/from-control-flow/#fallbacks-as-explicit-design-choices","title":"Fallbacks as Explicit Design Choices","text":"<p>Another important aspect of Patternia\u2019s design is how it treats fallback behavior. In traditional control flow, <code>default</code> branches often serve multiple purposes: they catch errors, handle normal fallthrough, or act as a safety net. Patternia separates these roles.</p> <p>A wildcard pattern (<code>__</code>) is an explicit, ordered case. A match-level fallback (<code>otherwise</code>) is only invoked when no case applies at all. This separation prevents accidental behavior changes when new cases are added and makes the intent of fallback logic explicit.</p>"},{"location":"tutorials/from-control-flow/#binding-and-guards-as-a-discipline-not-a-convenience","title":"Binding and Guards as a Discipline, Not a Convenience","text":"<p>Throughout this progression, one rule remains consistent: binding is always explicit, and guards only exist after binding. You never \u201chalf-bind\u201d a value, and you never attach a guard to a case that does not declare what data it operates on. This makes the relationship between a case and its handler mechanically obvious. The handler\u2019s parameters are not inferred from context; they are earned by binding.</p> <p>This discipline is what allows Patternia code to remain readable even as it grows. Each increase in expressiveness is accompanied by a visible structural change in the code.</p>"},{"location":"tutorials/from-control-flow/#thinking-in-cases-instead-of-branches","title":"Thinking in Cases Instead of Branches","text":"<p>Seen as a whole, Patternia does not replace <code>if</code> or <code>switch</code>. It reframes them. Simple decisions stay simple through <code>match(x, cases())</code>. Rich decisions become structured through <code>.when(...)</code>, <code>bind()</code>, and guards. Instead of growing a single control-flow construct until it collapses under its own weight, you move to a different form when the problem itself changes shape.</p> <p>That shift\u2014from procedural branching to declarative case description\u2014is what \u201cgetting into pattern matching\u201d ultimately means in Patternia. It is not about learning new syntax. It is about learning when to stop asking \u201chow do I check this?\u201d and start stating \u201cthese are the cases that exist.\u201d</p>"},{"location":"tutorials/other-languages/","title":"Pattern Matching in Other Languages","text":""},{"location":"tutorials/other-languages/#a-familiar-idea-revisited-in-c","title":"A Familiar Idea, Revisited in C++","text":"<p>If you have used pattern matching in languages like Rust, Scala, Haskell, or OCaml, you already understand the core promise of the technique. Pattern matching replaces imperative branching with a declarative description of cases. Instead of asking how to test conditions step by step, you state which shapes of data are meaningful and what should happen when those shapes appear.</p> <p>Patternia deliberately builds on this shared intuition. A match expression evaluates cases in order, the first applicable case wins, and handlers operate under the assumption that their input has already been validated by the pattern. In this sense, Patternia behaves exactly as an experienced pattern-matching user would expect.</p> <p>The differences begin to appear not at the conceptual level, but at the boundary between language features and library design.</p>"},{"location":"tutorials/other-languages/#expression-oriented-matching-across-languages","title":"Expression-Oriented Matching Across Languages","text":"<p>In most modern pattern-matching systems, <code>match</code> is an expression. It produces a value rather than merely directing control flow. This is true in Rust:</p> <pre><code>let label = match x {\n    0 =&gt; \"zero\",\n    1 =&gt; \"one\",\n    _ =&gt; \"many\",\n};\n</code></pre> <p>Patternia adopts the same expression-oriented mindset. A match computes a result, and every case participates in producing that result:</p> <pre><code>auto label = match(x, cases(\n  lit(0) &gt;&gt; \"zero\",\n  lit(1) &gt;&gt; \"one\",\n  __     &gt;&gt; \"many\"\n)).end();\n</code></pre> <p>The resemblance is intentional. For readers coming from expression-oriented languages, this form should feel immediately natural. What is different is what Patternia does not allow here. There are no bindings or guards. This mirrors the idea that value-only matching should remain simple and readable, rather than becoming a staging ground for complex logic.</p>"},{"location":"tutorials/other-languages/#when-guards-enter-the-picture","title":"When Guards Enter the Picture","text":"<p>In many languages, guards are written inline with patterns. Rust, for example, allows conditions to be attached directly to a match arm:</p> <pre><code>match x {\n    n if n &gt; 0 &amp;&amp; n &lt; 10 =&gt; \"small\",\n    _ =&gt; \"other\",\n}\n</code></pre> <p>Patternia supports the same expressive power, but deliberately changes how it is introduced. Guards do not appear in the simple <code>cases()</code> form. Instead, the presence of a guard signals a transition to a more expressive matching mode:</p> <pre><code>auto label = match(x)\n  .when(bind()[_ &gt; 0 &amp;&amp; _ &lt; 10] &gt;&gt; \"small\")\n  .otherwise(\"other\");\n</code></pre> <p>This separation is not accidental. In a library-based system, allowing arbitrary predicates everywhere would quickly blur the distinction between pattern matching and ad-hoc filtering. By requiring <code>bind()</code> before a guard can exist, Patternia enforces a clear rule: guards refine bound data; they do not replace matching itself.</p> <p>For readers familiar with other languages, it is useful to think of this as making the \u201cguarded arm\u201d concept structurally explicit rather than syntactically implicit.</p>"},{"location":"tutorials/other-languages/#binding-as-a-visible-contract","title":"Binding as a Visible Contract","text":"<p>One of the most striking differences for experienced users is how binding works. In many pattern-matching languages, variables introduced in patterns appear implicitly:</p> <pre><code>match value {\n    Some(v) =&gt; process(v),\n    None =&gt; {}\n}\n</code></pre> <p>In Patternia, binding is always explicit:</p> <pre><code>match(value)\n  .when(bind() &gt;&gt; [](auto v) { process(v); })\n  .otherwise([] {});\n</code></pre> <p>This is not an arbitrary restriction. In C++, implicit binding would interact poorly with overload resolution, template instantiation, and error diagnostics. By requiring <code>bind()</code>, Patternia makes the data contract between a pattern and its handler explicit and mechanically obvious.</p> <p>Conceptually, this is still the same idea: the handler receives values that were extracted by the match. The difference is that Patternia chooses explicitness over inference, favoring long-term readability and predictability.</p>"},{"location":"tutorials/other-languages/#structural-matching-without-native-destructuring","title":"Structural Matching Without Native Destructuring","text":"<p>Languages with native pattern matching often support destructuring as part of the syntax. Scala, for example, allows deep structural patterns directly in a case:</p> <pre><code>user match {\n  case User(age, true) if age &lt; 18 =&gt; \"minor\"\n  case _ =&gt; \"adult\"\n}\n</code></pre> <p>C++ does not provide a uniform destructuring facility for arbitrary types, so Patternia approaches structure differently. Instead of attempting to mirror language-level destructuring, it allows patterns to describe which parts of a value are relevant and then bind those parts explicitly.</p> <pre><code>auto label = match(user)\n  .when(\n    bind(has&lt;&amp;User::age, &amp;User::active&gt;())\n      [arg&lt;0&gt; &lt; 18 &amp;&amp; arg&lt;1&gt; == true] &gt;&gt;\n    \"minor\"\n  )\n  .otherwise(\"adult\");\n</code></pre> <p>The underlying intent is the same: separate shape from behavior. What changes is the surface syntax, shaped by the realities of C++\u2019s type system rather than by an algebraic data model.</p>"},{"location":"tutorials/other-languages/#exhaustiveness-and-fallbacks","title":"Exhaustiveness and Fallbacks","text":"<p>Many pattern-matching languages emphasize exhaustiveness, often enforced by the compiler. While a library cannot replicate this fully, Patternia still encourages explicit design choices around fallbacks.</p> <p>A wildcard pattern represents an intentional catch-all case, participating in ordering like any other case. A match-level fallback represents the absence of a match entirely. This distinction mirrors the conceptual difference, in other languages, between an explicit wildcard arm and an implicit runtime failure due to a non-exhaustive match.</p> <p>The important point for experienced readers is that fallback behavior is never implicit. If something happens \u201cby default,\u201d it is written as a case or as an explicit fallback.</p>"},{"location":"tutorials/other-languages/#translating-ideas-not-syntax","title":"Translating Ideas, Not Syntax","text":"<p>Patternia is not an attempt to recreate Rust, Scala, or Haskell syntax inside C++. It is an attempt to translate the ideas behind pattern matching into a form that remains idiomatic, predictable, and maintainable in a library setting.</p> <p>If you already understand pattern matching elsewhere, learning Patternia is primarily about learning where boundaries are drawn. Simple matches stay simple. Binding is explicit. Guards refine rather than replace matching. Structure is described, not implicitly unpacked.</p> <p>Once those boundaries are clear, the system should feel less like a foreign abstraction and more like a familiar concept expressed with C++\u2019s own constraints in mind.</p>"},{"location":"tutorials/policy-constraint/","title":"Policy Constraint Matching","text":""},{"location":"tutorials/policy-constraint/#from-ad-hoc-rules-to-declarative-policies","title":"From Ad-Hoc Rules to Declarative Policies","text":"<p>Policy-based decisions are a common source of complexity in real-world systems. Access control, feature gating, pricing rules, and workflow authorization often begin as a handful of conditions, then gradually accumulate exceptions, overrides, and special cases.</p> <p>In traditional C++, this logic is usually expressed as a growing chain of <code>if</code> statements. Each new rule is \u201cinserted\u201d somewhere into the control flow, and the meaning of the code becomes inseparable from its ordering. The logic works, but understanding why a decision was made requires tracing execution step by step.</p> <p>Patternia approaches policy decisions differently. Instead of encoding policy as control flow, it treats each rule as a case defined by structure and constraints. The goal is not to evaluate conditions procedurally, but to describe which policies exist and when they apply.</p>"},{"location":"tutorials/policy-constraint/#defining-the-policy-domain","title":"Defining the Policy Domain","text":"<p>We start by modeling the data involved in the decision. A policy decision typically depends on who is making the request, what is being accessed, and how it is accessed.</p> <pre><code>enum class Role {\n  Guest,\n  User,\n  Admin\n};\n\nstruct Request {\n  Role role;\n  int  resource_id;\n  bool read_only;\n};\n</code></pre> <p>This structure already hints at the nature of the problem. There is no single field that determines the outcome. The decision depends on relationships between fields, which immediately places us outside the realm of value dispatch.</p>"},{"location":"tutorials/policy-constraint/#recognizing-a-constraint-based-match","title":"Recognizing a Constraint-Based Match","text":"<p>Because the outcome cannot be determined by enumerating values, <code>cases()</code> is not the right tool here. What we need is a set of rules, each defined by constraints over the request data. This is exactly the scenario where <code>when(...)</code> and guarded bindings are intended to be used.</p> <pre><code>match(req)\n  .when(/* policy rule */)\n  .when(/* policy rule */)\n  .otherwise(/* default policy */);\n</code></pre> <p>At this level, the match already reads as a policy table rather than as a branching program.</p>"},{"location":"tutorials/policy-constraint/#binding-the-relevant-dimensions-of-a-rule","title":"Binding the Relevant Dimensions of a Rule","text":"<p>Each policy rule depends on a specific subset of the request fields. Instead of passing the entire <code>Request</code> object into every handler, we bind only the data that the rule actually reasons about.</p> <pre><code>bind(has&lt;&amp;Request::role, &amp;Request::resource_id, &amp;Request::read_only&gt;())\n</code></pre> <p>This binding step defines the vocabulary of the rule. Everything that follows\u2014the guard and the handler\u2014will operate strictly in terms of these bound values. The rule does not \u201cpeek\u201d back into the original object.</p>"},{"location":"tutorials/policy-constraint/#expressing-unconditional-policies-declaratively","title":"Expressing Unconditional Policies Declaratively","text":"<p>Some policies are unconditional within their scope. For example, administrators may be allowed to access any resource regardless of mode.</p> <pre><code>.when(\n  bind(has&lt;&amp;Request::role&gt;())\n    [arg&lt;0&gt; == Role::Admin] &gt;&gt;\n  true\n)\n</code></pre> <p>This case reads as a direct statement of policy. There is no procedural logic hidden in the handler. The policy itself is expressed entirely in the pattern and guard.</p>"},{"location":"tutorials/policy-constraint/#combining-multiple-constraints-in-a-single-rule","title":"Combining Multiple Constraints in a Single Rule","text":"<p>More realistic policies involve multiple conditions. Consider a rule that allows regular users to access resources only in read-only mode, and only when the resource identifier is valid.</p> <pre><code>.when(\n  bind(has&lt;&amp;Request::role, &amp;Request::resource_id, &amp;Request::read_only&gt;())\n    [\n      arg&lt;0&gt; == Role::User &amp;&amp;\n      arg&lt;1&gt; &gt;= 0 &amp;&amp;\n      arg&lt;2&gt; == true\n    ] &gt;&gt;\n  true\n)\n</code></pre> <p>This is a multi-value guard, and therefore <code>_</code> does not exist here. Every relationship is spelled out explicitly in terms of bound values. The guard describes why the rule applies; the handler simply enacts the decision.</p>"},{"location":"tutorials/policy-constraint/#introducing-domain-specific-predicates","title":"Introducing Domain-Specific Predicates","text":"<p>Some policy constraints cannot be expressed as simple relational checks. Whether a resource is public, restricted, or archived may depend on external logic or domain knowledge. Attempting to encode this logic directly into expression guards would reduce clarity.</p> <p>Instead, we name the predicate:</p> <pre><code>auto is_public_resource = [](int id) {\n  return id &lt; 1000;\n};\n</code></pre> <p>And then integrate it into the rule:</p> <pre><code>.when(\n  bind(has&lt;&amp;Request::role, &amp;Request::resource_id&gt;())\n    [\n      arg&lt;0&gt; == Role::Guest &amp;&amp;\n      is_public_resource\n    ] &gt;&gt;\n  true\n)\n</code></pre> <p>This mirrors the approach taken in geometric constraints: arithmetic-heavy logic lives in a predicate; simple relational logic remains declarative.</p>"},{"location":"tutorials/policy-constraint/#declaring-the-default-policy-explicitly","title":"Declaring the Default Policy Explicitly","text":"<p>Policy systems must always answer the question \u201cwhat happens if no rule applies?\u201d. Patternia forces this answer to be explicit.</p> <pre><code>.otherwise(false);\n</code></pre> <p>This is not a fallback rule among others; it is a statement of intent. Requests that do not satisfy any declared policy are denied by default.</p>"},{"location":"tutorials/policy-constraint/#reading-policies-as-patterns-not-branches","title":"Reading Policies as Patterns, Not Branches","text":"<p>Putting the rules together yields a complete policy matcher:</p> <pre><code>bool allowed(const Request&amp; req) {\n  return match(req)\n\n    .when(\n      bind(has&lt;&amp;Request::role&gt;())\n        [arg&lt;0&gt; == Role::Admin] &gt;&gt;\n      true\n    )\n\n    .when(\n      bind(has&lt;&amp;Request::role, &amp;Request::resource_id, &amp;Request::read_only&gt;())\n        [\n          arg&lt;0&gt; == Role::User &amp;&amp;\n          arg&lt;1&gt; &gt;= 0 &amp;&amp;\n          arg&lt;2&gt; == true\n        ] &gt;&gt;\n      true\n    )\n\n    .when(\n      bind(has&lt;&amp;Request::role, &amp;Request::resource_id&gt;())\n        [\n          arg&lt;0&gt; == Role::Guest &amp;&amp;\n          is_public_resource\n        ] &gt;&gt;\n      true\n    )\n\n    .otherwise(false);\n}\n</code></pre> <p>Each policy is a self-contained case. The order is visible. The constraints are explicit. The handler code is trivial because all reasoning has already been done.</p>"},{"location":"tutorials/policy-constraint/#policies-as-declarative-constraints","title":"Policies as Declarative Constraints","text":"<p>The important takeaway from this example is not how access control works, but how constraints scale when treated as patterns. Each policy is a description of when it applies, not a fragment of control flow.</p> <p>This mirrors the lesson from geometric constraint matching. Whether the constraint is mathematical or organizational, the structure is the same: bind what matters, declare why the case applies, and keep behavior separate from validation.</p> <p>This is the essence of constraint-based matching in Patternia.</p>"},{"location":"tutorials/predicate-guards/","title":"Custom Predicate Guards","text":""},{"location":"tutorials/predicate-guards/#guards-as-part-of-case-definition","title":"Guards as Part of Case Definition","text":"<p>In Patternia, a guard is not a free-floating condition. It is not an <code>if</code> placed near a handler, nor a generic predicate applied to the input value. A guard belongs to a case, and more specifically, it belongs to a case that has already bound data.</p> <p>This is why guards only appear in the <code>when(...)</code> form, and only after a pattern introduces bindings. A guard refines an already matched and bound case. If the guard fails, the case simply does not apply, and matching continues. Nothing \u201cfalls through,\u201d and nothing partially executes.</p> <p>Understanding this placement is the key to using guards correctly. Once that boundary is clear, the remaining question becomes practical: what kind of logic should live inside a guard?</p>"},{"location":"tutorials/predicate-guards/#using-built-in-guard-expressions-for-simple-logic","title":"Using Built-in Guard Expressions for Simple Logic","text":"<p>Patternia provides a small set of operator overloads designed specifically for guard expressions. These operators allow you to express simple, local constraints directly, without dropping back into lambdas.</p> <p>For a single bound value, this often reads naturally:</p> <pre><code>match(x)\n  .when(bind()[_ &gt; 0 &amp;&amp; _ &lt; 10] &gt;&gt; \"small\")\n  .otherwise(\"other\");\n</code></pre> <p>Here, <code>_</code> is not a runtime variable. It is a placeholder used to construct a predicate over the bound value. The expression <code>_ &gt; 0 &amp;&amp; _ &lt; 10</code> does not evaluate immediately; it builds a guard that will be evaluated after binding.</p> <p>This style is intended for simple, relational constraints: comparisons, ranges, and boolean combinations. The goal is clarity, not expressiveness at all costs. If the condition can be read as a short sentence about the value, it likely belongs in this form.</p> <p>Logical composition using <code>&amp;&amp;</code> and <code>||</code> is fully supported and is often sufficient for straightforward rules:</p> <pre><code>.when(bind()[_ == 0 || _ == 1] &gt;&gt; \"edge\")\n</code></pre> <p>As long as the logic remains local and obvious, keeping it in expression form improves readability by keeping the rule close to the case definition.</p>"},{"location":"tutorials/predicate-guards/#multi-value-guards-and-explicit-relationships","title":"Multi-Value Guards and Explicit Relationships","text":"<p>When a pattern binds multiple values, guards can express relationships between them. In this situation, the placeholder <code>_</code> is no longer sufficient, because there is more than one bound value. Patternia makes this explicit by requiring indexed access via <code>arg&lt;N&gt;</code>.</p> <pre><code>.when(\n  bind(has&lt;&amp;Point::x, &amp;Point::y&gt;())\n    [arg&lt;0&gt; == arg&lt;1&gt;] &gt;&gt;\n  \"diagonal\"\n)\n</code></pre> <p>Here, <code>arg&lt;0&gt;</code> and <code>arg&lt;1&gt;</code> refer to the first and second bound values, in binding order. This makes the dependency between values explicit and avoids ambiguity. The guard describes a relationship between bindings, not an opaque condition over the original object.</p> <p>As with single-value guards, logical operators can be used to combine constraints, but the same rule applies: if the condition reads cleanly as a declarative relationship, it fits well in this form.</p>"},{"location":"tutorials/predicate-guards/#knowing-when-to-stop-using-expression-guards","title":"Knowing When to Stop Using Expression Guards","text":"<p>Not all logic belongs in an expression-based guard. Patternia deliberately does not try to turn guards into a full embedded language. Once a condition becomes algorithmic, stateful, or domain-specific, expression syntax stops helping.</p> <p>Consider a check such as \u201cis this number prime?\u201d or \u201cdoes this payload satisfy protocol invariants?\u201d Attempting to encode such logic through operator overloads would obscure intent rather than clarify it.</p> <p>In these cases, the correct approach is to step back into ordinary C++ and use a lambda:</p> <pre><code>auto is_prime = [](int v) {\n  if (v &lt; 2) return false;\n  for (int i = 2; i * i &lt;= v; ++i)\n    if (v % i == 0) return false;\n  return true;\n};\n\nmatch(x)\n  .when(bind()[is_prime] &gt;&gt; \"prime\")\n  .otherwise(\"composite\");\n</code></pre> <p>This is not a fallback or a workaround; it is the intended design. Guards are predicates. When a predicate is complex, it should look like a predicate, written in normal C++.</p> <p>The lambda form keeps complex logic readable, testable, and reusable, without forcing it into an artificial DSL.</p>"},{"location":"tutorials/predicate-guards/#combining-expression-guards-and-lambdas","title":"Combining Expression Guards and Lambdas","text":"<p>Expression guards and lambda guards are not mutually exclusive. They can be mixed naturally, as long as the rule remains clear.</p> <pre><code>auto valid_id = [](int v) {\n  return v % 7 == 0;\n};\n\nmatch(x)\n  .when(bind()[_ &gt; 0 &amp;&amp; valid_id] &gt;&gt; \"valid\")\n  .otherwise(\"invalid\");\n</code></pre> <p>In this example, the simple relational constraint (<code>_ &gt; 0</code>) stays in expression form, while the domain-specific rule (<code>valid_id</code>) is expressed as a lambda. The guard reads as a composition of two ideas, each expressed in its most natural form.</p> <p>This composition works because guards are predicates, not control flow. Whether a predicate comes from an expression or a callable does not change how the case behaves.</p>"},{"location":"tutorials/predicate-guards/#guard-logic-belongs-at-the-boundary","title":"Guard Logic Belongs at the Boundary","text":"<p>A recurring theme in Patternia is that validation belongs at the boundary, not inside the handler. Guards exist to enforce that rule. A handler should assume its preconditions are satisfied and focus solely on behavior.</p> <p>If you find yourself writing defensive checks inside a handler, it is often a sign that the logic belongs in a guard instead. Conversely, if a guard starts to resemble a small program, it likely belongs in a lambda or outside the match entirely.</p> <p>Patternia does not attempt to blur this line. It gives you just enough syntax to express common constraints declaratively, and then relies on standard C++ for everything else.</p>"},{"location":"tutorials/predicate-guards/#writing-guards-with-intent","title":"Writing Guards with Intent","text":"<p>Effective guard usage is less about knowing every operator and more about restraint. Use the built-in expression operators for small, obvious constraints. Use <code>&amp;&amp;</code> and <code>||</code> to combine them when the relationship remains readable. When logic becomes complex, name it and write it as a lambda.</p> <p>By following this discipline, guards remain what they are meant to be: precise refinements of cases, not miniature control-flow systems hidden inside brackets.</p> <p>This is the role of custom predicate guards in Patternia\u2014not to replace C++, but to clarify where conditions belong.</p>"},{"location":"tutorials/sphere-constraint/","title":"Geometric Constraint Matching","text":""},{"location":"tutorials/sphere-constraint/#from-numeric-conditions-to-declarative-shape-constraints","title":"From Numeric Conditions to Declarative Shape Constraints","text":"<p>Geometric constraints are a good stress test for any control-flow abstraction. They are simple to state mathematically, yet often awkward to express clearly in code. A classic example is the unit sphere: a point lies inside the sphere if and only if <code>x\u00b2 + y\u00b2 + z\u00b2 &lt; 1</code>.</p> <p>In traditional C++, this condition is usually written as a boolean expression embedded directly inside an <code>if</code> statement. The code is compact, but the intent tends to blur once additional decisions are layered on top.</p> <pre><code>bool inside_unit_sphere(const Vec3&amp; p) {\n  return p.x * p.x + p.y * p.y + p.z * p.z &lt; 1.0;\n}\n</code></pre> <p>Patternia approaches the same problem from a different angle. Instead of asking \u201cis this condition true?\u201d, it asks \u201cdoes this value belong to a case defined by this constraint?\u201d. That shift becomes more visible as the example grows.</p>"},{"location":"tutorials/sphere-constraint/#choosing-the-subject-of-the-match","title":"Choosing the Subject of the Match","text":"<p>The subject of the decision is the point itself:</p> <pre><code>struct Vec3 {\n  double x;\n  double y;\n  double z;\n};\n</code></pre> <p>There is no finite set of values to enumerate, so this is not a <code>cases()</code> problem. We are dealing with constraints, not value dispatch, which means we move directly to the <code>when(...)</code> form.</p>"},{"location":"tutorials/sphere-constraint/#binding-structure-before-reasoning-about-constraints","title":"Binding Structure Before Reasoning About Constraints","text":"<p>The geometric constraint depends on the coordinates of the point. Rather than accessing those fields inside a handler, Patternia encourages binding them explicitly as part of the case definition.</p> <pre><code>match(p)\n  .when(\n    bind(has&lt;&amp;Vec3::x, &amp;Vec3::y, &amp;Vec3::z&gt;())\n      /* guard */\n      &gt;&gt;\n    /* handler */\n  )\n  .otherwise(/* fallback */);\n</code></pre> <p>At this stage, nothing has been \u201cchecked\u201d yet. The code simply states that this case is about points for which <code>x</code>, <code>y</code>, and <code>z</code> are relevant. Binding defines what data the case operates on before any constraint is applied.</p>"},{"location":"tutorials/sphere-constraint/#writing-the-constraint-as-a-predicate","title":"Writing the Constraint as a Predicate","text":"<p>The constraint <code>x\u00b2 + y\u00b2 + z\u00b2 &lt; 1</code> is not a simple relational check. It involves arithmetic across multiple values. This is exactly the point where Patternia expects you to step out of expression-based guards and write a predicate.</p> <pre><code>auto inside_unit_sphere = [](double x, double y, double z) {\n  return x * x + y * y + z * z &lt; 1.0;\n};\n</code></pre> <p>This predicate is ordinary C++. It can be tested independently and reused elsewhere. Patternia does not attempt to encode this kind of logic into operator overloads, because doing so would obscure intent rather than clarify it.</p>"},{"location":"tutorials/sphere-constraint/#attaching-a-multi-value-guard-correctly","title":"Attaching a Multi-Value Guard Correctly","text":"<p>With multiple bound values, the guard operates over all bindings at once. In this context, it is important to be precise:</p> <p>There is no <code>_</code> in multi-value guards.</p> <p>The placeholder <code>_</code> exists only for single-value bindings. Once a pattern binds more than one value, guards must refer to bound values explicitly\u2014either via <code>arg&lt;N&gt;</code> or by using a callable that consumes all bound values.</p> <p>In this case, the lambda form is the most natural:</p> <pre><code>auto classify(const Vec3&amp; p) {\n  return match(p)\n    .when(\n      bind(has&lt;&amp;Vec3::x, &amp;Vec3::y, &amp;Vec3::z&gt;())\n        [inside_unit_sphere] &gt;&gt;\n      \"inside\"\n    )\n    .otherwise(\"outside\");\n}\n</code></pre> <p>The guard is evaluated only after binding succeeds. If the predicate returns false, the case does not apply and matching continues. The handler itself contains no geometric logic; it simply represents the outcome of a satisfied constraint.</p>"},{"location":"tutorials/sphere-constraint/#adding-additional-constraints-without-confusing-semantics","title":"Adding Additional Constraints Without Confusing Semantics","text":"<p>Suppose we want to refine the rule: the point must be inside the unit sphere and lie in the upper half-space (<code>z \u2265 0</code>). This introduces a simple relational constraint alongside the existing geometric one.</p> <p>Because this is a multi-value guard, <code>_</code> is still not available. We must express the additional constraint explicitly in terms of bound values.</p> <p>One option is to extend the predicate:</p> <pre><code>auto inside_upper_unit_sphere = [](double x, double y, double z) {\n  return z &gt;= 0 &amp;&amp; x * x + y * y + z * z &lt; 1.0;\n};\n</code></pre> <p>Another option is to combine predicates using <code>arg&lt;N&gt;</code> for the simple part:</p> <pre><code>auto classify(const Vec3&amp; p) {\n  return match(p)\n    .when(\n      bind(has&lt;&amp;Vec3::x, &amp;Vec3::y, &amp;Vec3::z&gt;())\n        [arg&lt;2&gt; &gt;= 0 &amp;&amp; inside_unit_sphere] &gt;&gt;\n      \"inside\"\n    )\n    .otherwise(\"outside\");\n}\n</code></pre> <p>Here, <code>arg&lt;2&gt;</code> refers to the third bound value (<code>z</code>), following binding order. The guard reads as a clear composition: a simple relational check combined with a domain-specific predicate.</p> <p>The important rule remains intact: multi-value guards are explicit. Nothing is implicit, and no placeholder stands in for \u201cthe value\u201d when there are multiple values involved.</p>"},{"location":"tutorials/sphere-constraint/#why-this-structure-matters","title":"Why This Structure Matters","text":"<p>At this point, the benefit over a raw <code>if</code> statement becomes clear. The match expression does not merely compute a boolean; it describes a case defined by a geometric constraint. Binding declares which data the case depends on. The guard declares why the case applies. The handler declares what happens when it does.</p> <p>As constraints grow\u2014more dimensions, more regions, more classifications\u2014the match grows by adding or refining cases, not by nesting conditionals. This is the same scaling property that makes pattern matching attractive in other languages, applied here to geometric reasoning.</p>"},{"location":"tutorials/sphere-constraint/#constraints-as-patterns-not-conditions","title":"Constraints as Patterns, Not Conditions","text":"<p>The lesson of this example is not how to encode <code>x\u00b2 + y\u00b2 + z\u00b2 &lt; 1</code>. It is how to recognize constraints as patterns. Once a constraint is treated as a case boundary rather than an inline check, it becomes composable, testable, and readable.</p> <p>Patternia\u2019s rules around guards\u2014especially the strict separation between single-value placeholders and multi-value bindings\u2014exist to preserve that clarity. They prevent ambiguity and make the structure of a decision visible in the code itself.</p> <p>This is the purpose of worked examples in Patternia: to show how simple rules, applied consistently, scale to real problems without collapsing back into ad-hoc control flow.</p>"}]}