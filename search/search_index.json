{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Patternia Documentation","text":"<p>A modern C++ pattern matching DSL</p> <p>Patternia is a modern C++ pattern-matching DSL designed to make dispatch logic clear, expressive, and type-safe \u2014 without sacrificing performance or compilation efficiency.</p>"},{"location":"#navigation","title":"Navigation","text":""},{"location":"#quick-start","title":"Quick Start","text":"<ul> <li>Installation - How to integrate Patternia into your project</li> <li>Getting Started - Complete examples from basics to advanced</li> </ul>"},{"location":"#pattern-system","title":"Pattern System","text":"<ul> <li>Pattern System Overview - Understand Patternia's design philosophy</li> <li>Value Patterns - Value matching with literals, case-insensitive strings, predicates</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>API Documentation - Complete API reference for all functions and patterns</li> </ul>"},{"location":"#project-information","title":"Project Information","text":"<ul> <li>Roadmap - Future development directions and plans</li> <li>Releases - Version update history</li> </ul>"},{"location":"#core-features","title":"Core Features","text":"<ul> <li>Header-only: Zero dependencies, plug-and-play</li> <li>Declarative Syntax: <code>match().when().otherwise()</code> chaining</li> <li>Type Safety: Compile-time guarantees, zero runtime overhead</li> <li>Rich Patterns: Literal patterns, case-insensitive patterns, predicate patterns</li> <li>DSL Operators: <code>&gt;&gt;</code> for pattern-handler binding</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>#include &lt;ptn/patternia.hpp&gt;\nusing namespace ptn;\n\nint x = 42;\n\nauto result =\n    match(x)\n      .when(lit(0) &gt;&gt; \"zero\")\n      .when(lit(42) &gt;&gt; \"answer\")\n      .otherwise(\"other\");\n</code></pre> <p>Patternia evaluates patterns in order and returns the result associated with the first successful match.</p>"},{"location":"#where-to-start","title":"Where to Start","text":"<p>If you're new to Patternia, we recommend reading in this order:</p> <ol> <li>Installation - Integrate into your project</li> <li>Getting Started - Learn basic usage</li> <li>Value Patterns - Deep dive into value matching patterns</li> </ol> <p>If you're looking for specific information:</p> <ul> <li>Need a function reference? \u2192 API Documentation</li> <li>Want to understand design philosophy? \u2192 Pattern System Overview</li> <li>Check version updates? \u2192 Releases</li> </ul>"},{"location":"#system-requirements","title":"System Requirements","text":"<ul> <li>C++ Standard: C++17 or later</li> <li>Compilers: GCC \u226511, Clang \u226512, MSVC \u22652019</li> <li>Platforms: Linux, Windows, macOS</li> </ul> Make logical structure explicit, make C++ code more elegant"},{"location":"api/","title":"Patternia API Reference","text":""},{"location":"api/#namespace-structure-overview","title":"Namespace Structure Overview","text":"<p>Patternia adopts a layered namespace design, primarily containing the following namespaces:</p> <pre><code>ptn/                                    // Root namespace\n\u251c\u2500\u2500 core/                              // Core matching engine\n\u2502   \u251c\u2500\u2500 engine/                        // Matching engine implementation\n\u2502   \u251c\u2500\u2500 dsl/                          // DSL operators\n\u2502   \u2514\u2500\u2500 common/                       // Common utilities and traits\n\u251c\u2500\u2500 pat/                              // Pattern definitions\n\u2502   \u251c\u2500\u2500 base/                         // Pattern base classes\n\u2502   \u251c\u2500\u2500 lit.hpp                        // Literal pattern implementation\n\u2502   \u2514\u2500\u2500 bind.hpp                       // Binding pattern implementation\n\u2514\u2500\u2500 meta/                             // Meta programming tools\n    \u251c\u2500\u2500 base/                         // Base traits\n    \u251c\u2500\u2500 dsa/                          // Data structures and algorithms\n    \u2514\u2500\u2500 query/                        // Query utilities\n</code></pre>"},{"location":"api/#main-namespace-aliases","title":"Main Namespace Aliases","text":"<p>For user convenience, Patternia provides all pattern functions directly in the <code>ptn</code> namespace:</p> <pre><code>namespace ptn {\n  // lit, lit_ci, bind are available directly\n}\n</code></pre>"},{"location":"api/#core-matching-engine-api","title":"Core Matching Engine API","text":""},{"location":"api/#main-entry-functions","title":"Main Entry Functions","text":""},{"location":"api/#ptnmatchvalue","title":"<code>ptn::match(value)</code>","text":"<p>Type-deduced matching entry point that automatically deduces the value type.</p> <pre><code>template &lt;typename T&gt;\nconstexpr auto match(T &amp;&amp;value);\n</code></pre> <p>Parameters: - <code>value</code> - Value to match (forwarding reference)</p> <p>Returns: <code>match_builder</code> object for chained calls to <code>.when()</code> and <code>.otherwise()</code></p> <p>Example: <pre><code>int x = 42;\nauto result = match(x)\n    .when(lit(42) &gt;&gt; \"answer\")\n    .otherwise(\"other\");\n</code></pre></p>"},{"location":"api/#ptnmatchuvalue","title":"<code>ptn::match&lt;U&gt;(value)</code>","text":"<p>Explicit type-specified matching entry point that forces conversion to target type.</p> <pre><code>template &lt;typename U, typename T&gt;\nconstexpr auto match(T &amp;&amp;value);\n</code></pre> <p>Parameters: - <code>U</code> - Target type - <code>value</code> - Value to match</p> <p>Constraints: Type U must be constructible from value</p> <p>Example: <pre><code>double d = 3.14;\nauto result = match&lt;int&gt;(d)  // Force convert to int\n    .when(lit(3) &gt;&gt; \"three\")\n    .otherwise(\"other\");\n</code></pre></p>"},{"location":"api/#match-builder-api","title":"Match Builder API","text":""},{"location":"api/#match_builderwhenpattern-handler","title":"<code>match_builder::when(pattern &gt;&gt; handler)</code>","text":"<p>Add a matching branch.</p> <p>Syntax: <pre><code>.when(pattern &gt;&gt; handler)\n</code></pre></p> <p>Parameters: - <code>pattern</code> - Any pattern object - <code>handler</code> - Handler function or value</p> <p>Returns: New <code>match_builder</code> object (supports chained calls)</p> <p>Important Notes: - The builder does NOT execute matching until terminated with <code>.end()</code> or <code>.otherwise()</code> - Unterminated builders are inert and produce no side effects</p>"},{"location":"api/#match_builderotherwisehandler","title":"<code>match_builder::otherwise(handler)</code>","text":"<p>Add a default branch with explicit fallback handler.</p> <p>Syntax: <pre><code>.otherwise(handler)\n</code></pre></p> <p>Parameters: - <code>handler</code> - Default handler function or value</p> <p>Returns: Match result (type determined by handler)</p> <p>Use Cases: - When you need a default value or behavior - When handlers return non-void types - When you want explicit control over the fallback case</p> <p>When Triggered: The <code>.otherwise()</code> handler determines the final return value of the match expression:</p> <ol> <li>No Pattern Matches: When none of the <code>.when()</code> cases match the subject</li> <li>Defensive Fallback: When <code>__</code> can match all pattern forms, <code>.otherwise()</code> serves only as defensive fallback and typically won't trigger</li> </ol> <p>Key Distinction: - Pattern-level fallback (<code>__</code>): Only affects case matching process at pattern level - Match-level fallback (<code>.otherwise()</code>): Determines final return value of match expression - When <code>__</code> can match all pattern forms: <code>.otherwise()</code> serves only as defensive fallback</p> <p>Execution Priority: - Cases are evaluated in order - First matching pattern wins, regardless of fallback types - <code>.otherwise()</code> is only reached if no previous patterns match</p> <p>Example: <pre><code>auto result = match(42)\n    .when(lit(1) &gt;&gt; \"one\")      // \u274c No match\n    .when(lit(2) &gt;&gt; \"two\")      // \u274c No match\n    .when(__ &gt;&gt; \"other\")           // \u2705 PATTERN MATCHES: Returns \"other\"\n    .otherwise(\"default\");         // \u274c NOT triggered: Pattern already matched\n</code></pre></p>"},{"location":"api/#match_builderend","title":"<code>match_builder::end()</code>","text":"<p>Terminate the match expression for void-only matches.</p> <p>Syntax: <pre><code>.end()\n</code></pre></p> <p>Returns: <code>void</code> (no return value)</p> <p>Constraints: - All case handlers must return void - No explicit otherwise handler is provided - Used for exhaustive pattern matching where all cases are covered</p> <p>Use Cases: - When all possible cases are explicitly handled - When you want the compiler to verify exhaustiveness - For void-returning match expressions - When you don't need a default fallback</p>"},{"location":"api/#terminal-methods-comparison","title":"Terminal Methods Comparison","text":"Method Return Type When to Use Handler Required <code>.otherwise(handler)</code> Handler return type Need default behavior or non-void returns Yes <code>.end()</code> <code>void</code> Exhaustive matching with void returns No (implicit empty handler) <p>Key Differences:</p> <ol> <li>Return Type Control</li> <li><code>.otherwise()</code>: Handler determines return type</li> <li> <p><code>.end()</code>: Always returns <code>void</code></p> </li> <li> <p>Exhaustiveness Checking</p> </li> <li><code>.otherwise()</code>: Always safe, provides fallback</li> <li> <p><code>.end()</code>: Compiler enforces that all cases must return void</p> </li> <li> <p>Handler Requirements</p> </li> <li><code>.otherwise()</code>: Must provide explicit handler</li> <li> <p><code>.end()</code>: No handler needed (uses empty lambda internally)</p> </li> <li> <p>Use Case Intent</p> </li> <li><code>.otherwise()</code>: \"Handle everything else with this behavior\"</li> <li><code>.end()</code>: \"I've covered all cases explicitly\"</li> </ol>"},{"location":"api/#value-pattern-api","title":"Value Pattern API","text":"<p>Note</p> <p><code>ptn::pat::lit</code>, <code>ptn::pat::lit_ci</code>, and <code>ptn::pat::bind</code> are available directly in <code>ptn</code> namespace</p>"},{"location":"api/#literal-patterns","title":"Literal Patterns","text":""},{"location":"api/#ptnlitvalue","title":"<code>ptn::lit(value)</code>","text":"<p>Create exact match pattern.</p> <pre><code>template &lt;typename V&gt;\nconstexpr auto lit(V &amp;&amp;v);\n</code></pre> <p>Purpose: Create a pattern that exactly matches the given value</p> <p>Supported Types: - Arithmetic types (int, double, float, etc.) - Enum types - Strings (std::string, std::string_view, const char*) - User-defined types (must support operator==)</p> <p>Examples: <pre><code>// Integer matching\nmatch(42).when(lit(42) &gt;&gt; \"answer\");\n\n// String matching\nmatch(\"hello\").when(lit(\"hello\") &gt;&gt; \"greeting\");\n\n// Enum matching\nenum class Color { Red, Green, Blue };\nColor c = Color::Red;\nmatch(c).when(lit(Color::Red) &gt;&gt; \"red\");\n</code></pre></p>"},{"location":"api/#ptnlit_civalue","title":"<code>ptn::lit_ci(value)</code>","text":"<p>Create case-insensitive string matching pattern.</p> <pre><code>template &lt;typename V&gt;\nconstexpr auto lit_ci(V &amp;&amp;v);\n</code></pre> <p>Purpose: Create a case-insensitive string matching pattern (ASCII only)</p> <p>Example: <pre><code>std::string s = \"HELLO\";\nmatch(s).when(lit_ci(\"hello\") &gt;&gt; \"case-insensitive-match\");\n</code></pre></p>"},{"location":"api/#wildcard-pattern","title":"Wildcard Pattern","text":""},{"location":"api/#ptn__-wildcard","title":"<code>ptn::__</code> (Wildcard)","text":"<p>Create a pattern that matches any value without binding.</p> <pre><code>inline constexpr detail::wildcard_t __;\n</code></pre> <p>Purpose: Create a pattern that always matches regardless of the value, but doesn't capture/bind any data</p> <p>Returns: <code>wildcard_t</code> pattern that always matches and binds nothing</p> <p>Examples: <pre><code>// Default/fallback matching\nmatch(42)\n    .when(lit(0) &gt;&gt; \"zero\")\n    .when(__ &gt;&gt; \"non-zero\");  // Matches any other value\n\n// As the last case in exhaustive matching\nmatch(value)\n    .when(lit(\"success\") &gt;&gt; \"ok\")\n    .when(lit(\"error\") &gt;&gt; \"fail\")\n    .when(__ &gt;&gt; \"unknown\");  // Catch-all case\n</code></pre></p> <p>Key Characteristics: - Always matches (<code>match()</code> returns true for any input) - Binds no values (<code>bind()</code> returns empty tuple <code>std::tuple&lt;&gt;</code>) - Useful for default cases and catch-all patterns - More explicit than using <code>bind()</code> when no capture is needed</p>"},{"location":"api/#binding-patterns","title":"Binding Patterns","text":""},{"location":"api/#ptnbind","title":"<code>ptn::bind()</code>","text":"<p>Create a pattern that captures the entire subject value.</p> <pre><code>constexpr auto bind();\n</code></pre> <p>Purpose: Create a pattern that always matches and captures the subject as a tuple</p> <p>Returns: <code>binding_pattern</code> that binds the subject value</p> <p>Examples: <pre><code>// Capture any value\nmatch(42).when(bind() &gt;&gt; [](int v) { \n    return \"captured: \" + std::to_string(v);\n});\n\n// Fallback capture\nenum Status { Pending, Running };\nmatch(Status::Running)\n    .when(lit(Status::Pending) &gt;&gt; \"pending\")\n    .when(bind() &gt;&gt; [](int v) { return \"status: \" + std::to_string(v); });\n</code></pre></p>"},{"location":"api/#ptnbindsubpattern","title":"<code>ptn::bind(subpattern)</code>","text":"<p>Create a pattern that first matches with subpattern, then captures the subject.</p> <pre><code>template &lt;typename SubPattern&gt;\nconstexpr auto bind(SubPattern &amp;&amp;subpattern);\n</code></pre> <p>Purpose: Create a pattern that combines subpattern matching with subject capturing</p> <p>Parameters: - <code>subpattern</code> - Pattern to use for matching</p> <p>Returns: <code>binding_as_pattern</code> that binds both subject and subpattern bindings</p> <p>Examples: <pre><code>// Capture after matching specific value\nenum Status { Pending, Running, Completed };\nmatch(Status::Running)\n    .when(bind(lit(Status::Running)) &gt;&gt; [](int whole) {\n        std::cout &lt;&lt; \"Captured enum value: \" &lt;&lt; whole &lt;&lt; \"\\n\";\n        return \"running\";\n    });\n\n// Capture with string matching\nstd::string cmd = \"START\";\nmatch(cmd)\n    .when(bind(lit_ci(\"start\")) &gt;&gt; [](std::string command) {\n        return \"processing: \" + command;\n    });\n</code></pre></p> <p>Binding Behavior: - <code>bind()</code> alone binds the subject as <code>std::tuple&lt;Subject&gt;</code> - <code>bind(subpattern)</code> binds <code>std::tuple&lt;Subject, SubPatternBindings...&gt;</code> - Handler functions receive the bound values as parameters</p>"},{"location":"api/#dsl-operators-api","title":"DSL Operators API","text":""},{"location":"api/#pattern-handler-binding-operators","title":"Pattern-Handler Binding Operators","text":""},{"location":"api/#pattern-handler-pattern-binding","title":"<code>pattern &gt;&gt; handler</code> - Pattern binding","text":"<p>Bind a pattern with a handler function or value.</p> <p>Two modes:</p> <ol> <li> <p>Value handler mode: <pre><code>pattern &gt;&gt; value\n</code></pre>    Automatically creates a handler that returns a fixed value</p> </li> <li> <p>Function handler mode: <pre><code>pattern &gt;&gt; function\n</code></pre>    Directly uses the provided function as the handler</p> </li> </ol> <p>Examples: <pre><code>// Value handler\nmatch(42).when(lit(42) &gt;&gt; \"answer\");  // Returns string \"answer\"\n\n// Function handler\nmatch(42).when(lit(42) &gt;&gt; []{ \n    return \"answer\";\n});  // Returns string \"answer\"\n\n// Capturing handler with bind()\nmatch(42).when(bind() &gt;&gt; [](int value) { \n    return \"captured: \" + std::to_string(value);\n});\n\n// Capturing handler with subpattern\nenum Status { Running };\nmatch(Status::Running)\n    .when(bind(lit(Status::Running)) &gt;&gt; [](int whole) {\n        return \"status: \" + std::to_string(whole);\n    });\n</code></pre></p>"},{"location":"api/#binding-system-api","title":"Binding System API","text":""},{"location":"api/#binding-traits","title":"Binding Traits","text":"<p>Patternia uses a type trait system to determine what values each pattern binds.</p>"},{"location":"api/#binding_argspattern-subject","title":"<code>binding_args&lt;Pattern, Subject&gt;</code>","text":"<p>Trait that defines the binding result type for a pattern-subject pair.</p> <pre><code>template &lt;typename Pattern, typename Subject&gt;\nstruct binding_args {\n    using type = std::tuple&lt;&gt;; // default implementation\n};\n</code></pre> <p>Specializations: - <code>binding_args&lt;binding_pattern, Subject&gt;</code> \u2192 <code>std::tuple&lt;Subject&gt;</code> - <code>binding_args&lt;binding_as_pattern&lt;Tag, SubPattern&gt;, Subject&gt;</code> \u2192 concatenated tuple</p>"},{"location":"api/#binding_args_tpattern-subject","title":"<code>binding_args_t&lt;Pattern, Subject&gt;</code>","text":"<p>Convenience alias for binding arguments type.</p> <pre><code>template &lt;typename Pattern, typename Subject&gt;\nusing binding_args_t = typename binding_args&lt;Pattern, Subject&gt;::type;\n</code></pre>"},{"location":"api/#api-feature-summary","title":"API Feature Summary","text":""},{"location":"api/#type-safety","title":"Type Safety","text":"<ul> <li>All pattern matching is compile-time type safe</li> <li>Support for heterogeneous comparisons (comparisons between different types)</li> <li>Automatic type deduction and explicit type specification</li> <li>Strong typing for binding values</li> </ul>"},{"location":"api/#performance-optimization","title":"Performance Optimization","text":"<ul> <li>Zero runtime overhead abstractions</li> <li>Compile-time pattern combination optimization</li> <li>Support for constant expression evaluation</li> <li>No RTTI or virtual dispatch</li> </ul>"},{"location":"api/#extensibility","title":"Extensibility","text":"<ul> <li>CRTP-based pattern base classes</li> <li>Easy to add custom pattern types</li> <li>Support for custom comparators and predicates</li> <li>Modular binding trait system</li> </ul>"},{"location":"api/#expressiveness","title":"Expressiveness","text":"<ul> <li>Rich built-in pattern types (literal, binding, case-insensitive)</li> <li>Intuitive DSL syntax with <code>&gt;&gt;</code> operator</li> <li>Support for complex pattern combinations</li> <li>Value capturing and binding capabilities</li> </ul>"},{"location":"api/#compatibility","title":"Compatibility","text":"<ul> <li>Support for C++17 and C++20</li> <li>Modular header file design</li> <li>Configurable feature switches</li> <li>Header-only integration</li> </ul>"},{"location":"api/#future-features-and-roadmap","title":"Future Features and Roadmap","text":""},{"location":"api/#exhaustiveness-checking-planned","title":"Exhaustiveness Checking (Planned)","text":"<p>Patternia plans to introduce compile-time exhaustiveness checking to provide enhanced safety guarantees:</p> <p>What is Exhaustiveness Checking? A compile-time verification that all possible values of a type are covered by the match expression, similar to Rust's pattern matching guarantees.</p> <p>Planned Features: - Enum Exhaustiveness: Detect when enum variants are not fully covered - Literal Exhaustiveness: Warn when specific literal values are missing - Wildcard Coverage: Proper handling of wildcard (<code>__</code>) patterns in exhaustiveness analysis - Compile-time Errors: Static assertions that prevent non-exhaustive matches when required</p> <p>Example (Future API): <pre><code>enum class Status { Pending, Running, Completed, Failed };\n\n// This will trigger a compile-time error for missing variants\nmatch(status)\n    .when(lit(Status::Running) &gt;&gt; \"running\")\n    .when(lit(Status::Completed) &gt;&gt; \"completed\")\n    .end();  // ERROR: Not all enum variants covered!\n\n// Fixed version - exhaustive matching\nmatch(status)\n    .when(lit(Status::Pending) &gt;&gt; \"pending\")\n    .when(lit(Status::Running) &gt;&gt; \"running\") \n    .when(lit(Status::Completed) &gt;&gt; \"completed\")\n    .when(lit(Status::Failed) &gt;&gt; \"failed\")\n    .end();  // OK: All cases covered\n</code></pre></p> <p>Implementation Timeline: - Phase 1: Basic enum exhaustiveness detection - Phase 2: Integration with type system and improved error messages - Phase 3: Advanced pattern analysis (wildcard handling, complex patterns)</p> <p>This feature will make Patternia even safer by catching missing cases at compile-time, reducing runtime errors and improving code reliability.</p> <p>This complete API reference covers all public interfaces of the Patternia library, including internal and external APIs, and provides comprehensive example code. You can use this documentation to write GitHub Pages documentation and README files.</p>"},{"location":"design-overview/","title":"Patternia Matching Semantics Overview","text":"<p>(<code>__</code>, <code>.end()</code>, <code>.otherwise()</code> and Destructuring Patterns)</p>"},{"location":"design-overview/#0-core-objectives","title":"0. Core Objectives","text":"<p>Patternia's DSL is designed to satisfy three key principles:</p> <ol> <li>Semantic Clarity:</li> <li>Clear separation between \"pattern-level\" and \"match-level\" responsibilities.</li> <li>Predictable Behavior:</li> <li>Consistent with Rust and the C++ standard proposal P1371R1 <code>inspect</code> mechanism in spirit.</li> <li>User-Friendly:</li> <li>Minimal API coverage for both \"statement-style matching\" and \"expression-style matching\" requirements.</li> </ol> <p>Around these three principles, the entire system can be abstracted into three levels:</p> <ol> <li>Pattern Level: <code>lit(...)</code>, <code>type::is&lt;T&gt;</code>, destructuring, <code>bind(...)</code>, <code>__</code>, etc.</li> <li>Case Level: <code>.when(pattern &gt;&gt; handler)</code>.</li> <li>Match Finalizer Level: <code>.end()</code> / <code>.otherwise(...)</code>.</li> </ol> <p>All discussions below revolve around these three levels.</p>"},{"location":"design-overview/#1-formal-definitions-of-core-concepts","title":"1. Formal Definitions of Core Concepts","text":""},{"location":"design-overview/#11-__-wildcard-pattern","title":"1.1 <code>__</code> (Wildcard Pattern)","text":"<ul> <li><code>__</code> is a pattern used to match \"any value\".</li> <li>It exists only at the Pattern Level and does not control the entire match lifecycle.</li> <li> <p>It plays different roles in different contexts:</p> </li> <li> <p>In literal matching: Serves as a \"fallback case\".</p> </li> <li>In enum/variant-like matching: Serves as a \"fallback for remaining constructors\".</li> <li>In struct destructuring:     Used for \"field-level ignoring\", similar to Rust's <code>_</code> / <code>..</code>.</li> </ul>"},{"location":"design-overview/#12-end-statement-style-match-finalizer","title":"1.2 <code>.end()</code> (Statement-style Match Finalizer)","text":"<ul> <li> <p><code>.end()</code> transforms the builder into statement-style matching:</p> </li> <li> <p>The entire <code>match(...)</code> expression does not return a value.</p> </li> <li>Used only for side effects (printing, logging, state modification, etc.).</li> <li> <p>Corresponds to the statement form in the standard proposal's <code>inspect</code>:</p> </li> <li> <p><code>pattern: statement;</code></p> </li> <li> <p>Constraints:</p> </li> <li> <p>All case handlers must return <code>void</code>.</p> </li> <li> <p>For exhaustible types (enum, bool, variant-like), future exhaustiveness checking will be performed:</p> <ul> <li>Compile-time diagnostics when not all enum values or alternatives are covered.</li> </ul> </li> </ul>"},{"location":"design-overview/#13-otherwise-expression-style-match-finalizer","title":"1.3 <code>.otherwise(...)</code> (Expression-style Match Finalizer)","text":"<ul> <li> <p><code>.otherwise(fallback)</code> transforms the builder into expression-style matching:</p> </li> <li> <p>The entire <code>match(...)</code> has a unified return value.</p> </li> <li>Similar to Rust's <code>let r = match x { ... };</code></li> <li> <p>Corresponds to the expression form in the standard proposal's <code>inspect</code>:</p> </li> <li> <p><code>pattern =&gt; expression,</code></p> </li> <li> <p>Constraints:</p> </li> <li> <p>All <code>.when(pattern &gt;&gt; handler)</code> handlers must return non-void and be type-unifiable.</p> </li> <li> <p><code>.otherwise(...)</code> provides the final fallback value:</p> <ul> <li>Used when no branches match.</li> <li><code>.otherwise(...)</code> terminates the builder and determines the return type.</li> </ul> </li> </ul>"},{"location":"design-overview/#2-semantic-levels-pattern-vs-match-finalizer","title":"2. Semantic Levels: Pattern vs Match Finalizer","text":"<p>Always remember:</p> <p><code>__</code> is a Pattern-level object; <code>.end()</code> and <code>.otherwise()</code> are Match Finalizer-level objects.</p> <p>They solve completely different problems:</p> Role Level Problem Solved <code>__</code> Pattern Level How current case matches \"any/remaining forms\" <code>.end()</code> Match Level Entire match \"executed as statement\" with no return <code>.otherwise</code> Match Level Entire match \"as expression\" with final return value <p>Therefore:</p> <ul> <li><code>__</code> cannot replace <code>.otherwise()</code>:   It doesn't terminate the builder, nor determine return type.</li> <li><code>.otherwise()</code> cannot replace <code>__</code>:   It cannot express \"fallback for remaining constructors/fields in pattern tree\".</li> </ul>"},{"location":"design-overview/#3-end-vs-otherwise-two-modes","title":"3. <code>.end()</code> vs <code>.otherwise()</code>: Two Modes","text":""},{"location":"design-overview/#31-end-statement-style-matching","title":"3.1 <code>.end()</code> \u2014 Statement-style Matching","text":"<p>Use Cases:</p> <ul> <li>Only care about side effects, no return value needed.</li> <li>Want exhaustiveness checking for enum/variant-like types.</li> </ul> <p>Semantic Characteristics:</p> <ul> <li>All handlers must return <code>void</code>.</li> <li>Return type is <code>void</code>.</li> <li>Exhaustible types will be checked for \"complete coverage\".</li> </ul> <p>Example (enum):</p> <pre><code>enum class Status { Pending, Running, Failed };\n\nmatch(status)\n    .when(lit(Status::Pending) &gt;&gt; [] { log(\"Pending\"); })\n    .when(lit(Status::Running) &gt;&gt; [] { log(\"Running\"); })\n    .when(__ &gt;&gt; [] { log(\"Other\"); })  // pattern-level fallback\n    .end();                            // match finalizer, no return value\n</code></pre> <p>Rust Analogy:</p> <pre><code>match status {\n    Status::Pending =&gt; log(\"Pending\"),\n    Status::Running =&gt; log(\"Running\"),\n    _               =&gt; log(\"Other\"),\n};\n</code></pre>"},{"location":"design-overview/#32-otherwise-expression-style-matching","title":"3.2 <code>.otherwise(...)</code> \u2014 Expression-style Matching","text":"<p>Use Cases:</p> <ul> <li>Need to compute a value from match:</li> <li>Generate labels for enum/variant;</li> <li>Calculate results, map strings, etc.</li> </ul> <p>Semantic Characteristics:</p> <ul> <li>All handlers return the same type (or commonly convertible).</li> <li><code>.otherwise(fallback)</code> provides the final value.</li> <li>The entire <code>match(...)</code> expression has a concrete type.</li> </ul> <p>Example (Rust counterpart):</p> <pre><code>int x = 2;\n\nauto res = match(x)\n    .when(lit(1) &gt;&gt; \"one\")\n    .when(lit(2) &gt;&gt; \"two\")\n    .otherwise(\"Other\");\n\nstd::cout &lt;&lt; res;\n</code></pre> <p>Corresponding Rust:</p> <pre><code>let x = 2;\nlet res = match x {\n    1 =&gt; \"one\",\n    2 =&gt; \"two\",\n    _ =&gt; \"Other\",\n};\nprintln!(\"{}\", res);\n</code></pre>"},{"location":"design-overview/#4-__-roles-in-different-scenarios","title":"4. <code>__</code> Roles in Different Scenarios","text":""},{"location":"design-overview/#41-as-case-fallback-wildcard","title":"4.1 As \"Case Fallback\" Wildcard","text":"<p>Simplest literal scenario:</p> <pre><code>auto res = match(x)\n    .when(lit(1) &gt;&gt; \"one\")\n    .when(lit(2) &gt;&gt; \"two\")\n    .when(__ &gt;&gt; \"other\")    // __ is pattern-level fallback here\n    .otherwise(\"panic\");    // match-level fallback (defensive, usually never triggered)\n</code></pre> <ul> <li><code>__ &gt;&gt; \"other\"</code>: Represents \"all other values\".</li> <li><code>.otherwise(\"panic\")</code>: Ideally never used, but can serve as defensive fallback.</li> </ul>"},{"location":"design-overview/#42-remaining-branch-in-enumvariant-like-matching","title":"4.2 Remaining Branch in Enum/Variant-like Matching","text":"<p>For variant-like types (including future kind/alternative patterns):</p> <pre><code>auto info = match(v)\n    .when(type::is&lt;int&gt;         &gt;&gt; \"int\")\n    .when(type::is&lt;std::string&gt; &gt;&gt; \"string\")\n    .when(__                     &gt;&gt; \"other-kind\")\n    .otherwise(\"panic\"); // match-level defense, ideally never triggered\n</code></pre> <p>Here:</p> <ul> <li><code>__</code> represents \"all alternatives except int and string\".</li> <li><code>.otherwise(\"panic\")</code> is the final match-level defense.</li> </ul>"},{"location":"design-overview/#43-field-wildcard-in-struct-destructuring","title":"4.3 Field Wildcard in Struct Destructuring","text":"<p>Corresponding Rust:</p> <pre><code>match p {\n    Point { x, .. } =&gt; println!(\"{}\", x),\n}\n</code></pre> <p>Patternia ideal DSL example:</p> <pre><code>struct Point { int x, y, z; };\n\nmatch(p)\n    .when(Point{ bind(x), __, __ } &gt;&gt; [&amp;] {\n        std::cout &lt;&lt; x;\n    })\n    .end();\n</code></pre> <p>Meaning:</p> <ul> <li>Matches object of type <code>Point</code>.</li> <li>Only binds first field <code>x</code>.</li> <li>Other fields (<code>y</code>, <code>z</code>) are ignored with <code>__</code>.</li> </ul> <p><code>__</code> here is field-level wildcard, not a fallback case. Future named field versions could also be extended:</p> <pre><code>.when(Point{ .x = bind(x), .y = __, .z = __ } &gt;&gt; ...)\n</code></pre>"},{"location":"design-overview/#5-when-do-__-and-otherwise-appear-together","title":"5. When Do <code>__</code> and <code>.otherwise()</code> \"Appear Together\"?","text":""},{"location":"design-overview/#51-typical-scenario-expression-match-pattern-fallback-match-fallback","title":"5.1 Typical Scenario: Expression Match + Pattern Fallback + Match Fallback","text":"<p>In complex modes:</p> <ul> <li>Pattern level might already use <code>__</code> for fallback matching all forms;</li> <li>But you can still set <code>.otherwise(...)</code> at match level as \"defensive branch that should never trigger\".</li> </ul> <p>Example:</p> <pre><code>auto label = match(v)\n    .when(type::is&lt;int&gt;         &gt;&gt; \"int\")\n    .when(type::is&lt;std::string&gt; &gt;&gt; \"string\")\n    .when(__                     &gt;&gt; \"other-kind\") // pattern-level fallback\n    .otherwise(\"unreachable\");                    // match-level defense\n</code></pre> <p>Here <code>.otherwise(\"unreachable\")</code> should ideally never trigger in normal logic, but:</p> <ul> <li>Can be used for debug/assertions;</li> <li>Semantically completely valid in the DSL.</li> </ul>"},{"location":"design-overview/#52-expression-matches-must-use-otherwise","title":"5.2 Expression Matches Must Use <code>.otherwise()</code>","text":"<p>Whenever you write:</p> <pre><code>auto res = match(subject)\n    .when(...)\n    ...\n</code></pre> <p>And want to assign the result to <code>res</code>, then expression-style matches must be terminated with <code>.otherwise(...)</code>. Even if the pattern level is already covered by <code>__</code>.</p> <p>The reason is:</p> <ul> <li>Builder needs a finalizer to determine \"this is an expression-style match\";</li> <li>C++ needs a clear return type, and <code>.otherwise(...)</code> is exactly this entry point.</li> </ul>"},{"location":"design-overview/#53-when-does-match-level-fallback-trigger","title":"5.3 When Does Match-level Fallback Trigger?","text":"<p>The <code>.otherwise(handler)</code> is triggered in two scenarios:</p>"},{"location":"design-overview/#scenario-1-no-pattern-matches","title":"Scenario 1: No Pattern Matches","text":"<p>When none of the <code>.when()</code> cases match the subject value:</p> <pre><code>auto result = match(42)\n    .when(lit(1) &gt;&gt; \"one\")      // \u274c No match\n    .when(lit(2) &gt;&gt; \"two\")      // \u274c No match  \n    .when(__ &gt;&gt; \"other\")           // \u274c No match (if no wildcard case for this specific scenario)\n    .otherwise(\"default\");         // \u2705 TRIGGERED: Returns \"default\"\n</code></pre>"},{"location":"design-overview/#scenario-2-explicit-match-level-defense","title":"Scenario 2: Explicit Match-level Defense","text":"<p>Even when patterns (including <code>__</code>) could theoretically match everything, <code>.otherwise()</code> still serves as a defensive fallback:</p> <pre><code>auto result = match(42)\n    .when(lit(1) &gt;&gt; \"one\")      // \u274c No match\n    .when(lit(2) &gt;&gt; \"two\")      // \u274c No match\n    .when(__ &gt;&gt; \"other\")           // \u2705 PATTERN MATCHES: Returns \"other\"\n    .otherwise(\"unreachable\");      // \u274c NOT TRIGGERED: Pattern already matched\n</code></pre> <p>Key Principles:</p> <ol> <li>Pattern Priority: Cases are evaluated in order. The first matching pattern wins.</li> <li>Wildcard Coverage: <code>__</code> matches any value, so if placed before <code>.otherwise()</code>, it will typically match first.</li> <li>Defensive Purpose: <code>.otherwise()</code> as \"unreachable\" provides runtime safety for logic errors or unexpected inputs.</li> </ol>"},{"location":"design-overview/#practical-example-with-pattern-vs-match-fallback","title":"Practical Example with Pattern vs Match Fallback:","text":"<pre><code>// This demonstrates the execution order\nauto classify = std::string input;\n\nauto result = match(classify)\n    .when(lit_ci(\"error\") &gt;&gt; \"ERROR\")           // Case 1: Specific match\n    .when(lit_ci(\"warning\") &gt;&gt; \"WARNING\")       // Case 2: Specific match  \n    .when(__ &gt;&gt; \"UNKNOWN\")                      // Case 3: Pattern fallback\n    .otherwise(\"INVALID INPUT\");                 // Case 4: Match-level fallback (unlikely to trigger)\n\n// For input \"INFO\":\n// - Cases 1,2: No match\n// - Case 3 (__): Matches \u2192 Returns \"UNKNOWN\"  \n// - Case 4 (.otherwise): NOT triggered\n\n// For input null/empty string (if it reaches match):\n// - Cases 1,2,3: All could potentially handle this\n// - Depending on implementation, might reach .otherwise() as defense\n</code></pre> <p>Summary: - Pattern-level fallback (<code>__</code>): Only affects case matching process at pattern level - Match-level fallback (<code>.otherwise()</code>): Determines final return value of match expression - When <code>__</code> can match all pattern forms: <code>.otherwise()</code> serves only as defensive fallback and typically won't trigger</p>"},{"location":"design-overview/#6-when-to-use-end-when-to-use-otherwise","title":"6. When to Use <code>.end()</code>, When to Use <code>.otherwise()</code>?","text":"<p>Use this decision table to directly guide user usage.</p>"},{"location":"design-overview/#61-decision-table","title":"6.1 Decision Table","text":"Requirement Recommended Usage Only execute side effects, no match return value Use <code>.end()</code> Need to get a value from match (like Rust) Use <code>.otherwise(...)</code> Want exhaustiveness checking for enum/variant Use <code>.end()</code> Express \"all remaining matching forms\" Use <code>__</code> in pattern Express \"entire match fallback return value\" Use <code>.otherwise(...)</code>"},{"location":"design-overview/#62-typical-patterns","title":"6.2 Typical Patterns","text":"<ol> <li>Statement-style with fallback:</li> </ol> <pre><code>match(s)\n    .when(lit(Status::Pending) &gt;&gt; [] { ... })\n    .when(lit(Status::Running) &gt;&gt; [] { ... })\n    .when(__ &gt;&gt; [] { ... }) // fallback\n    .end();\n</code></pre> <ol> <li>Expression-style, Rust counterpart:</li> </ol> <pre><code>auto res = match(x)\n    .when(lit(1) &gt;&gt; \"one\")\n    .when(lit(2) &gt;&gt; \"two\")\n    .otherwise(\"Other\");\n</code></pre> <ol> <li>Struct destructuring + field wildcard:</li> </ol> <pre><code>match(p)\n    .when(Point{ bind(x), __, __ } &gt;&gt; [&amp;] { return x; })\n    .otherwise(0);\n</code></pre> <ol> <li>Variant-like + type matching + pattern fallback:</li> </ol> <pre><code>auto info = match(v)\n    .when(type::is&lt;int&gt;         &gt;&gt; \"int\")\n    .when(type::is&lt;std::string&gt; &gt;&gt; \"string\")\n    .when(__                     &gt;&gt; \"other-kind\")\n    .otherwise(\"panic\");\n</code></pre>"},{"location":"design-overview/#7-implementation-details","title":"7. Implementation Details","text":""},{"location":"design-overview/#71-builder-execution-flow","title":"7.1 Builder Execution Flow","text":"<p>The builder pattern ensures that matches are only executed when properly terminated:</p> <pre><code>// Without .end() or .otherwise():\nmatch(value).when(lit(42) &gt;&gt; [] { /* handler */ });\n// Result: Nothing is executed - builder remains unterminated\n\n// With .end():\nmatch(value).when(lit(42) &gt;&gt; [] { /* handler */ }).end();\n// Result: match_impl::eval(subject_, cases_, std::move(dummy_fallback));\n\n// With .otherwise():\nmatch(value).when(lit(42) &gt;&gt; [] { /* handler */ }).otherwise(fallback);\n// Result: match_impl::eval(subject_, cases_, std::move(final_handler));\n</code></pre> <p>Key Points:</p> <ul> <li>Without <code>.end()</code> or <code>.otherwise()</code>, the builder never triggers execution.</li> <li><code>.end()</code> creates an empty fallback handler for statement-style execution.</li> <li><code>.otherwise()</code> uses the provided handler as the final fallback for expression-style execution.</li> </ul>"},{"location":"design-overview/#72-type-safety-guarantees","title":"7.2 Type Safety Guarantees","text":"<ul> <li>Statement-style (<code>.end()</code>): All handlers must return <code>void</code></li> <li>Expression-style (<code>.otherwise()</code>): All handlers must return compatible types</li> <li>Pattern matching: Type-safe heterogeneous comparisons</li> <li>Binding: Compile-time type deduction for bound values</li> </ul>"},{"location":"design-overview/#8-future-roadmap","title":"8. Future Roadmap","text":"<p>To make these semantics truly user-friendly, Patternia's future plans include:</p> <ol> <li>Exhaustiveness Checking for <code>.end()</code>:</li> <li>Enum/bool: Static checking for complete enum value coverage.</li> <li>Variant-like: Check for complete alternative coverage.</li> <li> <p>Provide \"missing case\" and \"useless case\" hints.</p> </li> <li> <p>Formal Struct Destructuring DSL:</p> </li> <li>Positional: <code>Point{ bind(x), __, __ }</code></li> <li>Named: <code>Point{ .x = bind(x), .y = __, .z = __ }</code></li> <li> <p>Support guard/bind/nested patterns.</p> </li> <li> <p>Improved Error Messages:</p> </li> <li>Non-void handler under <code>.end()</code> \u2192 Clear error.</li> <li>Handler return type inconsistency under <code>.otherwise()</code> \u2192 Clear type diagnostics.</li> <li>Wildcard + <code>.otherwise()</code> redundancy \u2192 Hint \"potentially redundant patterns\".</li> </ol> <p>This comprehensive design ensures that Patternia provides clear, predictable, and user-friendly pattern matching semantics while maintaining type safety and performance guarantees.</p>"},{"location":"changelog/releases/","title":"Patternia Releases","text":"<ul> <li>v0.5.2 - December 10, 2025</li> </ul>"},{"location":"changelog/v0.5.2/","title":"Patternia v0.5.2 Release Notes","text":"<p>Release Date: December 10, 2025  Version: 0.5.2</p>"},{"location":"changelog/v0.5.2/#overview","title":"\ud83c\udfaf Overview","text":"<p>Patternia v0.5.2 introduces the wildcard pattern <code>__</code> and provides comprehensive documentation updates. This release focuses on semantic clarity, improved developer experience, and establishing a solid foundation for future exhaustiveness checking features.</p>"},{"location":"changelog/v0.5.2/#new-features","title":"\u2728 New Features","text":""},{"location":"changelog/v0.5.2/#wildcard-pattern-__","title":"Wildcard Pattern (<code>__</code>)","text":"<p>Added: <code>ptn::__</code> - A pattern that matches any value without binding.</p> <pre><code>// Basic wildcard usage\nmatch(value)\n    .when(lit(0) &gt;&gt; \"zero\")\n    .when(__ &gt;&gt; \"other\")  // Matches any other value\n    .end();\n</code></pre> <p>Key Characteristics: - Always matches regardless of input value - Binds no data (returns empty tuple <code>std::tuple&lt;&gt;</code>) - More explicit than <code>bind()</code> when no capture is needed - Essential for catch-all cases and future struct destructuring</p>"},{"location":"changelog/v0.5.2/#enhanced-terminal-method-semantics","title":"Enhanced Terminal Method Semantics","text":"<p>Improved: Clear distinction between <code>.end()</code> and <code>.otherwise()</code> terminal methods.</p>"},{"location":"changelog/v0.5.2/#end-statement-style-matching","title":"<code>.end()</code> - Statement-style Matching","text":"<ul> <li>For void-returning matches</li> <li>Designed for exhaustiveness checking (future feature)</li> <li>Used when only side effects are needed</li> </ul>"},{"location":"changelog/v0.5.2/#otherwisehandler-expression-style-matching","title":"<code>.otherwise(handler)</code> - Expression-style Matching","text":"<ul> <li>For value-returning matches</li> <li>Provides explicit fallback behavior</li> <li>Used when computing results from matches</li> </ul>"},{"location":"changelog/v0.5.2/#fallback-trigger-mechanism-clarification","title":"Fallback Trigger Mechanism Clarification","text":"<p>Added: Detailed explanation of when <code>.otherwise()</code> is triggered:</p> <ol> <li>No Pattern Matches: When no <code>.when()</code> cases match the subject</li> <li>Defensive Fallback: Even with pattern coverage, provides runtime safety</li> </ol> <p>Key Principle: First matching pattern wins, regardless of fallback types.</p>"},{"location":"changelog/v0.5.2/#documentation-improvements","title":"\ud83d\udcda Documentation Improvements","text":""},{"location":"changelog/v0.5.2/#design-overview-document","title":"Design Overview Document","text":"<p>Added: <code>docs/design-overview.md</code> - Comprehensive guide covering: - Three-level architecture (Pattern \u2192 Case \u2192 Match Finalizer) - Semantic differences between <code>__</code>, <code>.end()</code>, and <code>.otherwise()</code> - Usage scenarios and best practices - Implementation details and execution flow - Future roadmap for exhaustiveness checking</p>"},{"location":"changelog/v0.5.2/#enhanced-api-reference","title":"Enhanced API Reference","text":"<p>Updated: <code>docs/api.md</code> with: - Complete wildcard pattern documentation - Detailed comparison of terminal methods - Implementation notes about builder execution - Future features section with exhaustiveness checking roadmap</p>"},{"location":"changelog/v0.5.2/#improved-user-guide","title":"Improved User Guide","text":"<p>Updated: <code>README.md</code> featuring: - Wildcard pattern examples - Clear terminal method guidance - Future roadmap section - Better usage decision tables</p>"},{"location":"changelog/v0.5.2/#internal-improvements","title":"\ud83d\udd27 Internal Improvements","text":""},{"location":"changelog/v0.5.2/#comment-standardization","title":"Comment Standardization","text":"<p>Fixed: Consistent English comment style across all modified files: - <code>include/ptn/pattern/wildcard.hpp</code> - Added comprehensive file header - <code>include/ptn/core/engine/detail/builder_impl.hpp</code> - Completed member variable documentation - <code>include/ptn/core/common/common_traits.hpp</code> - Enhanced type trait comments - <code>samples/test.cpp</code> - Added explanatory comments and examples</p>"},{"location":"changelog/v0.5.2/#builder-implementation-enhancements","title":"Builder Implementation Enhancements","text":"<p>Improved: Better documentation in <code>match_builder</code> implementation: - Clear explanation of builder execution flow - Documented member variable purposes - Enhanced inline comments for complex template logic</p>"},{"location":"changelog/v0.5.2/#architecture-changes","title":"\ud83c\udfd7\ufe0f Architecture Changes","text":""},{"location":"changelog/v0.5.2/#three-level-design-formalization","title":"Three-Level Design Formalization","text":"<p>Patternia now explicitly follows a three-level architecture:</p> <ol> <li>Pattern Level: <code>lit()</code>, <code>bind()</code>, <code>__</code>, etc.</li> <li>Case Level: <code>.when(pattern &gt;&gt; handler)</code></li> <li>Match Finalizer Level: <code>.end()</code> / <code>.otherwise()</code></li> </ol> <p>This design ensures: - Clear separation of concerns - Predictable behavior matching Rust/standard proposals - Extensible foundation for future features</p>"},{"location":"changelog/v0.5.2/#semantic-clarity-improvements","title":"Semantic Clarity Improvements","text":"<p>Established: Clear distinctions between: - Pattern-level wildcards (<code>__</code>) vs match-level fallbacks (<code>.otherwise()</code>) - Statement-style (<code>.end()</code>) vs expression-style (<code>.otherwise()</code>) matching - Field-level ignoring vs case-level fallbacks</p>"},{"location":"changelog/v0.5.2/#usage-examples","title":"\ud83d\ude80 Usage Examples","text":""},{"location":"changelog/v0.5.2/#basic-pattern-matching","title":"Basic Pattern Matching","text":"<pre><code>#include &lt;ptn/patternia.hpp&gt;\n\n// Expression-style match\nauto result = match(value)\n    .when(lit(1) &gt;&gt; \"one\")\n    .when(lit(2) &gt;&gt; \"two\") \n    .when(__ &gt;&gt; \"other\")  // Wildcard fallback\n    .otherwise(\"default\");  // Match-level fallback\n</code></pre>"},{"location":"changelog/v0.5.2/#statement-style-matching","title":"Statement-style Matching","text":"<pre><code>// Statement-style match with exhaustiveness (future)\nmatch(status)\n    .when(lit(Status::Pending) &gt;&gt; [] { log(\"pending\"); })\n    .when(lit(Status::Running) &gt;&gt; [] { log(\"running\"); })\n    .when(__ &gt;&gt; [] { log(\"other\"); })  // Pattern fallback\n    .end();  // Statement termination\n</code></pre>"},{"location":"changelog/v0.5.2/#enum-with-wildcard","title":"Enum with Wildcard","text":"<pre><code>enum class Color { Red, Green, Blue };\nColor c = Color::Green;\n\nmatch(c)\n    .when(lit(Color::Red) &gt;&gt; [] { std::cout &lt;&lt; \"red\"; })\n    .when(lit(Color::Green) &gt;&gt; [] { std::cout &lt;&lt; \"green\"; })\n    .when(__ &gt;&gt; [] { std::cout &lt;&lt; \"other\"; })  // Catch-all\n    .end();\n</code></pre>"},{"location":"changelog/v0.5.2/#future-foundation","title":"\ud83d\udd2e Future Foundation","text":"<p>This release establishes the groundwork for v0.6.0 features:</p>"},{"location":"changelog/v0.5.2/#planned-for-v060","title":"Planned for v0.6.0","text":"<ul> <li>Enum Exhaustiveness Checking for <code>.end()</code> usage</li> <li>Struct Destructuring DSL with field wildcards</li> <li>Enhanced Error Messages for better developer experience</li> <li>Type Pattern Matching (<code>type::is&lt;T&gt;</code>)</li> </ul>"},{"location":"changelog/v0.5.2/#implementation-timeline","title":"Implementation Timeline","text":"<ul> <li>Phase 1 (v0.6.0): Basic enum exhaustiveness</li> <li>Phase 2 (v0.7.0): Struct destructuring support  </li> <li>Phase 3 (v0.8.0): Advanced pattern analysis</li> </ul>"},{"location":"changelog/v0.5.2/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":""},{"location":"changelog/v0.5.2/#api-clarity","title":"API Clarity","text":"<p>Fixed: Ambiguous terminal method behavior - Clear distinction between <code>.end()</code> and <code>.otherwise()</code>  - Better examples showing appropriate use cases</p>"},{"location":"changelog/v0.5.2/#installation","title":"\ud83d\udce6 Installation","text":"<p>No changes required - Patternia remains header-only with C++17+ compatibility.</p> <pre><code>FetchContent_Declare(\n    patternia\n    GIT_REPOSITORY https://github.com/SentoMK/patternia.git\n    GIT_TAG v0.5.2\n)\n</code></pre>"},{"location":"changelog/v0.5.2/#acknowledgments","title":"\ud83d\ude4f Acknowledgments","text":"<p>Special thanks to the community for feedback on semantic clarity and documentation needs. This release incorporates extensive user experience improvements based on real-world usage patterns.</p>"},{"location":"changelog/v0.5.2/#migration-guide","title":"\ud83d\udccb Migration Guide","text":""},{"location":"changelog/v0.5.2/#from-v051-to-v052","title":"From v0.5.1 to v0.5.2","text":"<p>No breaking changes - This is a feature-enhancement release.</p>"},{"location":"changelog/v0.5.2/#recommended-practices","title":"Recommended Practices","text":"<ol> <li>Use <code>__</code> instead of <code>bind()</code> when no capture is needed</li> <li>Prefer <code>.end()</code> for statement-style matches with future exhaustiveness</li> <li>Use <code>.otherwise()</code> when computing values from matches</li> <li>Consult <code>docs/design-overview.md</code> for detailed semantic guidance</li> </ol> <p>Total Changes: 12 files modified, 847 lines added, 23 lines removed Documentation Pages: 3 new/updated comprehensive guides API Enhancements: 1 new pattern, 2 clarified terminal methods</p> <p>This release continues Patternia's commitment to providing zero-overhead, expressive pattern matching for modern C++ while establishing a solid foundation for future advanced features.</p>"},{"location":"guide/getting-started/","title":"Getting Started","text":"<p>Patternia is a header-only library. Once installed or fetched into your project, you can start using pattern matching immediately.</p> <p>Below is minimal working example demonstrating the core DSL:</p>"},{"location":"guide/getting-started/#optional-recommended-code-style","title":"Optional: Recommended Code Style","text":"<p>To keep your chained <code>.when()</code> and <code>.otherwise()</code> expressions visually aligned and easy to scan, you can add a minimal <code>.clang-format</code> to your project root:</p> <pre><code># patternia .clang-format (minimal)\nBasedOnStyle: LLVM\nIndentWidth: 2            # or 4\nContinuationIndentWidth: 4 # or 6\nColumnLimit: 0\nBinPackArguments: false\nBinPackParameters: false\nBreakBeforeBinaryOperators: None\n</code></pre> <p>With this style, multi-line match expressions remain clean and consistent:</p> <pre><code>auto out =\n    match(5)\n      .when(lit(0) &gt;&gt; \"zero\")\n      .when(lit(5) &gt;&gt; \"five\")\n      .otherwise(\"other\");\n</code></pre>"},{"location":"guide/getting-started/#basic-example","title":"Basic Example","text":"<pre><code>#include &lt;ptn/patternia.hpp&gt;\n#include &lt;iostream&gt;\nusing namespace ptn;\n\nint main() {\n  int x = 42;\n\n  auto result =\n    match(x)\n      .when(lit(0)       &gt;&gt; \"zero\")\n      .when(lit(42)      &gt;&gt; \"answer to everything\")\n      .otherwise(\"other\");\n\n  std::cout &lt;&lt; result &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>answer to everything\n</code></pre>"},{"location":"guide/getting-started/#case-insensitive-matching","title":"Case-insensitive matching","text":"<pre><code>std::string s = \"Ok\";\n\nauto out = match(s)\n  .when(lit_ci(\"OK\") &gt;&gt; \"accepted\")\n  .otherwise(\"rejected\");\n</code></pre>"},{"location":"guide/getting-started/#no-macros-no-reflection-no-magic","title":"No macros. No reflection. No magic","text":"<p>Patternia compiles down to normal C++ control flow using inlined pattern objects. There is no runtime overhead beyond executing the selected handler.</p>"},{"location":"guide/installation/","title":"Installation","text":"<p>Patternia is a header-only C++ library. There is no build system, no linking step, and no external dependency.</p> <p>You can integrate Patternia into your project in any of the following ways.</p>"},{"location":"guide/installation/#1-recommended-fetch-patternia-automatically","title":"1. Recommended: Fetch Patternia automatically","text":"<p>You may choose to fetch Patternia as a remote dependency during configuration.</p> <p>FetchContent:</p> <pre><code>include(FetchContent)\nFetchContent_Declare(patternia\n  GIT_REPOSITORY https://github.com/sentomk/patternia.git\n  GIT_TAG main\n)\nFetchContent_MakeAvailable(patternia)\n\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>CPM.cmake:</p> <pre><code>CPMAddPackage(\"gh:sentomk/patternia@main\")\n</code></pre> <p>This fits well in reproducible CI pipelines and modern CMake workflows.</p>"},{"location":"guide/installation/#2-install-and-consume-via-find_package","title":"2. Install and consume via <code>find_package()</code>","text":"<p>Patternia provides full CMake package export support.</p> <p>Install:</p> <pre><code>cmake -B build\ncmake --build build\ncmake --install build --prefix /path/to/install\n</code></pre> <p>Use in any project:</p> <pre><code>find_package(patternia REQUIRED)\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>This is the recommended method for system-wide integration, packaging, and distribution.</p>"},{"location":"guide/installation/#3-add-patternia-as-a-git-submodule","title":"3. Add Patternia as a Git submodule","text":"<pre><code>git submodule add https://github.com/sentomk/patternia extern/patternia\n</code></pre> <p>Then in your CMake project:</p> <pre><code>add_subdirectory(extern/patternia)\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>This approach keeps Patternia version-controlled inside your repository and works well for mid- to large-scale projects.</p>"},{"location":"guide/installation/#4-include-the-include-directory-directly","title":"4. Include the <code>include/</code> directory directly","text":"<p>This is the simplest approach. Just add Patternia\u2019s header path to your target:</p> <pre><code>target_include_directories(your_target\n  PRIVATE /path/to/patternia/include\n)\n</code></pre> <p>No configuration, no installation, immediately usable.</p>"},{"location":"patterns/foreword/","title":"Pattern System Architecture","text":"<p>Patternia is built around a single architectural idea: matching should be a first-class, composable, zero-overhead operation in C++.</p> <p>Most C++ projects rely heavily on hand-written branching logic\u2014nested <code>if</code> statements, large <code>switch</code> blocks, duplicated comparisons, and one-off helper functions. These mechanisms are powerful but structurally limited:</p> <ul> <li>Logic becomes scattered across functions.  </li> <li>Conditions cannot be abstracted or composed easily.  </li> <li>Type-dependent paths require RTTI or explicit <code>dynamic_cast</code>.  </li> <li>Value-dependent paths become deeply imperative and repetitive.  </li> <li>Maintenance requires editing many disconnected branches.</li> </ul> <p>Patternia introduces a dedicated Pattern System to unify these forms of branching under a single semantic model.</p> <p>At its core, a Pattern is an object that describes a condition, and the system determines how to evaluate that condition safely and efficiently. All patterns\u2014whether they describe a value, a predicate, or a type\u2014share the same conceptual role:</p> <ol> <li> <p>Describe a match rule.    A pattern encapsulates the logic for deciding whether a subject satisfies a condition.</p> </li> <li> <p>Compose into larger rules.    Patterns form an algebra: they can be combined into richer logic without changing control flow.</p> </li> <li> <p>Participate in the matching pipeline.    The system evaluates patterns in sequence and invokes handlers for the first matching rule.</p> </li> </ol> <p>The Pattern System is not an auxiliary feature. It is the architectural foundation on which the entire library\u2014value dispatch, type dispatch, and later variant dispatch\u2014is built.</p> <p>This chapter examines the architectural model of the Pattern System and clarifies how different pattern categories cooperate to define matching behavior. The discussion begins with value patterns and type patterns as foundational components.</p> <ul> <li>Value Patterns </li> <li>Type Patterns</li> </ul> <p>Their APIs appear elsewhere; here we focus on their design purpose, abstraction model, and role within the match pipeline.</p>"},{"location":"patterns/type/","title":"Type Patterns \u2014 Architectural Perspective","text":"<p>Type Patterns define the part of the Pattern System dedicated to type-level dispatch. They describe conditions about what a value is, rather than how it behaves or what its runtime value contains.</p> <p>They solve a central architectural problem in C++ codebases:</p> <p>How do we express type-dependent logic without RTTI, virtual inheritance, or manual <code>if constexpr</code> chains?</p> <p>Type Patterns provide a unified answer.</p>"},{"location":"patterns/type/#1-type-level-semantics-as-first-class-objects","title":"1. Type-Level Semantics as First-Class Objects","text":"<p>In typical C++ systems, type-specific logic is embedded in:</p> <ul> <li>Template specializations  </li> <li><code>std::variant</code> visitor lambdas  </li> <li>Chains of <code>if constexpr (std::is_same_v&lt;T, ...&gt;)</code> </li> <li>RTTI (<code>typeid</code>, <code>dynamic_cast</code>)  </li> </ul> <p>These mechanisms work but lack a uniform abstraction for type conditions.</p> <p>Type Patterns elevate type checks to first-class pattern objects, enabling the same:</p> <ul> <li>Composition  </li> <li>Reuse  </li> <li>Declarative structure  </li> </ul> <p>that Value Patterns provide for runtime data.</p>"},{"location":"patterns/type/#2-zero-cost-type-dispatch","title":"2. Zero-Cost Type Dispatch","text":"<p>All type decisions in Patternia are resolved through normal C++ type inspection and inlining. The Pattern System introduces:</p> <ul> <li>No RTTI  </li> <li>No virtual calls  </li> <li>No runtime type discrimination  </li> <li>No dynamic polymorphism  </li> </ul> <p>By making type checks structural (not reflective), Patternia provides the performance profile needed for high-throughput or low-latency applications.</p>"},{"location":"patterns/type/#3-unifying-value-and-type-domains","title":"3. Unifying Value and Type Domains","text":"<p>A key architectural goal is that Value Patterns and Type Patterns participate in the same matching pipeline.</p> <p>This allows rules such as:</p> <ul> <li>\"If the subject is an <code>int</code> and greater than zero\u2026\"  </li> <li>\"If the subject is a <code>std::string</code> and equals 'start'\u2026\"  </li> <li>\"If the subject is from this template family and satisfies a numeric guard\u2026\"</li> </ul> <p>The system does not treat type and value as separate languages. They are part of one cohesive pattern algebra.</p>"},{"location":"patterns/type/#4-foundation-for-variant-dispatch","title":"4. Foundation for Variant Dispatch","text":"<p>The upcoming Variant Layer relies directly on Type Patterns.</p> <p>Matching an active alternative of <code>std::variant</code> is fundamentally a type-level operation:</p> <ul> <li>If the active type is <code>T</code>\u2026  </li> <li>If the active type belongs to <code>{A, B, C}</code>\u2026  </li> <li>If the alternative is any specialization of a template family\u2026</li> </ul> <p>Type Patterns make these decisions explicit and reusable.</p> <p>In other words, they are not an optional feature; they are a structural part of the library\u2019s dispatch model.</p>"},{"location":"patterns/type/#summary","title":"Summary","text":"<p>Architecturally, Type Patterns:</p> <ul> <li>Represent type-based semantics independently of runtime values  </li> <li>Provide a uniform abstraction for type dispatch  </li> <li>Integrate with the same compositional model used by Value Patterns  </li> <li>Enable zero-overhead matching  </li> <li>Form the basis for variant-aware pattern layers</li> </ul> <p>They are the type-theoretic pillar of Patternia\u2019s Pattern System.</p>"},{"location":"patterns/value/","title":"Value Patterns \u2014 Architectural Perspective","text":"<p>Value Patterns represent the part of the Pattern System concerned with runtime values. They describe conditions on concrete data: numbers, strings, states, commands, and any object that can be inspected without involving its type structure.</p> <p>From an architectural perspective, Value Patterns serve three core roles:</p>"},{"location":"patterns/value/#1-unifying-value-level-logic","title":"1. Unifying Value-Level Logic","text":"<p>In conventional C++, comparisons and conditions are expressed through imperative constructs:</p> <ul> <li><code>if (x == 42)</code> </li> <li><code>if (name == \"start\")</code> </li> <li><code>if (name == \"START\")</code> (case-insensitive)</li> </ul> <p>Each condition is tied to surrounding control flow. Value Patterns decouple the expression of conditions from the control structure that uses them.</p> <p>As a result:</p> <ul> <li>Value conditions become reusable units.</li> <li>Complex value logic becomes declarative\u2014described, not executed.</li> <li>Matching rules become centralized and maintainable.</li> </ul>"},{"location":"patterns/value/#2-enabling-compositional-semantics","title":"2. Enabling Compositional Semantics","text":"<p>Patterns obey a formal algebra. Value Patterns can be combined with logical operators to describe richer semantics without duplicating comparisons or control logic.</p> <p>This provides architectural benefits:</p> <ul> <li>Conditions become first-class objects.  </li> <li>Rules can be assembled, reused, refined, or shared across modules.  </li> <li>Large matching systems can be built from small, orthogonal components.</li> </ul> <p>This capability is essential as the library grows toward supporting predicate guards, custom user-defined patterns, and domain-specific pattern sets.</p>"},{"location":"patterns/value/#3-integrating-with-the-match-pipeline","title":"3. Integrating with the Match Pipeline","text":"<p>At match time, Value Patterns participate in a common evaluation pipeline:</p> <ol> <li>The subject is passed to each pattern.  </li> <li>The pattern decides, independently, whether the subject satisfies its rule.  </li> <li>A matching pattern triggers a handler and short-circuits evaluation.</li> </ol> <p>Value Patterns do not influence the structure of evaluation\u2014only the semantics of the condition. This separation of responsibilities keeps the system modular and allows different pattern families to coexist imperatively.</p>"},{"location":"patterns/value/#current-implementation","title":"Current Implementation","text":"<p>The current implementation provides:</p>"},{"location":"patterns/value/#literal-patterns","title":"Literal Patterns","text":"<ul> <li><code>lit(value)</code> - Exact value matching</li> <li><code>lit_ci(value)</code> - Case-insensitive string matching (ASCII only)</li> </ul>"},{"location":"patterns/value/#supported-types","title":"Supported Types","text":"<ul> <li>Arithmetic types (int, double, float, etc.)</li> <li>Enum types  </li> <li>Strings (std::string, std::string_view, const char*)</li> <li>User-defined types (must support operator==)</li> </ul>"},{"location":"patterns/value/#dsl-operators","title":"DSL Operators","text":"<ul> <li><code>&gt;&gt;</code> - Pattern-handler binding operator</li> </ul>"},{"location":"patterns/value/#summary","title":"Summary","text":"<p>Architecturally, Value Patterns:</p> <ul> <li>Represent value-level semantics in declarative form  </li> <li>Promote reusable, composable conditions  </li> <li>Integrate seamlessly into the shared match pipeline  </li> <li>Prepare the ground for higher-level constructs (predicates, guards, domain-specific rules)</li> </ul> <p>They are the foundational layer of runtime data dispatch in Patternia.</p>"}]}