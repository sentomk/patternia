{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Patternia Documentation","text":"<p>A modern C++ pattern matching DSL</p> <p>Patternia is a modern C++ pattern-matching DSL designed to make dispatch logic clear, expressive, and type-safe \u2014 without sacrificing performance or compilation efficiency.</p>"},{"location":"#navigation","title":"Navigation","text":""},{"location":"#quick-start","title":"Quick Start","text":"<ul> <li>Installation - How to integrate Patternia into your project</li> <li>Getting Started - Complete examples from basics to advanced</li> </ul>"},{"location":"#pattern-system","title":"Pattern System","text":"<ul> <li>Pattern System Overview - Understand Patternia's design philosophy</li> <li>Value Patterns - Value matching with literals, ranges, predicates</li> <li>Type Patterns - Type matching with type checking, type lists</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>API Documentation - Complete API reference for all functions and patterns</li> </ul>"},{"location":"#project-information","title":"Project Information","text":"<ul> <li>Roadmap - Future development directions and plans</li> <li>Releases - Version update history</li> </ul>"},{"location":"#core-features","title":"Core Features","text":"<ul> <li>Header-only: Zero dependencies, plug-and-play</li> <li>Declarative Syntax: <code>match().when().otherwise()</code> chaining</li> <li>Type Safety: Compile-time guarantees, zero runtime overhead</li> <li>Rich Patterns: Value patterns, type patterns, predicate patterns</li> <li>DSL Operators: <code>&gt;&gt;</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>!</code> for composition</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>#include &lt;ptn/patternia.hpp&gt;\nusing namespace ptn;\n\nint x = 42;\n\nauto result =\n    match(x)\n      .when(lit(0) &gt;&gt; \"zero\")\n      .when(lit(42) &gt;&gt; \"answer\")\n      .when(type::is&lt;int&gt; &gt;&gt; \"int value\")\n      .otherwise(\"other\");\n</code></pre> <p>Patternia evaluates patterns in order and returns the result associated with the first successful match.</p>"},{"location":"#where-to-start","title":"Where to Start","text":"<p>If you're new to Patternia, we recommend reading in this order:</p> <ol> <li>Installation - Integrate into your project</li> <li>Getting Started - Learn basic usage</li> <li>Value Patterns or Type Patterns - Deep dive based on your needs</li> </ol> <p>If you're looking for specific information:</p> <ul> <li>Need a function reference? \u2192 API Documentation</li> <li>Want to understand design philosophy? \u2192 Pattern System Overview</li> <li>Check version updates? \u2192 Releases</li> </ul>"},{"location":"#system-requirements","title":"System Requirements","text":"<ul> <li>C++ Standard: C++17 or later</li> <li>Compilers: GCC \u226511, Clang \u226512, MSVC \u22652019</li> <li>Platforms: Linux, Windows, macOS</li> </ul> Make logical structure explicit, make C++ code more elegant"},{"location":"patternia_architecture_en/","title":"Patternia Pattern Matching Library Architecture Analysis","text":""},{"location":"patternia_architecture_en/#part-1-namespace-structure","title":"Part 1: Namespace Structure","text":"<p>Patternia library adopts a clear hierarchical namespace structure, divided into the following layers:</p>"},{"location":"patternia_architecture_en/#root-namespace-ptn","title":"Root Namespace <code>ptn</code>","text":"<p>The root namespace of Patternia library, where all public APIs are located.</p>"},{"location":"patternia_architecture_en/#core-sub-namespaces","title":"Core Sub-namespaces","text":""},{"location":"patternia_architecture_en/#ptncore","title":"<code>ptn::core</code>","text":"<p>Core engine and DSL-related functionality - <code>ptn::core::common</code> - Common utilities and diagnostics - <code>ptn::core::dsl</code> - Domain-specific language operators - <code>ptn::core::engine</code> - Core matching engine implementation</p>"},{"location":"patternia_architecture_en/#ptnpat","title":"<code>ptn::pat</code>","text":"<p>Pattern definitions and implementations - <code>ptn::pat::base</code> - Base pattern abstractions and traits - <code>ptn::pat::value</code> - Value patterns (literal, relational, predicate) - <code>ptn::pat::type</code> - Type patterns</p>"},{"location":"patternia_architecture_en/#ptnmeta","title":"<code>ptn::meta</code>","text":"<p>Metaprogramming utilities - <code>ptn::meta::base</code> - Basic type traits - <code>ptn::meta::dsa</code> - Data structures and algorithms - <code>ptn::meta::query</code> - Type query utilities</p>"},{"location":"patternia_architecture_en/#implementation-detail-namespaces","title":"Implementation Detail Namespaces","text":"<ul> <li><code>ptn::core::engine::detail</code> - Engine implementation details</li> <li><code>ptn::core::dsl::detail</code> - DSL implementation details</li> <li><code>ptn::pat::value::detail</code> - Value pattern implementation details</li> <li><code>ptn::pat::type::detail</code> - Type pattern implementation details</li> </ul>"},{"location":"patternia_architecture_en/#part-2-layer-division","title":"Part 2: Layer Division","text":"<p>Patternia library adopts a classic layered architecture design, divided into the following layers from bottom to top:</p>"},{"location":"patternia_architecture_en/#meta-layer","title":"Meta Layer","text":"<p>Location: <code>ptn/meta/</code> Responsibility: Provides compile-time type operations and metaprogramming infrastructure - <code>base/traits.hpp</code> - Basic type traits (remove_cvref_t, is_spec_of, etc.) - <code>dsa/</code> - Data structures and algorithms (type_list, algorithms) - <code>query/</code> - Type query utilities (index, template_info)</p>"},{"location":"patternia_architecture_en/#core-layer","title":"Core Layer","text":"<p>Location: <code>ptn/core/</code> Responsibility: Provides core pattern matching engine and DSL support</p>"},{"location":"patternia_architecture_en/#common-sublayer","title":"Common Sublayer","text":"<ul> <li><code>common/</code> - Common utilities, diagnostics, optimization, evaluation</li> </ul>"},{"location":"patternia_architecture_en/#dsl-sublayer","title":"DSL Sublayer","text":"<ul> <li><code>dsl/</code> - Domain-specific language operators (&gt;&gt;, &amp;&amp;, ||, !)</li> </ul>"},{"location":"patternia_architecture_en/#engine-sublayer","title":"Engine Sublayer","text":"<ul> <li><code>engine/</code> - Matching engine implementation (builder, match)</li> </ul>"},{"location":"patternia_architecture_en/#pattern-layer","title":"Pattern Layer","text":"<p>Location: <code>ptn/pattern/</code> Responsibility: Defines various types of patterns and pattern factories</p>"},{"location":"patternia_architecture_en/#base-sublayer","title":"Base Sublayer","text":"<ul> <li><code>base/</code> - Pattern base classes, traits, binding contracts</li> </ul>"},{"location":"patternia_architecture_en/#value-pattern-sublayer","title":"Value Pattern Sublayer","text":"<ul> <li><code>value/</code> - Value patterns (literal, relational comparison, predicate)</li> </ul>"},{"location":"patternia_architecture_en/#type-pattern-sublayer","title":"Type Pattern Sublayer","text":"<ul> <li><code>type/</code> - Type patterns (is, in, not_in, from)</li> </ul>"},{"location":"patternia_architecture_en/#configuration-layer","title":"Configuration Layer","text":"<p>Location: <code>ptn/config.hpp</code> Responsibility: Compile-time configuration switches and feature control</p>"},{"location":"patternia_architecture_en/#integration-layer","title":"Integration Layer","text":"<p>Location: <code>ptn/patternia.hpp</code> Responsibility: Unified public entry point, exports all necessary headers</p>"},{"location":"patternia_architecture_en/#part-3-api-summary-and-semantics","title":"Part 3: API Summary and Semantics","text":""},{"location":"patternia_architecture_en/#core-matching-apis","title":"Core Matching APIs","text":""},{"location":"patternia_architecture_en/#ptnmatcht-value","title":"<code>ptn::match(T&amp;&amp; value)</code>","text":"<p>Semantics: Entry point for pattern matching, creates a match builder Parameters: Value to be matched Returns: <code>match_builder</code> object supporting chained calls</p>"},{"location":"patternia_architecture_en/#ptnmatchut-value","title":"<code>ptn::match&lt;U&gt;(T&amp;&amp; value)</code>","text":"<p>Semantics: Pattern matching entry point with explicit type specification Parameters: Target type U and value to be converted Returns: Typed <code>match_builder</code> object</p>"},{"location":"patternia_architecture_en/#pattern-builder-apis","title":"Pattern Builder APIs","text":""},{"location":"patternia_architecture_en/#whencase_expr","title":"<code>when(case_expr)</code>","text":"<p>Semantics: Add a matching condition and corresponding handler function Parameters: Case expression created using <code>&gt;&gt;</code> operator Returns: New match builder (supports chained calls)</p>"},{"location":"patternia_architecture_en/#otherwisehandler","title":"<code>otherwise(handler)</code>","text":"<p>Semantics: Set default handler function, executed when all patterns fail to match Parameters: Handler function or return value Returns: Matching result</p>"},{"location":"patternia_architecture_en/#dsl-operator-apis","title":"DSL Operator APIs","text":""},{"location":"patternia_architecture_en/#pattern-handler","title":"<code>pattern &gt;&gt; handler</code>","text":"<p>Semantics: Associate pattern with handler function Special: If handler is a value type, automatically converted to a function returning that value</p>"},{"location":"patternia_architecture_en/#pattern1-pattern2","title":"<code>pattern1 &amp;&amp; pattern2</code>","text":"<p>Semantics: Logical AND composition, both patterns must match</p>"},{"location":"patternia_architecture_en/#pattern1-pattern2_1","title":"<code>pattern1 || pattern2</code>","text":"<p>Semantics: Logical OR composition, either pattern matching is sufficient</p>"},{"location":"patternia_architecture_en/#pattern","title":"<code>!pattern</code>","text":"<p>Semantics: Logical NOT, succeeds when pattern does not match</p>"},{"location":"patternia_architecture_en/#value-pattern-apis","title":"Value Pattern APIs","text":""},{"location":"patternia_architecture_en/#literal-patterns","title":"Literal Patterns","text":"<ul> <li><code>lit(value)</code> - Exact literal value matching</li> <li><code>lit_ci(value)</code> - Case-insensitive string matching</li> </ul>"},{"location":"patternia_architecture_en/#relational-patterns","title":"Relational Patterns","text":"<ul> <li><code>lt(value)</code> - Less than (x &lt; value)</li> <li><code>le(value)</code> - Less than or equal (x &lt;= value)</li> <li><code>gt(value)</code> - Greater than (x &gt; value)</li> <li><code>ge(value)</code> - Greater than or equal (x &gt;= value)</li> <li><code>eq(value)</code> - Equal (x == value)</li> <li><code>ne(value)</code> - Not equal (x != value)</li> <li><code>between(lo, hi, closed=true)</code> - Interval matching</li> </ul>"},{"location":"patternia_architecture_en/#predicate-patterns","title":"Predicate Patterns","text":"<ul> <li><code>pred(predicate)</code> - Use arbitrary predicate function</li> </ul>"},{"location":"patternia_architecture_en/#type-pattern-apis","title":"Type Pattern APIs","text":""},{"location":"patternia_architecture_en/#ptnpattypeist","title":"<code>ptn::pat::type::is&lt;T&gt;</code>","text":"<p>Semantics: Exact type matching, binds value to handler when match succeeds Binding: Binds matched value as <code>std::tuple&lt;Subject&gt;</code></p>"},{"location":"patternia_architecture_en/#ptnpattypeintypes","title":"<code>ptn::pat::type::in&lt;Types...&gt;</code>","text":"<p>Semantics: Type set matching, checks if type is in given type list</p>"},{"location":"patternia_architecture_en/#ptnpattypenot_intypes","title":"<code>ptn::pat::type::not_in&lt;Types...&gt;</code>","text":"<p>Semantics: Type exclusion matching, checks if type is not in given type list</p>"},{"location":"patternia_architecture_en/#ptnpattypefromt","title":"<code>ptn::pat::type::from&lt;T&gt;</code>","text":"<p>Semantics: Type conversion matching, checks if convertible from target type</p>"},{"location":"patternia_architecture_en/#metaprogramming-apis","title":"Metaprogramming APIs","text":""},{"location":"patternia_architecture_en/#type-traits","title":"Type Traits","text":"<ul> <li><code>ptn::meta::remove_cvref_t&lt;T&gt;</code> - Remove const/volatile and reference</li> <li><code>ptn::meta::is_spec_of_v&lt;Template, T&gt;</code> - Check if template specialization</li> <li><code>ptn::meta::is_tmpl_v&lt;T&gt;</code> - Check if template instance</li> </ul>"},{"location":"patternia_architecture_en/#type-list-operations","title":"Type List Operations","text":"<ul> <li><code>ptn::meta::dsa::type_list</code> - Type list container</li> <li><code>ptn::meta::dsa::algorithms</code> - Type list algorithms</li> </ul>"},{"location":"patternia_architecture_en/#configuration-macros","title":"Configuration Macros","text":"<ul> <li><code>PTN_ENABLE_VALUE_PATTERN</code> - Enable value patterns</li> <li><code>PTN_ENABLE_RELATIONAL_PATTERN</code> - Enable relational patterns</li> <li><code>PTN_ENABLE_TYPE_PATTERN</code> - Enable type patterns</li> <li><code>PTN_ENABLE_PREDICATE_PATTERN</code> - Enable predicate patterns</li> <li><code>PTN_USE_CONCEPTS</code> - Enable C++20 concepts support</li> </ul>"},{"location":"patternia_architecture_en/#binding-semantics","title":"Binding Semantics","text":"<ul> <li>Literal patterns: Bind no values (<code>std::tuple&lt;&gt;</code>)</li> <li>Relational patterns: Bind no values (<code>std::tuple&lt;&gt;</code>)</li> <li>Predicate patterns: Bind no values (<code>std::tuple&lt;&gt;</code>)</li> <li>Type patterns: Bind matched value (<code>std::tuple&lt;Subject&gt;</code>)</li> </ul>"},{"location":"patternia_architecture_en/#error-handling","title":"Error Handling","text":"<p>The library uses <code>static_assert</code> for compile-time validation of: - Pattern type validity - Handler function signature compatibility - Type constructibility - Operator support</p> <p>This design ensures type safety and high performance while providing an intuitive and easy-to-use DSL syntax.</p>"},{"location":"patternia_architecture_zh/","title":"Patternia \u6a21\u5f0f\u5339\u914d\u5e93\u67b6\u6784\u5206\u6790","text":""},{"location":"patternia_architecture_zh/#_1","title":"\u7b2c\u4e00\u90e8\u5206\uff1a\u547d\u540d\u7a7a\u95f4\u7ed3\u6784","text":"<p>Patternia \u5e93\u91c7\u7528\u4e86\u6e05\u6670\u7684\u5c42\u6b21\u5316\u547d\u540d\u7a7a\u95f4\u7ed3\u6784\uff0c\u4e3b\u8981\u5206\u4e3a\u4ee5\u4e0b\u51e0\u4e2a\u5c42\u6b21\uff1a</p>"},{"location":"patternia_architecture_zh/#ptn","title":"\u6839\u547d\u540d\u7a7a\u95f4 <code>ptn</code>","text":"<p>Patternia \u5e93\u7684\u6839\u547d\u540d\u7a7a\u95f4\uff0c\u6240\u6709\u516c\u5171API\u90fd\u4f4d\u4e8e\u6b64\u547d\u540d\u7a7a\u95f4\u4e0b\u3002</p>"},{"location":"patternia_architecture_zh/#_2","title":"\u6838\u5fc3\u5b50\u547d\u540d\u7a7a\u95f4","text":""},{"location":"patternia_architecture_zh/#ptncore","title":"<code>ptn::core</code>","text":"<p>\u6838\u5fc3\u5f15\u64ce\u548cDSL\u76f8\u5173\u529f\u80fd - <code>ptn::core::common</code> - \u901a\u7528\u5de5\u5177\u548c\u8bca\u65ad - <code>ptn::core::dsl</code> - \u9886\u57df\u7279\u5b9a\u8bed\u8a00\u64cd\u4f5c\u7b26 - <code>ptn::core::engine</code> - \u5339\u914d\u5f15\u64ce\u6838\u5fc3\u5b9e\u73b0</p>"},{"location":"patternia_architecture_zh/#ptnpat","title":"<code>ptn::pat</code>","text":"<p>\u6a21\u5f0f\u5b9a\u4e49\u548c\u5b9e\u73b0 - <code>ptn::pat::base</code> - \u57fa\u7840\u6a21\u5f0f\u62bd\u8c61\u548c\u7279\u5f81 - <code>ptn::pat::value</code> - \u503c\u6a21\u5f0f\uff08\u5b57\u9762\u91cf\u3001\u5173\u7cfb\u3001\u8c13\u8bcd\uff09 - <code>ptn::pat::type</code> - \u7c7b\u578b\u6a21\u5f0f</p>"},{"location":"patternia_architecture_zh/#ptnmeta","title":"<code>ptn::meta</code>","text":"<p>\u5143\u7f16\u7a0b\u5de5\u5177 - <code>ptn::meta::base</code> - \u57fa\u7840\u7c7b\u578b\u7279\u5f81 - <code>ptn::meta::dsa</code> - \u6570\u636e\u7ed3\u6784\u548c\u7b97\u6cd5 - <code>ptn::meta::query</code> - \u7c7b\u578b\u67e5\u8be2\u5de5\u5177</p>"},{"location":"patternia_architecture_zh/#_3","title":"\u5b9e\u73b0\u7ec6\u8282\u547d\u540d\u7a7a\u95f4","text":"<ul> <li><code>ptn::core::engine::detail</code> - \u5f15\u64ce\u5b9e\u73b0\u7ec6\u8282</li> <li><code>ptn::core::dsl::detail</code> - DSL\u5b9e\u73b0\u7ec6\u8282</li> <li><code>ptn::pat::value::detail</code> - \u503c\u6a21\u5f0f\u5b9e\u73b0\u7ec6\u8282</li> <li><code>ptn::pat::type::detail</code> - \u7c7b\u578b\u6a21\u5f0f\u5b9e\u73b0\u7ec6\u8282</li> </ul>"},{"location":"patternia_architecture_zh/#_4","title":"\u7b2c\u4e8c\u90e8\u5206\uff1a\u5c42\u6b21\u5212\u5206","text":"<p>Patternia \u5e93\u91c7\u7528\u4e86\u7ecf\u5178\u7684\u5206\u5c42\u67b6\u6784\u8bbe\u8ba1\uff0c\u4ece\u5e95\u5c42\u5230\u9876\u5c42\u5206\u4e3a\u4ee5\u4e0b\u5c42\u6b21\uff1a</p>"},{"location":"patternia_architecture_zh/#meta-layer","title":"Meta Layer (\u5143\u7f16\u7a0b\u5c42)","text":"<p>\u4f4d\u7f6e: <code>ptn::meta/</code> \u804c\u8d23: \u63d0\u4f9b\u7f16\u8bd1\u65f6\u7c7b\u578b\u64cd\u4f5c\u548c\u5143\u7f16\u7a0b\u57fa\u7840\u8bbe\u65bd - <code>base/traits.hpp</code> - \u57fa\u7840\u7c7b\u578b\u7279\u5f81\uff08remove_cvref_t, is_spec_of\u7b49\uff09 - <code>dsa/</code> - \u6570\u636e\u7ed3\u6784\u548c\u7b97\u6cd5\uff08type_list, algorithms\uff09 - <code>query/</code> - \u7c7b\u578b\u67e5\u8be2\u5de5\u5177\uff08index, template_info\uff09</p>"},{"location":"patternia_architecture_zh/#core-layer","title":"Core Layer (\u6838\u5fc3\u5c42)","text":"<p>\u4f4d\u7f6e: <code>ptn/core/</code> \u804c\u8d23: \u63d0\u4f9b\u6a21\u5f0f\u5339\u914d\u7684\u6838\u5fc3\u5f15\u64ce\u548cDSL\u652f\u6301</p>"},{"location":"patternia_architecture_zh/#common-sublayer","title":"Common Sublayer","text":"<ul> <li><code>common/</code> - \u901a\u7528\u5de5\u5177\u3001\u8bca\u65ad\u3001\u4f18\u5316\u3001\u8bc4\u4f30</li> </ul>"},{"location":"patternia_architecture_zh/#dsl-sublayer","title":"DSL Sublayer","text":"<ul> <li><code>dsl/</code> - \u9886\u57df\u7279\u5b9a\u8bed\u8a00\u64cd\u4f5c\u7b26\uff08&gt;&gt;, &amp;&amp;, ||, !\uff09</li> </ul>"},{"location":"patternia_architecture_zh/#engine-sublayer","title":"Engine Sublayer","text":"<ul> <li><code>engine/</code> - \u5339\u914d\u5f15\u64ce\u5b9e\u73b0\uff08builder, match\uff09</li> </ul>"},{"location":"patternia_architecture_zh/#pattern-layer","title":"Pattern Layer (\u6a21\u5f0f\u5c42)","text":"<p>\u4f4d\u7f6e: <code>ptn/pattern/</code> \u804c\u8d23: \u5b9a\u4e49\u5404\u79cd\u7c7b\u578b\u7684\u6a21\u5f0f\u548c\u6a21\u5f0f\u5de5\u5382</p>"},{"location":"patternia_architecture_zh/#base-sublayer","title":"Base Sublayer","text":"<ul> <li><code>base/</code> - \u6a21\u5f0f\u57fa\u7c7b\u3001\u7279\u5f81\u3001\u7ed1\u5b9a\u5951\u7ea6</li> </ul>"},{"location":"patternia_architecture_zh/#value-pattern-sublayer","title":"Value Pattern Sublayer","text":"<ul> <li><code>value/</code> - \u503c\u6a21\u5f0f\uff08\u5b57\u9762\u91cf\u3001\u5173\u7cfb\u6bd4\u8f83\u3001\u8c13\u8bcd\uff09</li> </ul>"},{"location":"patternia_architecture_zh/#type-pattern-sublayer","title":"Type Pattern Sublayer","text":"<ul> <li><code>type/</code> - \u7c7b\u578b\u6a21\u5f0f\uff08is, in, not_in, from\uff09</li> </ul>"},{"location":"patternia_architecture_zh/#configuration-layer","title":"Configuration Layer (\u914d\u7f6e\u5c42)","text":"<p>\u4f4d\u7f6e: <code>ptn/config.hpp</code> \u804c\u8d23: \u7f16\u8bd1\u65f6\u914d\u7f6e\u5f00\u5173\u548c\u7279\u6027\u63a7\u5236</p>"},{"location":"patternia_architecture_zh/#integration-layer","title":"Integration Layer (\u96c6\u6210\u5c42)","text":"<p>\u4f4d\u7f6e: <code>ptn/patternia.hpp</code> \u804c\u8d23: \u7edf\u4e00\u7684\u516c\u5171\u5165\u53e3\u70b9\uff0c\u5bfc\u51fa\u6240\u6709\u5fc5\u8981\u7684\u5934\u6587\u4ef6</p>"},{"location":"patternia_architecture_zh/#api","title":"\u7b2c\u4e09\u90e8\u5206\uff1aAPI\u6c47\u603b\u53ca\u5176\u8bed\u4e49","text":""},{"location":"patternia_architecture_zh/#api_1","title":"\u6838\u5fc3\u5339\u914dAPI","text":""},{"location":"patternia_architecture_zh/#ptnmatcht-value","title":"<code>ptn::match(T&amp;&amp; value)</code>","text":"<p>\u8bed\u4e49: \u6a21\u5f0f\u5339\u914d\u7684\u5165\u53e3\u70b9\uff0c\u521b\u5efa\u5339\u914d\u6784\u5efa\u5668 \u53c2\u6570: \u8981\u5339\u914d\u7684\u503c \u8fd4\u56de: <code>match_builder</code> \u5bf9\u8c61\uff0c\u652f\u6301\u94fe\u5f0f\u8c03\u7528</p>"},{"location":"patternia_architecture_zh/#ptnmatchut-value","title":"<code>ptn::match&lt;U&gt;(T&amp;&amp; value)</code>","text":"<p>\u8bed\u4e49: \u663e\u5f0f\u6307\u5b9a\u7c7b\u578b\u7684\u6a21\u5f0f\u5339\u914d\u5165\u53e3\u70b9 \u53c2\u6570: \u76ee\u6807\u7c7b\u578bU\u548c\u8981\u8f6c\u6362\u7684\u503c \u8fd4\u56de: \u6307\u5b9a\u7c7b\u578b\u7684 <code>match_builder</code> \u5bf9\u8c61</p>"},{"location":"patternia_architecture_zh/#api_2","title":"\u6a21\u5f0f\u6784\u5efa\u5668API","text":""},{"location":"patternia_architecture_zh/#whencase_expr","title":"<code>when(case_expr)</code>","text":"<p>\u8bed\u4e49: \u6dfb\u52a0\u4e00\u4e2a\u5339\u914d\u6761\u4ef6\u548c\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570 \u53c2\u6570: \u4f7f\u7528 <code>&gt;&gt;</code> \u64cd\u4f5c\u7b26\u521b\u5efa\u7684case\u8868\u8fbe\u5f0f \u8fd4\u56de: \u65b0\u7684\u5339\u914d\u6784\u5efa\u5668\uff08\u652f\u6301\u94fe\u5f0f\u8c03\u7528\uff09</p>"},{"location":"patternia_architecture_zh/#otherwisehandler","title":"<code>otherwise(handler)</code>","text":"<p>\u8bed\u4e49: \u8bbe\u7f6e\u9ed8\u8ba4\u5904\u7406\u51fd\u6570\uff0c\u5f53\u6240\u6709\u6a21\u5f0f\u90fd\u4e0d\u5339\u914d\u65f6\u6267\u884c \u53c2\u6570: \u5904\u7406\u51fd\u6570\u6216\u8fd4\u56de\u503c \u8fd4\u56de: \u5339\u914d\u7ed3\u679c</p>"},{"location":"patternia_architecture_zh/#dslapi","title":"DSL\u64cd\u4f5c\u7b26API","text":""},{"location":"patternia_architecture_zh/#pattern-handler","title":"<code>pattern &gt;&gt; handler</code>","text":"<p>\u8bed\u4e49: \u5c06\u6a21\u5f0f\u4e0e\u5904\u7406\u51fd\u6570\u5173\u8054 \u7279\u6b8a: \u5982\u679chandler\u662f\u503c\u7c7b\u578b\uff0c\u81ea\u52a8\u8f6c\u6362\u4e3a\u8fd4\u56de\u8be5\u503c\u7684\u51fd\u6570</p>"},{"location":"patternia_architecture_zh/#pattern1-pattern2","title":"<code>pattern1 &amp;&amp; pattern2</code>","text":"<p>\u8bed\u4e49: \u903b\u8f91AND\u7ec4\u5408\uff0c\u4e24\u4e2a\u6a21\u5f0f\u90fd\u5fc5\u987b\u5339\u914d</p>"},{"location":"patternia_architecture_zh/#pattern1-pattern2_1","title":"<code>pattern1 || pattern2</code>","text":"<p>\u8bed\u4e49: \u903b\u8f91OR\u7ec4\u5408\uff0c\u4efb\u4e00\u6a21\u5f0f\u5339\u914d\u5373\u53ef</p>"},{"location":"patternia_architecture_zh/#pattern","title":"<code>!pattern</code>","text":"<p>\u8bed\u4e49: \u903b\u8f91NOT\uff0c\u6a21\u5f0f\u4e0d\u5339\u914d\u65f6\u6210\u529f</p>"},{"location":"patternia_architecture_zh/#api_3","title":"\u503c\u6a21\u5f0fAPI","text":""},{"location":"patternia_architecture_zh/#_5","title":"\u5b57\u9762\u91cf\u6a21\u5f0f","text":"<ul> <li><code>lit(value)</code> - \u7cbe\u786e\u5339\u914d\u5b57\u9762\u503c</li> <li><code>lit_ci(value)</code> - \u5927\u5c0f\u5199\u4e0d\u654f\u611f\u7684\u5b57\u7b26\u4e32\u5339\u914d</li> </ul>"},{"location":"patternia_architecture_zh/#_6","title":"\u5173\u7cfb\u6a21\u5f0f","text":"<ul> <li><code>lt(value)</code> - \u5c0f\u4e8e (x &lt; value)</li> <li><code>le(value)</code> - \u5c0f\u4e8e\u7b49\u4e8e (x &lt;= value)</li> <li><code>gt(value)</code> - \u5927\u4e8e (x &gt; value)</li> <li><code>ge(value)</code> - \u5927\u4e8e\u7b49\u4e8e (x &gt;= value)</li> <li><code>eq(value)</code> - \u7b49\u4e8e (x == value)</li> <li><code>ne(value)</code> - \u4e0d\u7b49\u4e8e (x != value)</li> <li><code>between(lo, hi, closed=true)</code> - \u533a\u95f4\u5339\u914d</li> </ul>"},{"location":"patternia_architecture_zh/#_7","title":"\u8c13\u8bcd\u6a21\u5f0f","text":"<ul> <li><code>pred(predicate)</code> - \u4f7f\u7528\u4efb\u610f\u8c13\u8bcd\u51fd\u6570</li> </ul>"},{"location":"patternia_architecture_zh/#api_4","title":"\u7c7b\u578b\u6a21\u5f0fAPI","text":""},{"location":"patternia_architecture_zh/#ptnpattypeist","title":"<code>ptn::pat::type::is&lt;T&gt;</code>","text":"<p>\u8bed\u4e49: \u7cbe\u786e\u7c7b\u578b\u5339\u914d\uff0c\u5339\u914d\u6210\u529f\u65f6\u7ed1\u5b9a\u503c\u5230\u5904\u7406\u51fd\u6570 \u7ed1\u5b9a: \u7ed1\u5b9a\u5339\u914d\u7684\u503c\u4f5c\u4e3a <code>std::tuple&lt;Subject&gt;</code></p>"},{"location":"patternia_architecture_zh/#ptnpattypeintypes","title":"<code>ptn::pat::type::in&lt;Types...&gt;</code>","text":"<p>\u8bed\u4e49: \u7c7b\u578b\u96c6\u5408\u5339\u914d\uff0c\u68c0\u67e5\u7c7b\u578b\u662f\u5426\u5728\u7ed9\u5b9a\u7684\u7c7b\u578b\u5217\u8868\u4e2d</p>"},{"location":"patternia_architecture_zh/#ptnpattypenot_intypes","title":"<code>ptn::pat::type::not_in&lt;Types...&gt;</code>","text":"<p>\u8bed\u4e49: \u7c7b\u578b\u6392\u9664\u5339\u914d\uff0c\u68c0\u67e5\u7c7b\u578b\u4e0d\u5728\u7ed9\u5b9a\u7684\u7c7b\u578b\u5217\u8868\u4e2d</p>"},{"location":"patternia_architecture_zh/#ptnpattypefromt","title":"<code>ptn::pat::type::from&lt;T&gt;</code>","text":"<p>\u8bed\u4e49: \u7c7b\u578b\u8f6c\u6362\u5339\u914d\uff0c\u68c0\u67e5\u662f\u5426\u53ef\u4ee5\u4ece\u76ee\u6807\u7c7b\u578b\u8f6c\u6362\u800c\u6765</p>"},{"location":"patternia_architecture_zh/#api_5","title":"\u5143\u7f16\u7a0bAPI","text":""},{"location":"patternia_architecture_zh/#_8","title":"\u7c7b\u578b\u7279\u5f81","text":"<ul> <li><code>ptn::meta::remove_cvref_t&lt;T&gt;</code> - \u79fb\u9664const/volatile\u548c\u5f15\u7528</li> <li><code>ptn::meta::is_spec_of_v&lt;Template, T&gt;</code> - \u68c0\u67e5\u662f\u5426\u4e3a\u6a21\u677f\u7279\u5316</li> <li><code>ptn::meta::is_tmpl_v&lt;T&gt;</code> - \u68c0\u67e5\u662f\u5426\u4e3a\u6a21\u677f\u5b9e\u4f8b</li> </ul>"},{"location":"patternia_architecture_zh/#_9","title":"\u7c7b\u578b\u5217\u8868\u64cd\u4f5c","text":"<ul> <li><code>ptn::meta::dsa::type_list</code> - \u7c7b\u578b\u5217\u8868\u5bb9\u5668</li> <li><code>ptn::meta::dsa::algorithms</code> - \u7c7b\u578b\u5217\u8868\u7b97\u6cd5</li> </ul>"},{"location":"patternia_architecture_zh/#_10","title":"\u914d\u7f6e\u5b8f","text":"<ul> <li><code>PTN_ENABLE_VALUE_PATTERN</code> - \u542f\u7528\u503c\u6a21\u5f0f</li> <li><code>PTN_ENABLE_RELATIONAL_PATTERN</code> - \u542f\u7528\u5173\u7cfb\u6a21\u5f0f</li> <li><code>PTN_ENABLE_TYPE_PATTERN</code> - \u542f\u7528\u7c7b\u578b\u6a21\u5f0f</li> <li><code>PTN_ENABLE_PREDICATE_PATTERN</code> - \u542f\u7528\u8c13\u8bcd\u6a21\u5f0f</li> <li><code>PTN_USE_CONCEPTS</code> - \u542f\u7528C++20\u6982\u5ff5\u652f\u6301</li> </ul>"},{"location":"patternia_architecture_zh/#_11","title":"\u7ed1\u5b9a\u8bed\u4e49","text":"<ul> <li>\u5b57\u9762\u91cf\u6a21\u5f0f: \u4e0d\u7ed1\u5b9a\u4efb\u4f55\u503c\uff08<code>std::tuple&lt;&gt;</code>\uff09</li> <li>\u5173\u7cfb\u6a21\u5f0f: \u4e0d\u7ed1\u5b9a\u4efb\u4f55\u503c\uff08<code>std::tuple&lt;&gt;</code>\uff09</li> <li>\u8c13\u8bcd\u6a21\u5f0f: \u4e0d\u7ed1\u5b9a\u4efb\u4f55\u503c\uff08<code>std::tuple&lt;&gt;</code>\uff09</li> <li>\u7c7b\u578b\u6a21\u5f0f: \u7ed1\u5b9a\u5339\u914d\u7684\u503c\uff08<code>std::tuple&lt;Subject&gt;</code>\uff09</li> </ul>"},{"location":"patternia_architecture_zh/#_12","title":"\u9519\u8bef\u5904\u7406","text":"<p>\u5e93\u4f7f\u7528 <code>static_assert</code> \u5728\u7f16\u8bd1\u65f6\u9a8c\u8bc1\uff1a - \u6a21\u5f0f\u7c7b\u578b\u7684\u6709\u6548\u6027 - \u5904\u7406\u51fd\u6570\u7b7e\u540d\u7684\u517c\u5bb9\u6027 - \u7c7b\u578b\u7684\u53ef\u6784\u9020\u6027 - \u64cd\u4f5c\u7b26\u7684\u652f\u6301\u6027</p> <p>\u8fd9\u4e2a\u8bbe\u8ba1\u786e\u4fdd\u4e86\u7c7b\u578b\u5b89\u5168\u548c\u9ad8\u6027\u80fd\uff0c\u540c\u65f6\u63d0\u4f9b\u4e86\u76f4\u89c2\u6613\u7528\u7684DSL\u8bed\u6cd5\u3002</p>"},{"location":"api/api/","title":"Patternia API Reference","text":""},{"location":"api/api/#namespace-structure-overview","title":"Namespace Structure Overview","text":"<p>Patternia adopts a layered namespace design, primarily containing the following namespaces:</p> <pre><code>ptn/                                    // Root namespace\n\u251c\u2500\u2500 core/                              // Core matching engine\n\u2502   \u251c\u2500\u2500 engine/                        // Matching engine implementation\n\u2502   \u251c\u2500\u2500 dsl/                          // DSL operators\n\u2502   \u2514\u2500\u2500 common/                       // Common utilities and traits\n\u251c\u2500\u2500 pat/                              // Pattern definitions\n\u2502   \u251c\u2500\u2500 base/                         // Pattern base classes\n\u2502   \u251c\u2500\u2500 value/                        // Value patterns\n\u2502   \u2514\u2500\u2500 type/                         // Type patterns\n\u2514\u2500\u2500 meta/                             // Meta programming tools\n    \u251c\u2500\u2500 base/                         // Base traits\n    \u251c\u2500\u2500 dsa/                          // Data structures and algorithms\n    \u2514\u2500\u2500 query/                        // Query utilities\n</code></pre>"},{"location":"api/api/#main-namespace-aliases","title":"Main Namespace Aliases","text":"<p>For user convenience, Patternia provides the following namespace aliases:</p> <pre><code>namespace ptn {\n  namespace type = pat::type;    // Type pattern alias\n  namespace value = pat::value;  // Value pattern alias\n}\n</code></pre>"},{"location":"api/api/#core-matching-engine-api","title":"Core Matching Engine API","text":""},{"location":"api/api/#main-entry-functions","title":"Main Entry Functions","text":""},{"location":"api/api/#ptnmatchvalue","title":"<code>ptn::match(value)</code>","text":"<p>Type-deduced matching entry point that automatically deduces the value type.</p> <pre><code>template &lt;typename T&gt;\nconstexpr auto match(T &amp;&amp;value);\n</code></pre> <p>Parameters: - <code>value</code> - Value to match (forwarding reference)</p> <p>Returns: <code>match_builder</code> object for chained calls to <code>.when()</code> and <code>.otherwise()</code></p> <p>Example: <pre><code>int x = 42;\nauto result = match(x)\n    .when(lit(42) &gt;&gt; \"answer\")\n    .otherwise(\"other\");\n</code></pre></p>"},{"location":"api/api/#ptnmatchuvalue","title":"<code>ptn::match&lt;U&gt;(value)</code>","text":"<p>Explicit type-specified matching entry point that forces conversion to target type.</p> <pre><code>template &lt;typename U, typename T&gt;\nconstexpr auto match(T &amp;&amp;value);\n</code></pre> <p>Parameters: - <code>U</code> - Target type - <code>value</code> - Value to match</p> <p>Constraints: Type U must be constructible from value</p> <p>Example: <pre><code>double d = 3.14;\nauto result = match&lt;int&gt;(d)  // Force convert to int\n    .when(lit(3) &gt;&gt; \"three\")\n    .otherwise(\"other\");\n</code></pre></p>"},{"location":"api/api/#match-builder-api","title":"Match Builder API","text":""},{"location":"api/api/#match_builderwhenpattern-handler","title":"<code>match_builder::when(pattern &gt;&gt; handler)</code>","text":"<p>Add a matching branch.</p> <p>Syntax: <pre><code>.when(pattern &gt;&gt; handler)\n</code></pre></p> <p>Parameters: - <code>pattern</code> - Any pattern object - <code>handler</code> - Handler function or value</p> <p>Returns: New <code>match_builder</code> object (supports chained calls)</p>"},{"location":"api/api/#match_builderotherwisehandler","title":"<code>match_builder::otherwise(handler)</code>","text":"<p>Add a default branch.</p> <p>Syntax: <pre><code>.otherwise(handler)\n</code></pre></p> <p>Parameters: - <code>handler</code> - Default handler function or value</p> <p>Returns: Match result</p>"},{"location":"api/api/#value-pattern-api","title":"Value Pattern API","text":"<p>Note</p> <p><code>ptn::pat::value::lit</code> == <code>ptn::lit</code> </p>"},{"location":"api/api/#literal-patterns","title":"Literal Patterns","text":""},{"location":"api/api/#ptnlitvalue","title":"<code>ptn::lit(value)</code>","text":"<p>Create exact match pattern.</p> <pre><code>template &lt;typename V&gt;\nconstexpr auto lit(V &amp;&amp;v);\n</code></pre> <p>Purpose: Create a pattern that exactly matches the given value</p> <p>Supported Types: - Arithmetic types (int, double, float, etc.) - Enum types - Strings (std::string, std::string_view, const char*) - User-defined types (must support operator==)</p> <p>Examples: <pre><code>// Integer matching\nmatch(42).when(lit(42) &gt;&gt; \"answer\");\n\n// String matching\nmatch(\"hello\").when(lit(\"hello\") &gt;&gt; \"greeting\");\n\n// Enum matching\nenum class Color { Red, Green, Blue };\nColor c = Color::Red;\nmatch(c).when(lit(Color::Red) &gt;&gt; \"red\");\n</code></pre></p>"},{"location":"api/api/#ptnlit_civalue","title":"<code>ptn::lit_ci(value)</code>","text":"<p>Create case-insensitive string matching pattern.</p> <pre><code>template &lt;typename V&gt;\nconstexpr auto lit_ci(V &amp;&amp;v);\n</code></pre> <p>Purpose: Create a case-insensitive string matching pattern (ASCII only)</p> <p>Example: <pre><code>std::string s = \"HELLO\";\nmatch(s).when(lit_ci(\"hello\") &gt;&gt; \"case-insensitive-match\");\n</code></pre></p>"},{"location":"api/api/#relational-patterns","title":"Relational Patterns","text":""},{"location":"api/api/#ptnltvalue-less-than","title":"<code>ptn::lt(value)</code> - Less than","text":"<pre><code>template &lt;typename V&gt;\nconstexpr auto lt(V &amp;&amp;v);\n</code></pre> <p>Example: <pre><code>match(5).when(lt(10) &gt;&gt; \"less-than-10\");\n</code></pre></p>"},{"location":"api/api/#ptnlevalue-less-than-or-equal","title":"<code>ptn::le(value)</code> - Less than or equal","text":"<pre><code>template &lt;typename V&gt;\nconstexpr auto le(V &amp;&amp;v);\n</code></pre> <p>Example: <pre><code>match(10).when(le(10) &gt;&gt; \"less-or-equal-10\");\n</code></pre></p>"},{"location":"api/api/#ptngtvalue-greater-than","title":"<code>ptn::gt(value)</code> - Greater than","text":"<pre><code>template &lt;typename V&gt;\nconstexpr auto gt(V &amp;&amp;v);\n</code></pre> <p>Example: <pre><code>match(15).when(gt(10) &gt;&gt; \"greater-than-10\");\n</code></pre></p>"},{"location":"api/api/#ptngevalue-greater-than-or-equal","title":"<code>ptn::ge(value)</code> - Greater than or equal","text":"<pre><code>template &lt;typename V&gt;\nconstexpr auto ge(V &amp;&amp;v);\n</code></pre> <p>Example: <pre><code>match(10).when(ge(10) &gt;&gt; \"greater-or-equal-10\");\n</code></pre></p>"},{"location":"api/api/#ptneqvalue-equal","title":"<code>ptn::eq(value)</code> - Equal","text":"<pre><code>template &lt;typename V&gt;\nconstexpr auto eq(V &amp;&amp;v);\n</code></pre> <p>Example: <pre><code>match(42).when(eq(42) &gt;&gt; \"equal-42\");\n</code></pre></p>"},{"location":"api/api/#ptnnevalue-not-equal","title":"<code>ptn::ne(value)</code> - Not equal","text":"<pre><code>template &lt;typename V&gt;\nconstexpr auto ne(V &amp;&amp;v);\n</code></pre> <p>Example: <pre><code>match(42).when(ne(0) &gt;&gt; \"not-zero\");\n</code></pre></p>"},{"location":"api/api/#ptnbetweenlo-hi-closed-range-matching","title":"<code>ptn::between(lo, hi, closed)</code> - Range matching","text":"<pre><code>template &lt;typename L, typename R&gt;\nconstexpr auto between(L &amp;&amp;lo, R &amp;&amp;hi, bool closed = true);\n</code></pre> <p>Parameters: - <code>lo</code> - Lower bound - <code>hi</code> - Upper bound - <code>closed</code> - Whether it's a closed interval (default true)</p> <p>Examples: <pre><code>match(5).when(between(1, 10) &gt;&gt; \"in-range\");      // [1, 10]\nmatch(5).when(between(1, 10, false) &gt;&gt; \"in-open-range\"); // (1, 10)\n</code></pre></p>"},{"location":"api/api/#predicate-patterns","title":"Predicate Patterns","text":""},{"location":"api/api/#ptnpredpredicate","title":"<code>ptn::pred(predicate)</code>","text":"<p>Wrap any predicate function as a pattern.</p> <pre><code>template &lt;typename F&gt;\nconstexpr auto pred(F &amp;&amp;f);\n</code></pre> <p>Parameters: <code>predicate</code> - Callable object that accepts one parameter and returns a value convertible to bool</p> <p>Examples: <pre><code>auto is_even = pred([](int x) { return x % 2 == 0; });\nauto is_positive = pred([](int x) { return x &gt; 0; });\n\nmatch(4).when(is_even &gt;&gt; \"even-number\");\nmatch(-5).when(is_positive &gt;&gt; \"positive\");\n</code></pre></p>"},{"location":"api/api/#type-pattern-api","title":"Type Pattern API","text":"<p>Note</p> <p><code>ptn::pat::type::is</code> = <code>ptn::type::is</code> </p>"},{"location":"api/api/#ptnpattypeist","title":"<code>ptn::pat::type::is&lt;T&gt;</code>","text":"<p>Exact type matching pattern.</p> <pre><code>template &lt;typename T&gt;\ninline constexpr detail::is_pattern&lt;T&gt; is{};\n</code></pre> <p>Purpose: Match types identical to the given type</p> <p>Bound Value: The matched value itself</p> <p>Examples: <pre><code>match(42).when(pat::type::is&lt;int&gt; &gt;&gt; \"integer\");\nmatch(3.14).when(pat::type::is&lt;double&gt; &gt;&gt; \"floating-point\");\n\n// Alias in ptn::type namespace\nmatch(42).when(type::is&lt;int&gt; &gt;&gt; \"integer\");\n</code></pre></p>"},{"location":"api/api/#ptnpattypeints","title":"<code>ptn::pat::type::in&lt;Ts...&gt;</code>","text":"<p>Type set matching pattern.</p> <pre><code>template &lt;typename... Ts&gt;\ninline constexpr detail::in_pattern&lt;Ts...&gt; in{};\n</code></pre> <p>Purpose: Match types belonging to any type in the given type set</p> <p>Parameters: <code>Ts...</code> - Type list</p> <p>Bound Value: The matched value itself</p> <p>Examples: <pre><code>match(42).when(pat::type::in&lt;int, long, short&gt; &gt;&gt; \"integral\");\nmatch(3.14f).when(pat::type::in&lt;float, double&gt; &gt;&gt; \"floating\");\n\n// Using alias\nmatch(\"hello\").when(type::in&lt;std::string, std::string_view&gt; &gt;&gt; \"string-like\");\n</code></pre></p>"},{"location":"api/api/#ptnpattypenot_ints","title":"<code>ptn::pat::type::not_in&lt;Ts...&gt;</code>","text":"<p>Type exclusion matching pattern.</p> <pre><code>template &lt;typename... Ts&gt;\ninline constexpr detail::not_in_pattern&lt;Ts...&gt; not_in{};\n</code></pre> <p>Purpose: Match types not belonging to any type in the given type set</p> <p>Parameters: <code>Ts...</code> - Type list to exclude</p> <p>Bound Value: The matched value itself</p> <p>Examples: <pre><code>match(42).when(pat::type::not_in&lt;float, double&gt; &gt;&gt; \"not-floating\");\nmatch(\"hello\").when(pat::type::not_in&lt;int, double&gt; &gt;&gt; \"not-number\");\n\n// Using alias\nmatch(3.14f).when(type::not_in&lt;int, long&gt; &gt;&gt; \"not-integral\");\n</code></pre></p>"},{"location":"api/api/#ptnpattypefromtpl","title":"<code>ptn::pat::type::from&lt;Tpl&gt;</code>","text":"<p>Template specialization matching pattern.</p> <pre><code>template &lt;template &lt;typename...&gt; typename Tpl&gt;\ninline constexpr detail::from_pattern&lt;Tpl&gt; from{};\n</code></pre> <p>Purpose: Match specializations of a specific template</p> <p>Parameters: <code>Tpl</code> - Template name</p> <p>Bound Value: The matched value itself</p> <p>Examples: <pre><code>#include &lt;vector&gt;\n#include &lt;optional&gt;\n#include &lt;map&gt;\n\nstd::vector&lt;int&gt; vec{1, 2, 3};\nstd::optional&lt;std::string&gt; opt = \"hello\";\nstd::map&lt;int, std::string&gt; map{{1, \"one\"}};\n\nmatch(vec).when(pat::type::from&lt;std::vector&gt; &gt;&gt; \"vector\");\nmatch(opt).when(pat::type::from&lt;std::optional&gt; &gt;&gt; \"optional\");\nmatch(map).when(pat::type::from&lt;std::map&gt; &gt;&gt; \"map\");\n\n// Using alias\nmatch(vec).when(type::from&lt;std::vector&gt; &gt;&gt; \"vector\");\n</code></pre></p>"},{"location":"api/api/#dsl-operators-api","title":"DSL Operators API","text":""},{"location":"api/api/#pattern-combination-operators","title":"Pattern Combination Operators","text":""},{"location":"api/api/#pattern1-pattern2-logical-and","title":"<code>pattern1 &amp;&amp; pattern2</code> - Logical AND","text":"<p>Create a combined pattern that satisfies both patterns simultaneously.</p> <pre><code>template &lt;typename L, typename R&gt;\nconstexpr auto operator&amp;&amp;(L &amp;&amp;l, R &amp;&amp;r);\n</code></pre> <p>Examples: <pre><code>auto positive_even = pred([](int x) { return x &gt; 0; }) &amp;&amp; \n                     pred([](int x) { return x % 2 == 0; });\n\nmatch(4).when(positive_even &gt;&gt; \"positive-even\");\nmatch(-2).when(positive_even &gt;&gt; \"not-positive-even\");\n\n// Mix type and value patterns\nmatch(42).when(pat::type::is&lt;int&gt; &amp;&amp; lit(42) &gt;&gt; \"exact-42-int\");\n</code></pre></p>"},{"location":"api/api/#pattern1-pattern2-logical-or","title":"<code>pattern1 || pattern2</code> - Logical OR","text":"<p>Create a combined pattern that satisfies either pattern.</p> <pre><code>template &lt;typename L, typename R&gt;\nconstexpr auto operator||(L &amp;&amp;l, R &amp;&amp;r);\n</code></pre> <p>Examples: <pre><code>auto zero_or_empty = lit(0) || lit(std::optional&lt;int&gt;{});\n\nmatch(0).when(zero_or_empty &gt;&gt; \"zero-or-empty\");\nmatch(std::optional&lt;int&gt;{}).when(zero_or_empty &gt;&gt; \"zero-or-empty\");\n\n// Type combination\nauto numeric = pat::type::is&lt;int&gt; || pat::type::is&lt;double&gt;;\nmatch(42).when(numeric &gt;&gt; \"numeric\");\nmatch(3.14).when(numeric &gt;&gt; \"numeric\");\n</code></pre></p>"},{"location":"api/api/#pattern-logical-not","title":"<code>!pattern</code> - Logical NOT","text":"<p>Create a pattern that does not satisfy the given pattern.</p> <pre><code>template &lt;typename P&gt;\nconstexpr auto operator!(P &amp;&amp;p);\n</code></pre> <p>Examples: <pre><code>auto not_zero = !lit(0);\nauto not_string = !pat::type::is&lt;std::string&gt;;\n\nmatch(5).when(not_zero &gt;&gt; \"not-zero\");\nmatch(42).when(not_string &gt;&gt; \"not-string\");\n</code></pre></p>"},{"location":"api/api/#pattern-handler-binding-operators","title":"Pattern-Handler Binding Operators","text":""},{"location":"api/api/#pattern-handler-pattern-binding","title":"<code>pattern &gt;&gt; handler</code> - Pattern binding","text":"<p>Bind a pattern with a handler function or value.</p> <p>Two modes:</p> <ol> <li> <p>Value handler mode: <pre><code>pattern &gt;&gt; value\n</code></pre>    Automatically creates a handler that returns a fixed value</p> </li> <li> <p>Function handler mode: <pre><code>pattern &gt;&gt; function\n</code></pre>    Directly uses the provided function as the handler</p> </li> </ol> <p>Examples: <pre><code>// Value handler\nmatch(42).when(lit(42) &gt;&gt; \"answer\");  // Returns string \"answer\"\n\n// Function handler\nmatch(42).when(lit(42) &gt;&gt; [](int x) { \n    return x * 2; \n});  // Returns 84\n\n// Handler with binding (type pattern)\nmatch(\"hello\").when(pat::type::is&lt;std::string&gt; &gt;&gt; [](const std::string&amp; s) {\n    return s.length();\n});  // Returns 5\n</code></pre></p>"},{"location":"api/api/#metaprogramming-api","title":"Metaprogramming API","text":""},{"location":"api/api/#basic-type-traits","title":"Basic Type Traits","text":""},{"location":"api/api/#ptnmetaremove_cvref_tt","title":"<code>ptn::meta::remove_cvref_t&lt;T&gt;</code>","text":"<p>Type alias that removes const, volatile, and reference qualifiers.</p> <pre><code>template &lt;typename T&gt;\nusing remove_cvref_t = std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;;\n</code></pre> <p>Example: <pre><code>static_assert(std::is_same_v&lt;\n    ptn::meta::remove_cvref_t&lt;const int&amp;&gt;, \n    int\n&gt;);\n</code></pre></p>"},{"location":"api/api/#ptnmetais_spec_of_vtpl-t","title":"<code>ptn::meta::is_spec_of_v&lt;Tpl, T&gt;</code>","text":"<p>Check if a type is a specialization of a specific template.</p> <pre><code>template &lt;template &lt;typename...&gt; typename Template, typename T&gt;\ninline constexpr bool is_spec_of_v = is_spec_of&lt;Template, T&gt;::value;\n</code></pre> <p>Example: <pre><code>static_assert(ptn::meta::is_spec_of_v&lt;std::vector, std::vector&lt;int&gt;&gt;);\nstatic_assert(!ptn::meta::is_spec_of_v&lt;std::vector, int&gt;);\n</code></pre></p>"},{"location":"api/api/#ptnmetais_tmpl_vt","title":"<code>ptn::meta::is_tmpl_v&lt;T&gt;</code>","text":"<p>Check if a type is a specialization of some template.</p> <pre><code>template &lt;typename T&gt;\ninline constexpr bool is_tmpl_v = is_tmpl&lt;T&gt;::value;\n</code></pre> <p>Example: <pre><code>static_assert(ptn::meta::is_tmpl_v&lt;std::vector&lt;int&gt;&gt;);\nstatic_assert(!ptn::meta::is_tmpl_v&lt;int&gt;);\n</code></pre></p>"},{"location":"api/api/#type-list-operations","title":"Type List Operations","text":""},{"location":"api/api/#ptnmetatype_listts","title":"<code>ptn::meta::type_list&lt;Ts...&gt;</code>","text":"<p>Compile-time type container.</p> <pre><code>template &lt;typename... Ts&gt;\nstruct type_list {\n    static constexpr std::size_t size = sizeof...(Ts);\n};\n</code></pre>"},{"location":"api/api/#list-operation-functions","title":"List Operation Functions","text":""},{"location":"api/api/#contactlist1-list2-concatenate-two-type-lists","title":"<code>contact(list1, list2)</code> - Concatenate two type lists","text":"<pre><code>template &lt;typename... A, typename... B&gt;\nconstexpr auto contact(type_list&lt;A...&gt;, type_list&lt;B...&gt;) -&gt; type_list&lt;A..., B...&gt;;\n</code></pre>"},{"location":"api/api/#appendtlist-add-type-to-end-of-list","title":"<code>append&lt;T&gt;(list)</code> - Add type to end of list","text":"<pre><code>template &lt;typename T, typename... Ts&gt;\nconstexpr auto append(type_list&lt;Ts...&gt;) -&gt; type_list&lt;Ts..., T&gt;;\n</code></pre>"},{"location":"api/api/#prependtlist-add-type-to-beginning-of-list","title":"<code>prepend&lt;T&gt;(list)</code> - Add type to beginning of list","text":"<pre><code>template &lt;typename T, typename... Ts&gt;\nconstexpr auto prepend(type_list&lt;Ts...&gt;) -&gt; type_list&lt;T, Ts...&gt;;\n</code></pre>"},{"location":"api/api/#nth_type_tn-list-get-the-nth-type","title":"<code>nth_type_t&lt;N, list&gt;</code> - Get the Nth type","text":"<pre><code>template &lt;std::size_t N, typename TL&gt;\nusing nth_type_t = typename nth_type&lt;N, TL&gt;::type;\n</code></pre>"},{"location":"api/api/#type-list-algorithms","title":"Type List Algorithms","text":""},{"location":"api/api/#ptnmetaallbs-logical-and-fold","title":"<code>ptn::meta::all&lt;Bs...&gt;</code> - Logical AND fold","text":"<pre><code>template &lt;bool... Bs&gt;\nstruct all : std::bool_constant&lt;(Bs &amp;&amp; ...)&gt; {};\n</code></pre>"},{"location":"api/api/#ptnmetaanybs-logical-or-fold","title":"<code>ptn::meta::any&lt;Bs...&gt;</code> - Logical OR fold","text":"<pre><code>template &lt;bool... Bs&gt;\nstruct any : std::bool_constant&lt;(Bs || ...)&gt; {};\n</code></pre>"},{"location":"api/api/#ptnmetanonebs-logical-not-fold","title":"<code>ptn::meta::none&lt;Bs...&gt;</code> - Logical NOT fold","text":"<pre><code>template &lt;bool... Bs&gt;\nstruct none : std::bool_constant&lt;!any&lt;Bs...&gt;::value&gt; {};\n</code></pre>"},{"location":"api/api/#ptnmetamap_tf-list-apply-metafunction-to-each-type","title":"<code>ptn::meta::map_t&lt;F, list&gt;</code> - Apply metafunction to each type","text":"<pre><code>template &lt;template &lt;typename&gt; typename F, typename TL&gt;\nusing map_t = typename map&lt;F, TL&gt;::type;\n</code></pre>"},{"location":"api/api/#ptnmetafilter_tpred-list-filter-type-list","title":"<code>ptn::meta::filter_t&lt;Pred, list&gt;</code> - Filter type list","text":"<pre><code>template &lt;template &lt;typename&gt; typename Pred, typename TL&gt;\nusing filter_t = typename filter&lt;Pred, TL&gt;::type;\n</code></pre>"},{"location":"api/api/#query-operations","title":"Query Operations","text":""},{"location":"api/api/#ptnmetacontains_vt-list-check-if-type-is-in-list","title":"<code>ptn::meta::contains_v&lt;T, list&gt;</code> - Check if type is in list","text":"<pre><code>template &lt;typename T, typename TL&gt;\ninline constexpr bool contains_v = contains&lt;T, TL&gt;::value;\n</code></pre>"},{"location":"api/api/#ptnmetaindex_of_vt-list-get-index-of-type-in-list","title":"<code>ptn::meta::index_of_v&lt;T, list&gt;</code> - Get index of type in list","text":"<pre><code>template &lt;typename T, typename TL&gt;\ninline constexpr int index_of_v = index_of&lt;T, TL&gt;::value;\n</code></pre> <p>Returns: Index of the type in the list, returns -1 if not found</p>"},{"location":"api/api/#template-information-queries","title":"Template Information Queries","text":""},{"location":"api/api/#ptnmetatemplate_infot","title":"<code>ptn::meta::template_info&lt;T&gt;</code>","text":"<p>Extract template specialization information.</p> <pre><code>template &lt;typename T&gt;\nstruct template_info {\n    static constexpr bool is_specialization = false;\n    using args = type_list&lt;&gt;;\n    // Non-template types don't have rebind\n};\n</code></pre> <p>Specialization version: <pre><code>template &lt;template &lt;typename...&gt; typename Template, typename... Args&gt;\nstruct template_info&lt;Template&lt;Args...&gt;&gt; {\n    static constexpr bool is_specialization = true;\n    using args = type_list&lt;Args...&gt;;\n\n    template &lt;typename... Us&gt;\n    using rebind = Template&lt;Us...&gt;;\n};\n</code></pre></p> <p>Example: <pre><code>using info = ptn::meta::template_info&lt;std::vector&lt;int&gt;&gt;;\nstatic_assert(info.is_specialization);\nusing args = info.args;  // type_list&lt;int&gt;\nusing new_vec = info::template rebind&lt;double&gt;;  // std::vector&lt;double&gt;\n</code></pre></p>"},{"location":"api/api/#complete-examples","title":"Complete Examples","text":""},{"location":"api/api/#basic-usage-examples","title":"Basic Usage Examples","text":"<pre><code>#include \"ptn/patternia.hpp\"\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;optional&gt;\n\nusing namespace ptn;\nusing namespace ptn::pat::value;\nusing namespace ptn::pat::type;\n\nvoid basic_examples() {\n    // 1. Simple value matching\n    int x = 42;\n    auto result1 = match(x)\n        .when(lit(42) &gt;&gt; \"answer to everything\")\n        .when(lit(0) &gt;&gt; \"zero\")\n        .otherwise(\"other number\");\n\n    // 2. Relational patterns\n    double score = 85.5;\n    auto result2 = match(score)\n        .when(ge(90) &gt;&gt; 'A')\n        .when(ge(80) &gt;&gt; 'B')\n        .when(ge(70) &gt;&gt; 'C')\n        .when(ge(60) &gt;&gt; 'D')\n        .otherwise('F');\n\n    // 3. Type patterns\n    std::variant&lt;int, std::string, double&gt; var = std::string(\"hello\");\n    auto result3 = match(var)\n        .when(type::is&lt;int&gt; &gt;&gt; [](int i) { return i * 2; })\n        .when(type::is&lt;std::string&gt; &gt;&gt; [](const std::string&amp; s) { return s.length(); })\n        .when(type::is&lt;double&gt; &gt;&gt; [](double d) { return static_cast&lt;int&gt;(d); });\n\n    std::cout &lt;&lt; \"Result 1: \" &lt;&lt; result1 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Result 2: \" &lt;&lt; result2 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Result 3: \" &lt;&lt; result3 &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"api/api/#complex-pattern-combination-examples","title":"Complex Pattern Combination Examples","text":"<pre><code>void complex_patterns() {\n    // 1. Combined pattern: positive even numbers\n    auto positive_even = pred([](int x) { return x &gt; 0; }) &amp;&amp; \n                         pred([](int x) { return x % 2 == 0; });\n\n    // 2. Range pattern: numbers between 10 and 20\n    auto in_range = between(10, 20);\n\n    // 3. Type combination: numeric types\n    auto numeric = type::is&lt;int&gt; || type::is&lt;double&gt; || type::is&lt;float&gt;;\n\n    // 4. Complex matching chain\n    auto result = match(15)\n        .when(positive_even &gt;&gt; \"positive even\")\n        .when(in_range &amp;&amp; type::is&lt;int&gt; &gt;&gt; \"integer in range\")\n        .when(numeric &gt;&gt; \"some number\")\n        .otherwise(\"other\");\n\n    // 5. Container type matching\n    std::vector&lt;int&gt; vec{1, 2, 3};\n    std::optional&lt;std::string&gt; opt = \"optional value\";\n    std::map&lt;int, std::string&gt; map{{1, \"one\"}};\n\n    auto container_type = [&amp;](auto&amp;&amp; container) {\n        return match(container)\n            .when(type::from&lt;std::vector&gt; &gt;&gt; \"vector\")\n            .when(type::from&lt;std::optional&gt; &gt;&gt; \"optional\")\n            .when(type::from&lt;std::map&gt; &gt;&gt; \"map\")\n            .otherwise(\"unknown container\");\n    };\n\n    std::cout &lt;&lt; \"Complex result: \" &lt;&lt; result &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Vec type: \" &lt;&lt; container_type(vec) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Opt type: \" &lt;&lt; container_type(opt) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Map type: \" &lt;&lt; container_type(map) &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"api/api/#string-processing-examples","title":"String Processing Examples","text":"<pre><code>void string_examples() {\n    std::string input = \"Hello\";\n\n    auto result = match(input)\n        .when(lit_ci(\"hello\") &gt;&gt; \"greeting (case insensitive)\")\n        .when(lit(\"world\") &gt;&gt; \"world\")\n        .when(pred([](const std::string&amp; s) { return s.length() &gt; 5; }) &gt;&gt; \"long string\")\n        .otherwise(\"other string\");\n\n    std::cout &lt;&lt; \"String result: \" &lt;&lt; result &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"api/api/#enum-and-user-type-examples","title":"Enum and User Type Examples","text":"<pre><code>enum class Status {\n    Active,\n    Inactive,\n    Pending,\n    Error\n};\n\nstruct User {\n    std::string name;\n    Status status;\n    int age;\n};\n\nvoid custom_types_example() {\n    Status status = Status::Active;\n    auto status_result = match(status)\n        .when(lit(Status::Active) &gt;&gt; \"user is active\")\n        .when(lit(Status::Inactive) &gt;&gt; \"user is inactive\")\n        .when(lit(Status::Pending) &gt;&gt; \"user is pending\")\n        .when(lit(Status::Error) &gt;&gt; \"error state\");\n\n    User user{\"Alice\", Status::Active, 25};\n    auto user_result = match(user)\n        .when(pred([](const User&amp; u) { return u.status == Status::Active &amp;&amp; u.age &gt;= 18; }) \n              &gt;&gt; \"active adult user\")\n        .when(pred([](const User&amp; u) { return u.status == Status::Pending; }) \n              &gt;&gt; \"pending user\")\n        .otherwise(\"other user\");\n\n    std::cout &lt;&lt; \"Status: \" &lt;&lt; status_result &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"User: \" &lt;&lt; user_result &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"api/api/#performance-analysis-examples","title":"Performance Analysis Examples","text":"<pre><code>void performance_analysis() {\n    // Compile-time optimization: all matches determined at compile time\n    constexpr auto get_description = [](int value) constexpr {\n        return match(value)\n            .when(lit(0) &gt;&gt; \"zero\")\n            .when(lit(1) &gt;&gt; \"one\")\n            .when(lit(2) &gt;&gt; \"two\")\n            .when(pred([](int x) { return x &gt; 2; }) &gt;&gt; \"greater than two\")\n            .otherwise(\"negative\");\n    };\n\n    static_assert(get_description(0) == \"zero\");\n    static_assert(get_description(3) == \"greater than two\");\n\n    // Runtime usage\n    for (int i = -1; i &lt;= 3; ++i) {\n        std::cout &lt;&lt; i &lt;&lt; \": \" &lt;&lt; get_description(i) &lt;&lt; '\\n';\n    }\n}\n</code></pre>"},{"location":"api/api/#metaprogramming-usage-examples","title":"Metaprogramming Usage Examples","text":"<pre><code>void metaprogramming_examples() {\n    // Using type lists\n    using numeric_types = ptn::meta::type_list&lt;int, float, double&gt;;\n\n    // Check if type is in list\n    static_assert(ptn::meta::contains_v&lt;int, numeric_types&gt;);\n    static_assert(!ptn::meta::contains_v&lt;std::string, numeric_types&gt;);\n\n    // Get type index\n    static_assert(ptn::meta::index_of_v&lt;double, numeric_types&gt; == 2);\n    static_assert(ptn::meta::index_of_v&lt;char, numeric_types&gt; == -1);\n\n    // Template information query\n    using vec_int_info = ptn::meta::template_info&lt;std::vector&lt;int&gt;&gt;;\n    static_assert(vec_int_info::is_specialization);\n    using vec_args = vec_int_info::args;  // type_list&lt;int, std::allocator&lt;int&gt;&gt;\n\n    // Rebind template parameters\n    using vec_double = vec_int_info::template rebind&lt;double&gt;;  // std::vector&lt;double&gt;\n\n    // Compile-time algorithms\n    static_assert(ptn::meta::all&lt;true, true, false&gt;::value == false);\n    static_assert(ptn::meta::any&lt;true, false, false&gt;::value == true);\n    static_assert(ptn::meta::none&lt;false, false&gt;::value == true);\n}\n</code></pre>"},{"location":"api/api/#complete-comprehensive-example","title":"Complete Comprehensive Example","text":"<pre><code>#include \"ptn/patternia.hpp\"\n#include &lt;iostream&gt;\n#include &lt;variant&gt;\n#include &lt;vector&gt;\n#include &lt;optional&gt;\n#include &lt;map&gt;\n\nusing namespace ptn;\nusing namespace ptn::pat::value;\nusing namespace ptn::pat::type;\n\nclass PatterniaDemo {\npublic:\n    void runAllExamples() {\n        std::cout &lt;&lt; \"=== Patternia API Examples ===\\n\\n\";\n\n        basic_examples();\n        std::cout &lt;&lt; '\\n';\n\n        complex_patterns();\n        std::cout &lt;&lt; '\\n';\n\n        string_examples();\n        std::cout &lt;&lt; '\\n';\n\n        custom_types_example();\n        std::cout &lt;&lt; '\\n';\n\n        performance_analysis();\n        std::cout &lt;&lt; '\\n';\n\n        std::cout &lt;&lt; \"=== All Examples Complete ===\\n\";\n    }\n};\n\nint main() {\n    PatterniaDemo demo;\n    demo.runAllExamples();\n    return 0;\n}\n</code></pre>"},{"location":"api/api/#api-feature-summary","title":"API Feature Summary","text":""},{"location":"api/api/#type-safety","title":"Type Safety","text":"<ul> <li>All pattern matching is compile-time type safe</li> <li>Support for heterogeneous comparisons (comparisons between different types)</li> <li>Automatic type deduction and explicit type specification</li> </ul>"},{"location":"api/api/#performance-optimization","title":"Performance Optimization","text":"<ul> <li>Zero runtime overhead abstractions</li> <li>Compile-time pattern combination optimization</li> <li>Support for constant expression evaluation</li> </ul>"},{"location":"api/api/#extensibility","title":"Extensibility","text":"<ul> <li>CRTP-based pattern base classes</li> <li>Easy to add custom pattern types</li> <li>Support for custom comparators and predicates</li> </ul>"},{"location":"api/api/#expressiveness","title":"Expressiveness","text":"<ul> <li>Rich built-in pattern types</li> <li>Intuitive DSL syntax</li> <li>Support for complex pattern combinations</li> </ul>"},{"location":"api/api/#compatibility","title":"Compatibility","text":"<ul> <li>Support for C++17 and C++20</li> <li>Modular header file design</li> <li>Configurable feature switches</li> </ul> <p>This complete API reference covers all public interfaces of the Patternia library, including internal and external APIs, and provides comprehensive example code. You can use this documentation to write GitHub Pages documentation and README files.</p>"},{"location":"guide/getting-started/","title":"Getting Started","text":"<p>Patternia is a header-only library. Once installed or fetched into your project, you can start using pattern matching immediately.</p> <p>Below is the minimal working example demonstrating the core DSL:</p>"},{"location":"guide/getting-started/#optional-recommended-code-style","title":"Optional: Recommended Code Style","text":"<p>To keep your chained <code>.when()</code> and <code>.otherwise()</code> expressions visually aligned and easy to scan, you can add a minimal <code>.clang-format</code> to your project root:</p> <pre><code># patternia .clang-format (minimal)\nBasedOnStyle: LLVM\nIndentWidth: 2            # or 4\nContinuationIndentWidth: 4 # or 6\nColumnLimit: 0\nBinPackArguments: false\nBinPackParameters: false\nBreakBeforeBinaryOperators: None\n</code></pre> <p>With this style, multi-line match expressions remain clean and consistent:</p> <pre><code>auto out =\n    match(5)\n      .when(lt(0) &gt;&gt; \"neg\")\n      .when(gt(0) &gt;&gt; \"pos\")\n      .otherwise(\"other\");\n</code></pre>"},{"location":"guide/getting-started/#basic-example","title":"Basic Example","text":"<pre><code>#include &lt;ptn/patternia.hpp&gt;\n#include &lt;iostream&gt;\nusing namespace ptn;\n\nint main() {\n  int x = 42;\n\n  auto result =\n    match(x)\n      .when(lit(0)       &gt;&gt; \"zero\")\n      .when(lit(42)      &gt;&gt; \"answer to everything\")\n      .when(pred([](int v){ return v % 2 == 0; }) &gt;&gt; \"even\")\n      .otherwise(\"other\");\n\n  std::cout &lt;&lt; result &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>answer to everything\n</code></pre>"},{"location":"guide/getting-started/#type-based-matching","title":"Type-based Matching","text":"<p>Patternia provides a type layer for matching based on static type.</p> <pre><code>std::variant&lt;int, float, std::string&gt; v = 3.14f;\n\nauto out = match(v)\n  .when(type::is&lt;int&gt;    &gt;&gt; \"int\")\n  .when(type::is&lt;float&gt;  &gt;&gt; \"float\")\n  .when(type::is&lt;std::string&gt; &gt;&gt; \"string\")\n  .otherwise(\"unknown\");\n</code></pre>"},{"location":"guide/getting-started/#relational-patterns","title":"Relational Patterns","text":"<p>Patternia\u2019s relational DSL (<code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>) works on any comparable value.</p> <pre><code>int score = 87;\n\nauto grade = match(score)\n  .when(lt(60)             &gt;&gt; \"F\") // less than\n  .when(ge(90)             &gt;&gt; \"A\") // greater equal\n  .when(ge(80)             &gt;&gt; \"B\")\n  .when(ge(70)             &gt;&gt; \"C\")\n  .otherwise(\"D\");\n</code></pre>"},{"location":"guide/getting-started/#predicates","title":"Predicates","text":"<p>Arbitrary logic can be wrapped into concise predicate patterns:</p> <pre><code>auto res = match(x)\n  .when(pred([](int v){ return v % 2 == 1; }) &gt;&gt; \"odd\")\n  .otherwise(\"even\");\n</code></pre>"},{"location":"guide/getting-started/#case-insensitive-matching","title":"Case-insensitive matching","text":"<pre><code>std::string s = \"Ok\";\n\nauto out = match(s)\n  .when(lit_ci(\"OK\") &gt;&gt; \"accepted\")\n  .otherwise(\"rejected\");\n</code></pre>"},{"location":"guide/getting-started/#no-macros-no-reflection-no-magic","title":"No macros. No reflection. No magic","text":"<p>Patternia compiles down to normal C++ control flow using inlined pattern objects. There is no runtime overhead beyond executing the selected handler.</p>"},{"location":"guide/installation/","title":"Installation","text":"<p>Patternia is a header-only C++ library. There is no build system, no linking step, and no external dependency.</p> <p>You can integrate Patternia into your project in any of the following ways.</p>"},{"location":"guide/installation/#1-recommended-fetch-patternia-automatically","title":"1. Recommended: Fetch Patternia automatically","text":"<p>You may choose to fetch Patternia as a remote dependency during configuration.</p> <p>FetchContent:</p> <pre><code>include(FetchContent)\nFetchContent_Declare(patternia\n  GIT_REPOSITORY https://github.com/sentomk/patternia.git\n  GIT_TAG main\n)\nFetchContent_MakeAvailable(patternia)\n\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>CPM.cmake:</p> <pre><code>CPMAddPackage(\"gh:sentomk/patternia@main\")\n</code></pre> <p>This fits well in reproducible CI pipelines and modern CMake workflows.</p>"},{"location":"guide/installation/#2-install-and-consume-via-find_package","title":"2. Install and consume via <code>find_package()</code>","text":"<p>Patternia provides full CMake package export support.</p> <p>Install:</p> <pre><code>cmake -B build\ncmake --build build\ncmake --install build --prefix /path/to/install\n</code></pre> <p>Use in any project:</p> <pre><code>find_package(patternia REQUIRED)\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>This is the recommended method for system-wide integration, packaging, and distribution.</p>"},{"location":"guide/installation/#3-add-patternia-as-a-git-submodule","title":"3. Add Patternia as a Git submodule","text":"<pre><code>git submodule add https://github.com/sentomk/patternia extern/patternia\n</code></pre> <p>Then in your CMake project:</p> <pre><code>add_subdirectory(extern/patternia)\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>This approach keeps Patternia version-controlled inside your repository and works well for mid- to large-scale projects.</p>"},{"location":"guide/installation/#4-include-the-include-directory-directly","title":"4. Include the <code>include/</code> directory directly","text":"<p>This is the simplest approach. Just add Patternia\u2019s header path to your target:</p> <pre><code>target_include_directories(your_target\n  PRIVATE /path/to/patternia/include\n)\n</code></pre> <p>No configuration, no installation, immediately usable.</p>"},{"location":"patterns/foreword/","title":"Pattern System Architecture","text":"<p>Patternia is built around a single architectural idea: matching should be a first-class, composable, zero-overhead operation in C++.</p> <p>Most C++ projects rely heavily on hand-written branching logic\u2014nested <code>if</code> statements, large <code>switch</code> blocks, duplicated comparisons, and one-off helper functions. These mechanisms are powerful but structurally limited:</p> <ul> <li>Logic becomes scattered across functions.  </li> <li>Conditions cannot be abstracted or composed easily.  </li> <li>Type-dependent paths require RTTI or explicit <code>dynamic_cast</code>.  </li> <li>Value-dependent paths become deeply imperative and repetitive.  </li> <li>Maintenance requires editing many disconnected branches.</li> </ul> <p>Patternia introduces a dedicated Pattern System to unify these forms of branching under a single semantic model.</p> <p>At its core, a Pattern is an object that describes a condition, and the system determines how to evaluate that condition safely and efficiently. All patterns\u2014whether they describe a value, a predicate, or a type\u2014share the same conceptual role:</p> <ol> <li> <p>Describe a match rule.    A pattern encapsulates the logic for deciding whether a subject satisfies a condition.</p> </li> <li> <p>Compose into larger rules.    Patterns form an algebra: they can be combined into richer logic without changing control flow.</p> </li> <li> <p>Participate in the matching pipeline.    The system evaluates patterns in sequence and invokes handlers for the first matching rule.</p> </li> </ol> <p>The Pattern System is not an auxiliary feature. It is the architectural foundation on which the entire library\u2014value dispatch, type dispatch, and later variant dispatch\u2014is built.</p> <p>This chapter examines the architectural model of the Pattern System and clarifies how different pattern categories cooperate to define matching behavior. The discussion begins with value patterns and type patterns as foundational components.</p> <ul> <li>Value Patterns </li> <li>Type Patterns</li> </ul> <p>Their APIs appear elsewhere; here we focus on their design purpose, abstraction model, and role within the match pipeline.</p>"},{"location":"patterns/type/","title":"Type Patterns \u2014 Architectural Perspective","text":"<p>Type Patterns define the part of the Pattern System dedicated to type-level dispatch. They describe conditions about what a value is, rather than how it behaves or what its runtime value contains.</p> <p>They solve a central architectural problem in C++ codebases:</p> <p>How do we express type-dependent logic without RTTI, virtual inheritance, or manual <code>if constexpr</code> chains?</p> <p>Type Patterns provide a unified answer.</p>"},{"location":"patterns/type/#1-type-level-semantics-as-first-class-objects","title":"1. Type-Level Semantics as First-Class Objects","text":"<p>In typical C++ systems, type-specific logic is embedded in:</p> <ul> <li>Template specializations  </li> <li><code>std::variant</code> visitor lambdas  </li> <li>Chains of <code>if constexpr (std::is_same_v&lt;T, ...&gt;)</code> </li> <li>RTTI (<code>typeid</code>, <code>dynamic_cast</code>)  </li> </ul> <p>These mechanisms work but lack a uniform abstraction for type conditions.</p> <p>Type Patterns elevate type checks to first-class pattern objects, enabling the same:</p> <ul> <li>Composition  </li> <li>Reuse  </li> <li>Declarative structure  </li> </ul> <p>that Value Patterns provide for runtime data.</p>"},{"location":"patterns/type/#2-zero-cost-type-dispatch","title":"2. Zero-Cost Type Dispatch","text":"<p>All type decisions in Patternia are resolved through normal C++ type inspection and inlining. The Pattern System introduces:</p> <ul> <li>No RTTI  </li> <li>No virtual calls  </li> <li>No runtime type discrimination  </li> <li>No dynamic polymorphism  </li> </ul> <p>By making type checks structural (not reflective), Patternia provides the performance profile needed for high-throughput or low-latency applications.</p>"},{"location":"patterns/type/#3-unifying-value-and-type-domains","title":"3. Unifying Value and Type Domains","text":"<p>A key architectural goal is that Value Patterns and Type Patterns participate in the same matching pipeline.</p> <p>This allows rules such as:</p> <ul> <li>\"If the subject is an <code>int</code> and greater than zero\u2026\"  </li> <li>\"If the subject is a <code>std::string</code> and equals 'start'\u2026\"  </li> <li>\"If the subject is from this template family and satisfies a numeric guard\u2026\"</li> </ul> <p>The system does not treat type and value as separate languages. They are part of one cohesive pattern algebra.</p>"},{"location":"patterns/type/#4-foundation-for-variant-dispatch","title":"4. Foundation for Variant Dispatch","text":"<p>The upcoming Variant Layer relies directly on Type Patterns.</p> <p>Matching an active alternative of <code>std::variant</code> is fundamentally a type-level operation:</p> <ul> <li>If the active type is <code>T</code>\u2026  </li> <li>If the active type belongs to <code>{A, B, C}</code>\u2026  </li> <li>If the alternative is any specialization of a template family\u2026</li> </ul> <p>Type Patterns make these decisions explicit and reusable.</p> <p>In other words, they are not an optional feature; they are a structural part of the library\u2019s dispatch model.</p>"},{"location":"patterns/type/#summary","title":"Summary","text":"<p>Architecturally, Type Patterns:</p> <ul> <li>Represent type-based semantics independently of runtime values  </li> <li>Provide a uniform abstraction for type dispatch  </li> <li>Integrate with the same compositional model used by Value Patterns  </li> <li>Enable zero-overhead matching  </li> <li>Form the basis for variant-aware pattern layers</li> </ul> <p>They are the type-theoretic pillar of Patternia\u2019s Pattern System.</p>"},{"location":"patterns/value/","title":"Value Patterns \u2014 Architectural Perspective","text":"<p>Value Patterns represent the part of the Pattern System concerned with runtime values. They describe conditions on concrete data: numbers, strings, states, commands, and any object that can be inspected without involving its type structure.</p> <p>From an architectural perspective, Value Patterns serve three core roles:</p>"},{"location":"patterns/value/#1-unifying-value-level-logic","title":"1. Unifying Value-Level Logic","text":"<p>In conventional C++, comparisons and conditions are expressed through imperative constructs:</p> <ul> <li><code>if (x == 42)</code> </li> <li><code>if (size &lt; capacity)</code> </li> <li><code>if (name == \"start\")</code> </li> <li><code>if (x &gt; 0 &amp;&amp; x &lt; 10)</code> </li> </ul> <p>Each condition is tied to surrounding control flow. Value Patterns decouple the expression of conditions from the control structure that uses them.</p> <p>As a result:</p> <ul> <li>Value conditions become reusable units.</li> <li>Complex value logic becomes declarative\u2014described, not executed.</li> <li>Matching rules become centralized and maintainable.</li> </ul>"},{"location":"patterns/value/#2-enabling-compositional-semantics","title":"2. Enabling Compositional Semantics","text":"<p>Patterns obey a formal algebra. Value Patterns can be combined with logical operators to describe richer semantics without duplicating comparisons or control logic.</p> <p>This provides architectural benefits:</p> <ul> <li>Conditions become first-class objects.  </li> <li>Rules can be assembled, reused, refined, or shared across modules.  </li> <li>Large matching systems can be built from small, orthogonal components.</li> </ul> <p>This capability is essential as the library grows toward supporting predicate guards, custom user-defined patterns, and domain-specific pattern sets.</p>"},{"location":"patterns/value/#3-integrating-with-the-match-pipeline","title":"3. Integrating with the Match Pipeline","text":"<p>At match time, Value Patterns participate in a common evaluation pipeline:</p> <ol> <li>The subject is passed to each pattern.  </li> <li>The pattern decides, independently, whether the subject satisfies its rule.  </li> <li>A matching pattern triggers a handler and short-circuits evaluation.</li> </ol> <p>Value Patterns do not influence the structure of evaluation\u2014only the semantics of the condition. This separation of responsibilities keeps the system modular and allows different pattern families to coexist imperatively.</p>"},{"location":"patterns/value/#summary","title":"Summary","text":"<p>Architecturally, Value Patterns:</p> <ul> <li>Represent value-level semantics in declarative form  </li> <li>Promote reusable, composable conditions  </li> <li>Integrate seamlessly into the shared match pipeline  </li> <li>Prepare the ground for higher-level constructs (predicates, guards, domain-specific rules)</li> </ul> <p>They are the foundational layer of runtime data dispatch in Patternia.</p>"}]}