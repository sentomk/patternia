{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Patternia Documentation","text":"<p>A modern C++ pattern matching DSL</p> <p>Patternia is a modern C++ pattern-matching DSL designed to make dispatch logic clear, expressive, and type-safe \u2014 without sacrificing performance or compilation efficiency.</p>"},{"location":"#navigation","title":"Navigation","text":""},{"location":"#quick-start","title":"Quick Start","text":"<ul> <li>Installation - How to integrate Patternia into your project</li> <li>Getting Started - Complete examples from basics to advanced</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>API Documentation - Complete API reference for all functions and patterns</li> </ul>"},{"location":"#project-information","title":"Project Information","text":"<ul> <li>Releases - Version update history</li> </ul>"},{"location":"#system-requirements","title":"System Requirements","text":"<ul> <li>C++ Standard: C++17 or later</li> <li>Compilers: GCC \u226511, Clang \u226512, MSVC \u22652019</li> <li>Platforms: Linux, Windows, macOS</li> </ul> Make logical structure explicit, make C++ code more elegant"},{"location":"api/","title":"Patternia API Reference","text":""},{"location":"api/#introduction","title":"Introduction","text":"<p>Patternia provides a comprehensive pattern matching system for C++ with a focus on type safety, performance, and expressiveness. This document outlines the core APIs that constitute Patternia's pattern matching language.</p>"},{"location":"api/#i-match-dsl-core-framework","title":"I. Match DSL Core Framework","text":"<p>The Match DSL forms the foundation of Patternia. It defines how values are inspected, how cases are registered, and how matching is ultimately evaluated.</p>"},{"location":"api/#matchsubject","title":"<code>match(subject)</code>","text":"<p>Role: DSL entry point and evaluation context for the entire system.</p> <p>Syntax: <pre><code>match(subject)\nmatch&lt;AsType&gt;(subject)\n</code></pre></p> <p>Core Characteristics:</p> <ul> <li><code>subject</code> is the value being matched, not an implicitly captured variable</li> <li><code>match()</code> returns a builder object; no matching is performed immediately</li> <li>Cases are evaluated sequentially using first-match semantics</li> </ul> <p>Basic Usage:</p> <pre><code>match(x)\n  .when(lit(1) &gt;&gt; [] { return \"one\"; })\n  .otherwise(\"default\");\n</code></pre> <p>Type Control:</p> <pre><code>// Automatic type deduction\nint x = 42;\nmatch(x);   // subject matched as int\n\n// Explicit matching view\ndouble d = 3.14;\nmatch&lt;int&gt;(d);  // subject is matched as int\n</code></pre> <p>Specifying <code>AsType</code> explicitly forces the subject to be viewed as that type during pattern evaluation.</p>"},{"location":"api/#whenpattern-handler","title":"<code>.when(pattern &gt;&gt; handler)</code>","text":"<p>Role: Primary case-definition primitive.</p> <p>Syntax:</p> <pre><code>.when(pattern &gt;&gt; handler)\n</code></pre> <p>Key Characteristics:</p> <ul> <li><code>pattern &gt;&gt; handler</code> forms a case expression</li> <li>The handler\u2019s parameter list is determined entirely by the pattern\u2019s binding behavior</li> <li><code>.when()</code> only registers a branch; it does not trigger execution</li> </ul> <p>Usage Examples:</p> <pre><code>// Handler without bindings\n.when(lit(1) &gt;&gt; [] { return \"one\"; })   // No parameters\n.when(lit(2) &gt;&gt; 42)                     // Constant value handler\n\n// Handler with bindings\n.when(bind() &gt;&gt; [](int v) {\n  return v * 2;\n})\n\n// Structural bindings\n.when(\n  bind(has&lt;&amp;Point::x, &amp;Point::y&gt;()) &gt;&gt;\n  [](int x, int y) {\n    return x + y;\n  }\n)\n</code></pre> <p>Handler Forms:</p> <ul> <li> <p>Value Handler \u2014 <code>pattern &gt;&gt; value</code>   Returns a fixed value. Semantically equivalent to a zero-argument function returning a constant.</p> </li> <li> <p>Function Handler \u2014 <code>pattern &gt;&gt; callable</code>   Receives the values produced by the pattern\u2019s bindings.</p> </li> </ul>"},{"location":"api/#otherwise-and-end","title":"<code>.otherwise(...)</code> and <code>.end()</code>","text":"<p>These terminal operations define how a match expression is finalized. They represent a deliberate design distinction in Patternia and must be chosen explicitly.</p>"},{"location":"api/#otherwise","title":"<code>.otherwise(...)</code>","text":"<p>Trigger Condition: Executed only if no prior <code>when</code> clause matches successfully.</p> <p>Purpose: Enables expression-style matching with a guaranteed fallback.</p> <p>Characteristics:</p> <ul> <li>Must return a type consistent with all other branches</li> <li>Acts as a defensive default, not as a regular case</li> <li>Evaluated only if no pattern has already matched</li> </ul> <pre><code>auto r = match(x)\n  .when(lit(1) &gt;&gt; 10)\n  .otherwise(0);\n</code></pre> <p>Execution Semantics:</p> <pre><code>auto result = match(42)\n  .when(lit(1) &gt;&gt; \"one\")      // No match\n  .when(lit(2) &gt;&gt; \"two\")      // No match\n  .when(__ &gt;&gt; \"other\")        // Matches here\n  .otherwise(\"default\");      // Not executed\n</code></pre>"},{"location":"api/#end","title":"<code>.end()</code>","text":"<p>Purpose: Terminates a statement-style match.</p> <p>Characteristics:</p> <ul> <li>All handlers must return <code>void</code></li> <li>No fallback branch is permitted</li> <li>Requires the set of patterns to be exhaustive</li> </ul> <pre><code>match(x)\n  .when(lit(1) &gt;&gt; [] { log(\"one\"); })\n  .when(__   &gt;&gt; [] { log(\"other\"); })\n  .end();\n</code></pre> <p>If no pattern matches and <code>.end()</code> is used, the program is ill-formed. This failure is detected at compile time.</p> <p>Design Philosophy: Patternia explicitly separates expression-oriented matching from statement-oriented control flow, rather than overloading a single construct with both semantics.</p>"},{"location":"api/#comparison-summary","title":"Comparison Summary","text":"Feature <code>.otherwise()</code> <code>.end()</code> Match Style Expression-oriented Statement-oriented Return Type Handler-determined <code>void</code> Failure Mode Runtime fallback Compile-time error Typical Use Value computation Side-effect execution"},{"location":"api/#ii-pattern-primitives","title":"II. Pattern Primitives","text":"<p>Pattern primitives constitute the core vocabulary of Patternia\u2019s pattern language. They describe what is matched, what is ignored, and what is explicitly bound.</p>"},{"location":"api/#litvalue","title":"<code>lit(value)</code>","text":"<p>Role: Fundamental value pattern for exact matching.</p> <p>Syntax: <pre><code>template &lt;typename V&gt;\nconstexpr auto lit(V &amp;&amp;v);\n\ntemplate &lt;typename V&gt;\nconstexpr auto lit_ci(V &amp;&amp;v);  // Case-insensitive matching\n</code></pre></p> <p>Semantics:</p> <ul> <li>Matches the subject using <code>operator==</code></li> <li>Produces no bindings</li> <li>Intended for value-based discrimination</li> </ul> <p>Examples:</p> <pre><code>.when(lit(Status::Running) &gt;&gt; ...)   // Enum matching\n.when(lit(42) &gt;&gt; ...)                // Integer literal\n.when(lit_ci(\"hello\") &gt;&gt; ...)        // Case-insensitive string match\n</code></pre> <p>Supported Types:</p> <ul> <li>Arithmetic types (<code>int</code>, <code>double</code>, <code>float</code>)</li> <li>Enumeration types</li> <li>String types (<code>std::string</code>, <code>std::string_view</code>, <code>const char*</code>)</li> <li>User-defined types providing <code>operator==</code></li> </ul>"},{"location":"api/#__-wildcard","title":"<code>__</code> (Wildcard)","text":"<p>Role: Pattern-level wildcard that matches any value without binding.</p> <p>Syntax:</p> <pre><code>inline constexpr detail::wildcard_t __;\n</code></pre> <p>Key Properties:</p> <ul> <li>Always matches</li> <li>Introduces no bindings</li> <li>Participates in pattern ordering and exhaustiveness</li> </ul> <pre><code>.when(__ &gt;&gt; [] {\n  // No access to the matched value\n})\n</code></pre> <p>Design Intent:</p> <pre><code>match(value)\n  .when(lit(\"success\") &gt;&gt; \"ok\")\n  .when(lit(\"error\")   &gt;&gt; \"fail\")\n  .when(__             &gt;&gt; \"unknown\")  // Pattern-level fallback\n  .otherwise(\"fallback\");              // Expression-level fallback\n</code></pre> <p>Key Distinction:</p> <ul> <li><code>__</code> \u2014 a pattern that participates in matching and ordering</li> <li><code>.otherwise()</code> \u2014 a match-level fallback executed only if no pattern matches</li> </ul>"},{"location":"api/#bind-binding-pattern","title":"<code>bind()</code> (Binding Pattern)","text":"<p>Role: Explicit value binding primitive.</p> <p><code>bind()</code> is the only mechanism in Patternia that introduces bindings into a match.</p> <p>Syntax:</p> <pre><code>constexpr auto bind();                    // Binds the entire subject\n\ntemplate &lt;typename SubPattern&gt;\nconstexpr auto bind(SubPattern &amp;&amp;sub);    // Binds subject conditionally under a subpattern constraint\n</code></pre> <p>Core Principles:</p> <ol> <li>All bindings are explicit</li> <li>No pattern introduces bindings implicitly</li> <li>Binding behavior fully determines handler parameter lists</li> </ol>"},{"location":"api/#binding-the-entire-subject","title":"Binding the Entire Subject","text":"<pre><code>.when(bind() &gt;&gt; [](auto v) {\n  return \"captured: \" + std::to_string(v);\n})\n</code></pre> <ul> <li>The entire subject is bound as a single value</li> <li>The handler receives exactly one parameter</li> </ul>"},{"location":"api/#conditional-binding-with-bindsubpattern","title":"Conditional Binding with <code>bind(subpattern)</code>","text":"<pre><code>.when(\n  bind(lit(Status::Running)) &gt;&gt;\n  [](Status s) {\n    return fmt(\"status = {}\", static_cast&lt;int&gt;(s));\n  }\n)\n````\n\n* `bind(subpattern)` introduces a binding **only if the subpattern matches**\n* The bound value is always the **entire subject**\n* The subpattern itself does **not** introduce bindings unless explicitly designed to do so\n\nThis form is useful when:\n\n* a value must be both **filtered** and **captured**\n* the captured value needs to be reused by the handler\n* the constraint is semantic rather than structural\n\n\n#### Structural Binding with `has&lt;&gt;`\n\n```cpp\nstruct Point { int x, int y; };\n\n.when(\n  bind(has&lt;&amp;Point::x, &amp;Point::y&gt;()) &gt;&gt;\n  [](int x, int y) {\n    return fmt(\"({}, {})\", x, y);\n  }\n)\n</code></pre> <ul> <li><code>has&lt;&gt;</code> describes the required structure</li> <li>Only the listed members are bound</li> <li>No access to unlisted members is provided</li> </ul> <p>Partial binding is expressed by listing only the desired members:</p> <pre><code>.when(\n  bind(has&lt;&amp;Point::x&gt;()) &gt;&gt;\n  [](int x) {\n    return fmt(\"x = {}\", x);\n  }\n)\n</code></pre>"},{"location":"api/#binding-semantics","title":"Binding Semantics","text":"<ul> <li><code>bind()</code> always binds the entire subject</li> <li><code>bind(subpattern)</code> binds the subject, but only if <code>subpattern</code> matches successfully.   If <code>subpattern</code> itself produces bindings (rare/advanced), those may be appended after the subject.</li> <li>The handler parameter order corresponds exactly to the binding order</li> <li>Patterns that do not bind values do not affect handler signatures</li> </ul> <p>[!IMPORTANT] <code>lit()</code> and <code>has&lt;&gt;</code> never introduce bindings by themselves. All bindings are introduced exclusively by <code>bind(...)</code>.</p> <pre><code>// Binding order example\nbind()                        -&gt; (subject)\nbind(lit(...))                -&gt; (subject)\nbind(has&lt;&amp;A::x, &amp;A::y&gt;())     -&gt; (x, y) // because has() is used under bind(), extraction is defined by bind(...)\n</code></pre> <p>Design Rationale:</p> <p>Patternia deliberately separates matching from binding. A pattern answers \u201cdoes this value match?\u201d A binding answers \u201cwhat values become available to the handler?\u201d</p> <p>This separation keeps control flow declarative and data flow explicit.</p>"},{"location":"api/#iii-guard-system","title":"III. Guard System","text":"<p>Guards are declarative constraints attached to patterns. They refine a match after binding succeeds, and before the handler is invoked.</p> <p>A guard failure does not terminate matching; it simply makes the current case fail and the engine continues to the next <code>.when(...)</code>.</p> <p>Warning</p> <p><code>_</code> and <code>rng(...)</code> are only valid when exactly one value is bound now. For multi-value patterns, use <code>arg&lt;N&gt;</code> or a lambda predicate.</p>"},{"location":"api/#guard-attachment","title":"<code>[]</code> Guard Attachment","text":"<p>Syntax:</p> <pre><code>pattern[guard]\n</code></pre> <p>Evaluation Order:</p> <ol> <li><code>pattern.match(subject)</code></li> <li><code>pattern.bind(subject)</code> \u2192 produces bound values (the handler inputs)</li> <li>evaluate <code>guard</code> (against the bound values)</li> <li>if guard passes \u2192 invoke handler; otherwise try next case</li> </ol> <p>Example:</p> <pre><code>match(x)\n  .when(\n    bind()[_ &gt; 0] &gt;&gt;\n    [](int v) {\n      // 1) bind() matches\n      // 2) bind() binds v\n      // 3) guard (_ &gt; 0) is evaluated\n      // 4) handler runs only if guard passes\n    }\n  )\n  .otherwise([] {});\n</code></pre> <p>Guard composition is supported:</p> <ul> <li><code>&amp;&amp;</code> (logical AND)</li> <li><code>||</code> (logical OR)</li> </ul>"},{"location":"api/#single-value-guards-_-and-rng","title":"Single-value Guards: <code>_</code> and <code>rng(...)</code>","text":"<p>Single-value guards are built with the global placeholder:</p> <pre><code>inline constexpr placeholder_t _;\n</code></pre> <p><code>_</code> is not a runtime value. Expressions like <code>_ &gt; 0</code> construct a predicate object.</p>"},{"location":"api/#supported-operators-for-_","title":"Supported operators for <code>_</code>","text":"<pre><code>_ &gt;  rhs\n_ &lt;  rhs\n_ &gt;= rhs\n_ &lt;= rhs\n_ == rhs\n_ != rhs\n</code></pre>"},{"location":"api/#range-helper-rnglo-hi-mode","title":"Range helper: <code>rng(lo, hi, mode)</code>","text":"<p>Use <code>rng(...)</code> for interval constraints (it returns a predicate usable inside <code>[]</code>).</p> <pre><code>rng(lo, hi)                 // [lo, hi]\nrng(lo, hi, open)           // (lo, hi)\nrng(lo, hi, open_closed)    // (lo, hi]\nrng(lo, hi, closed_open)    // [lo, hi)\n</code></pre> <p>Examples:</p> <pre><code>bind()[_ &gt; 0 &amp;&amp; _ &lt; 10]\nbind()[rng(0, 10, closed_open)]   // [0, 10)\n</code></pre> <p>Anything beyond these relational/range constraints should be expressed as a custom predicate (lambda), not as additional operator DSL.</p>"},{"location":"api/#multi-value-guards-argn-expressions","title":"Multi-value Guards: <code>arg&lt;N&gt;</code> Expressions","text":"<p>For guards that relate multiple bound values, use <code>arg&lt;N&gt;</code> to reference the N-th bound value (0-based):</p> <pre><code>template &lt;std::size_t I&gt;\ninline constexpr arg_t&lt;I&gt; arg{};\n</code></pre> <p>Key rule: <code>arg&lt;N&gt;</code> indices correspond exactly to the pattern\u2019s binding order (and therefore the handler\u2019s parameter order).</p>"},{"location":"api/#supported-operators-for-multi-value-expressions","title":"Supported operators for multi-value expressions","text":"<p>Multi-value guard expressions support:</p> <ul> <li>comparisons: <code>== != &lt; &gt; &lt;= &gt;=</code></li> <li>arithmetic: <code>+ - * / %</code></li> <li>plus logical composition via <code>&amp;&amp;</code> and <code>||</code></li> </ul> <p>There is no <code>rng(...)</code> for <code>arg&lt;N&gt;</code> expressions in the current design.</p> <p>Examples:</p> <pre><code>// x + y == 0\nmatch(p)\n  .when(\n    bind(has&lt;&amp;Point::x, &amp;Point::y&gt;())[arg&lt;0&gt; + arg&lt;1&gt; == 0] &gt;&gt;\n    [](int x, int y) { /* ... */ }\n  )\n  .otherwise([] {});\n</code></pre> <pre><code>// Protocol-like constraint over multiple fields\nmatch(pkt)\n  .when(\n    bind(has&lt;&amp;Packet::type, &amp;Packet::length&gt;())\n      [arg&lt;0&gt; == 0x01 &amp;&amp; arg&lt;1&gt; == 0] &gt;&gt;\n    [](auto type, auto len) { /* ... */ }\n  )\n  .otherwise([] {});\n</code></pre>"},{"location":"api/#compile-time-boundary-checking","title":"Compile-time boundary checking","text":"<p>Using an out-of-range <code>arg&lt;N&gt;</code> is ill-formed and diagnosed at compile time (the library checks the maximum referenced index against the number of bound values):</p> <pre><code>bind(has&lt;&amp;Point::x&gt;())[arg&lt;1&gt; &gt; 0]\n// \u274c ill-formed: arg&lt;1&gt; out of range (only one bound value)\n</code></pre>"},{"location":"api/#custom-predicates-recommended-for-domain-logic","title":"Custom Predicates (Recommended for \u201cDomain Logic\u201d)","text":"<p>A critical constraint of Patternia\u2019s guard DSL is that <code>arg&lt;N&gt;</code> is an expression-template placeholder, not \u201cthe real field type\u201d in a way that enables arbitrary member access in the DSL.</p> <p>So this is not supported as a guard DSL expression:</p> <pre><code>bind(has&lt;&amp;Message::payload&gt;())[arg&lt;0&gt;.size() &gt; 0] // \u274c do not do this\n</code></pre> <p>When you need container queries, method calls, non-trivial computations, or any domain-specific logic, write a lambda predicate and pass it to <code>[]</code>.</p> <p>Examples:</p> <pre><code>auto non_empty = [](auto const&amp; payload) {\n  return !payload.empty();\n};\n\nmatch(msg)\n  .when(\n    bind(has&lt;&amp;Message::payload&gt;())[non_empty] &gt;&gt;\n    [](auto const&amp; payload) {\n      // payload is guaranteed non-empty here\n    }\n  )\n  .otherwise([] {});\n</code></pre> <pre><code>auto sum_is_even = [](int a, int b) {\n  return ((a + b) % 2) == 0;\n};\n\nmatch(p)\n  .when(\n    bind(has&lt;&amp;Point::x, &amp;Point::y&gt;())[sum_is_even] &gt;&gt;\n    [](int x, int y) { /* ... */ }\n  )\n  .otherwise([] {});\n</code></pre>"},{"location":"api/#iv-structural-matching","title":"IV. Structural Matching","text":"<p>Structural matching allows Patternia to reason about the shape of objects at compile time, independently of control flow and value-level logic.</p> <p>Rather than destructuring by position, Patternia describes structure through explicit member selection.</p>"},{"location":"api/#hastmember","title":"<code>has&lt;&amp;T::member...&gt;</code>","text":"<p>Role: Structural constraint and decomposition primitive.</p> <p>Syntax: <pre><code>template &lt;auto... Ms&gt;\nconstexpr auto has();\n</code></pre></p> <p>Each template argument must be a pointer to a non-static data member.</p>"},{"location":"api/#semantics","title":"Semantics","text":"<p><code>has&lt;Ms...&gt;</code> declares a compile-time structural requirement:</p> <ul> <li>The matched type must contain all listed data members</li> <li>The order of members is not positional</li> <li>No values are accessed unless used within <code>bind()</code></li> </ul> <p>This makes <code>has&lt;&gt;</code> a structural predicate, not a value pattern.</p>"},{"location":"api/#core-characteristics","title":"Core Characteristics","text":"<ul> <li>Declarative structural constraints without control flow</li> <li>No implicit value access or extraction</li> <li>Independent of member layout or declaration order</li> <li>Compile-time validation of member pointers</li> </ul>"},{"location":"api/#basic-examples","title":"Basic Examples","text":"<pre><code>struct Point {\n  int x;\n  int y;\n};\n\nstruct Packet {\n  std::uint8_t type;\n  std::uint16_t length;\n  std::vector&lt;std::uint8_t&gt; data;\n};\n\n// Structural checks\nhas&lt;&amp;Point::x, &amp;Point::y&gt;\nhas&lt;&amp;Packet::type, &amp;Packet::length&gt;\n</code></pre> <p>These patterns assert that the matched value exposes the listed members. They do not bind or extract any values by themselves.</p>"},{"location":"api/#integration-with-bind","title":"Integration with <code>bind()</code>","text":"<p>When combined with <code>bind()</code>, <code>has&lt;&gt;</code> enables explicit structural extraction.</p> <pre><code>match(p)\n  .when(\n    bind(has&lt;&amp;Point::x, &amp;Point::y&gt;()) &gt;&gt;\n    [](int x, int y) {\n      return fmt(\"({}, {})\", x, y);\n    }\n  )\n  .otherwise([] {});\n</code></pre> <ul> <li><code>has&lt;&gt;</code> performs the structural check</li> <li><code>bind()</code> extracts the selected member values</li> <li>The handler receives the extracted values in the order listed</li> </ul>"},{"location":"api/#partial-structural-matching","title":"Partial Structural Matching","text":"<p>Structural matching is selective by design.</p> <p>To bind only a subset of members, list only those members:</p> <pre><code>match(p)\n  .when(\n    bind(has&lt;&amp;Point::x&gt;()) &gt;&gt;\n    [](int x) {\n      return fmt(\"x = {}\", x);\n    }\n  )\n  .otherwise([] {});\n</code></pre> <p>No placeholder or positional skipping is required. Unlisted members are simply ignored.</p>"},{"location":"api/#design-rationale","title":"Design Rationale","text":"<p>Patternia intentionally avoids positional or placeholder-based structural patterns.</p> <ul> <li>There is no notion of \u201cignored slots\u201d</li> <li>There is no dependency on member order</li> <li>There is no implicit reflection</li> </ul> <p>Instead:</p> <ul> <li>Structure is described by explicit member pointers</li> <li>Decomposition is driven by what you list, not what you omit</li> <li>This aligns with C++\u2019s existing type system and avoids reflection-like assumptions</li> </ul>"},{"location":"api/#standalone-vs-bound-usage","title":"Standalone vs Bound Usage","text":"<pre><code>has&lt;&amp;T::a, &amp;T::b&gt;        // Structural constraint only\nbind(has&lt;&amp;T::a, &amp;T::b&gt;) // Structural constraint + value extraction\n</code></pre> <p>This separation ensures that:</p> <ul> <li>Structural reasoning remains declarative</li> <li>Data flow remains explicit</li> <li>Control flow remains predictable</li> </ul>"},{"location":"api/#compile-time-guarantees","title":"Compile-time Guarantees","text":"<ul> <li>All member pointers are validated at compile time</li> <li>Invalid or non-existent members are diagnosed immediately</li> <li>No runtime reflection or metadata is required</li> </ul>"},{"location":"api/#conceptual-analogy","title":"Conceptual Analogy","text":"<p><code>has&lt;&gt;</code> is conceptually similar to Rust\u2019s structural patterns:</p> <pre><code>Point { x, y }\n</code></pre> <p>\u2014but adapted to C++\u2019s lack of native reflection by using explicit member pointers.</p> <p>It expresses what structure is required, not how to traverse it.</p>"},{"location":"api/#v-namespace-structure","title":"V. Namespace Structure","text":"<p>Patternia employs a layered namespace architecture:</p> <pre><code>ptn/                                    // Root namespace\n\u251c\u2500\u2500 core/                              // Core matching engine\n\u2502   \u251c\u2500\u2500 engine/                        // Matching engine implementation\n\u2502   \u251c\u2500\u2500 dsl/                          // DSL operators\n\u2502   \u2514\u2500\u2500 common/                       // Common utilities and traits\n\u251c\u2500\u2500 pat/                              // Pattern definitions\n\u2502   \u251c\u2500\u2500 base/                         // Pattern base classes\n\u2502   \u251c\u2500\u2500 lit.hpp                        // Literal pattern implementation\n\u2502   \u251c\u2500\u2500 bind.hpp                       // Binding pattern implementation\n\u2502   \u251c\u2500\u2500 wildcard.hpp                   // Wildcard pattern\n\u2502   \u251c\u2500\u2500 structural.hpp                 // Structural pattern\n\u2502   \u2514\u2500\u2500 modifiers/                     // Pattern modifiers\n\u2502       \u2514\u2500\u2500 guard.hpp                  // Guard system\n\u2514\u2500\u2500 meta/                             // Metaprogramming tools\n    \u251c\u2500\u2500 base/                         // Base traits\n    \u251c\u2500\u2500 dsa/                          // Data structures and algorithms\n    \u2514\u2500\u2500 query/                        // Query utilities\n</code></pre>"},{"location":"api/#primary-namespace-aliases","title":"Primary Namespace Aliases","text":"<p>For user convenience, Patternia provides all pattern functions directly in the <code>ptn</code> namespace:</p> <pre><code>namespace ptn {\n  // Core matching\n  using ptn::core::engine::match;\n\n  // Pattern primitives\n  using ptn::pat::lit;\n  using ptn::pat::lit_ci;\n  using ptn::pat::bind;\n  using ptn::pat::__;\n\n  // Guard system\n  using ptn::pat::mod::_;\n  using ptn::pat::mod::arg;\n  using ptn::pat::mod::rng;\n\n  // Structural patterns\n  using ptn::pat::has;\n}\n</code></pre> <p>This API reference focuses on Patternia's core design philosophy and essential APIs, providing readers with an understanding of Patternia's language composition rather than merely a function list. This organization facilitates better comprehension of Patternia's mental model and usage patterns.</p>"},{"location":"design-overview/","title":"Patternia Matching Semantics Overview","text":"<p>(<code>__</code>, <code>.end()</code>, <code>.otherwise()</code> and Destructuring Patterns)</p>"},{"location":"design-overview/#0-core-objectives","title":"0. Core Objectives","text":"<p>Patternia's DSL is designed to satisfy three key principles:</p> <ol> <li>Semantic Clarity:</li> <li>Clear separation between \"pattern-level\" and \"match-level\" responsibilities.</li> <li>Predictable Behavior:</li> <li>Consistent with Rust and the C++ standard proposal P1371R1 <code>inspect</code> mechanism in spirit.</li> <li>User-Friendly:</li> <li>Minimal API coverage for both \"statement-style matching\" and \"expression-style matching\" requirements.</li> </ol> <p>Around these three principles, the entire system can be abstracted into three levels:</p> <ol> <li>Pattern Level: <code>lit(...)</code>, <code>type::is&lt;T&gt;</code>, destructuring, <code>bind(...)</code>, <code>__</code>, etc.</li> <li>Case Level: <code>.when(pattern &gt;&gt; handler)</code>.</li> <li>Match Finalizer Level: <code>.end()</code> / <code>.otherwise(...)</code>.</li> </ol> <p>All discussions below revolve around these three levels.</p>"},{"location":"design-overview/#1-formal-definitions-of-core-concepts","title":"1. Formal Definitions of Core Concepts","text":""},{"location":"design-overview/#11-__-wildcard-pattern","title":"1.1 <code>__</code> (Wildcard Pattern)","text":"<ul> <li><code>__</code> is a pattern used to match \"any value\".</li> <li>It exists only at the Pattern Level and does not control the entire match lifecycle.</li> <li> <p>It plays different roles in different contexts:</p> </li> <li> <p>In literal matching: Serves as a \"fallback case\".</p> </li> <li>In enum/variant-like matching: Serves as a \"fallback for remaining constructors\".</li> <li>In struct destructuring:     Used for \"field-level ignoring\", similar to Rust's <code>_</code> / <code>..</code>.</li> </ul>"},{"location":"design-overview/#12-end-statement-style-match-finalizer","title":"1.2 <code>.end()</code> (Statement-style Match Finalizer)","text":"<ul> <li> <p><code>.end()</code> transforms the builder into statement-style matching:</p> </li> <li> <p>The entire <code>match(...)</code> expression does not return a value.</p> </li> <li>Used only for side effects (printing, logging, state modification, etc.).</li> <li> <p>Corresponds to the statement form in the standard proposal's <code>inspect</code>:</p> </li> <li> <p><code>pattern: statement;</code></p> </li> <li> <p>Constraints:</p> </li> <li> <p>All case handlers must return <code>void</code>.</p> </li> <li> <p>For exhaustible types (enum, bool, variant-like), future exhaustiveness checking will be performed:</p> <ul> <li>Compile-time diagnostics when not all enum values or alternatives are covered.</li> </ul> </li> </ul>"},{"location":"design-overview/#13-otherwise-expression-style-match-finalizer","title":"1.3 <code>.otherwise(...)</code> (Expression-style Match Finalizer)","text":"<ul> <li> <p><code>.otherwise(fallback)</code> transforms the builder into expression-style matching:</p> </li> <li> <p>The entire <code>match(...)</code> has a unified return value.</p> </li> <li>Similar to Rust's <code>let r = match x { ... };</code></li> <li> <p>Corresponds to the expression form in the standard proposal's <code>inspect</code>:</p> </li> <li> <p><code>pattern =&gt; expression,</code></p> </li> <li> <p>Constraints:</p> </li> <li> <p>All <code>.when(pattern &gt;&gt; handler)</code> handlers must return non-void and be type-unifiable.</p> </li> <li> <p><code>.otherwise(...)</code> provides the final fallback value:</p> <ul> <li>Used when no branches match.</li> <li><code>.otherwise(...)</code> terminates the builder and determines the return type.</li> </ul> </li> </ul>"},{"location":"design-overview/#2-semantic-levels-pattern-vs-match-finalizer","title":"2. Semantic Levels: Pattern vs Match Finalizer","text":"<p>Always remember:</p> <p><code>__</code> is a Pattern-level object; <code>.end()</code> and <code>.otherwise()</code> are Match Finalizer-level objects.</p> <p>They solve completely different problems:</p> Role Level Problem Solved <code>__</code> Pattern Level How current case matches \"any/remaining forms\" <code>.end()</code> Match Level Entire match \"executed as statement\" with no return <code>.otherwise</code> Match Level Entire match \"as expression\" with final return value <p>Therefore:</p> <ul> <li><code>__</code> cannot replace <code>.otherwise()</code>:   It doesn't terminate the builder, nor determine return type.</li> <li><code>.otherwise()</code> cannot replace <code>__</code>:   It cannot express \"fallback for remaining constructors/fields in pattern tree\".</li> </ul>"},{"location":"design-overview/#3-end-vs-otherwise-two-modes","title":"3. <code>.end()</code> vs <code>.otherwise()</code>: Two Modes","text":""},{"location":"design-overview/#31-end-statement-style-matching","title":"3.1 <code>.end()</code> \u2014 Statement-style Matching","text":"<p>Use Cases:</p> <ul> <li>Only care about side effects, no return value needed.</li> <li>Want exhaustiveness checking for enum/variant-like types.</li> </ul> <p>Semantic Characteristics:</p> <ul> <li>All handlers must return <code>void</code>.</li> <li>Return type is <code>void</code>.</li> <li>Exhaustible types will be checked for \"complete coverage\".</li> </ul> <p>Example (enum):</p> <pre><code>enum class Status { Pending, Running, Failed };\n\nmatch(status)\n    .when(lit(Status::Pending) &gt;&gt; [] { log(\"Pending\"); })\n    .when(lit(Status::Running) &gt;&gt; [] { log(\"Running\"); })\n    .when(__ &gt;&gt; [] { log(\"Other\"); })  // pattern-level fallback\n    .end();                            // match finalizer, no return value\n</code></pre> <p>Rust Analogy:</p> <pre><code>match status {\n    Status::Pending =&gt; log(\"Pending\"),\n    Status::Running =&gt; log(\"Running\"),\n    _               =&gt; log(\"Other\"),\n};\n</code></pre>"},{"location":"design-overview/#32-otherwise-expression-style-matching","title":"3.2 <code>.otherwise(...)</code> \u2014 Expression-style Matching","text":"<p>Use Cases:</p> <ul> <li>Need to compute a value from match:</li> <li>Generate labels for enum/variant;</li> <li>Calculate results, map strings, etc.</li> </ul> <p>Semantic Characteristics:</p> <ul> <li>All handlers return the same type (or commonly convertible).</li> <li><code>.otherwise(fallback)</code> provides the final value.</li> <li>The entire <code>match(...)</code> expression has a concrete type.</li> </ul> <p>Example (Rust counterpart):</p> <pre><code>int x = 2;\n\nauto res = match(x)\n    .when(lit(1) &gt;&gt; \"one\")\n    .when(lit(2) &gt;&gt; \"two\")\n    .otherwise(\"Other\");\n\nstd::cout &lt;&lt; res;\n</code></pre> <p>Corresponding Rust:</p> <pre><code>let x = 2;\nlet res = match x {\n    1 =&gt; \"one\",\n    2 =&gt; \"two\",\n    _ =&gt; \"Other\",\n};\nprintln!(\"{}\", res);\n</code></pre>"},{"location":"design-overview/#4-__-roles-in-different-scenarios","title":"4. <code>__</code> Roles in Different Scenarios","text":""},{"location":"design-overview/#41-as-case-fallback-wildcard","title":"4.1 As \"Case Fallback\" Wildcard","text":"<p>Simplest literal scenario:</p> <pre><code>auto res = match(x)\n    .when(lit(1) &gt;&gt; \"one\")\n    .when(lit(2) &gt;&gt; \"two\")\n    .when(__ &gt;&gt; \"other\")    // __ is pattern-level fallback here\n    .otherwise(\"panic\");    // match-level fallback (defensive, usually never triggered)\n</code></pre> <ul> <li><code>__ &gt;&gt; \"other\"</code>: Represents \"all other values\".</li> <li><code>.otherwise(\"panic\")</code>: Ideally never used, but can serve as defensive fallback.</li> </ul>"},{"location":"design-overview/#42-remaining-branch-in-enumvariant-like-matching","title":"4.2 Remaining Branch in Enum/Variant-like Matching","text":"<p>For variant-like types (including future kind/alternative patterns):</p> <pre><code>auto info = match(v)\n    .when(type::is&lt;int&gt;         &gt;&gt; \"int\")\n    .when(type::is&lt;std::string&gt; &gt;&gt; \"string\")\n    .when(__                     &gt;&gt; \"other-kind\")\n    .otherwise(\"panic\"); // match-level defense, ideally never triggered\n</code></pre> <p>Here:</p> <ul> <li><code>__</code> represents \"all alternatives except int and string\".</li> <li><code>.otherwise(\"panic\")</code> is the final match-level defense.</li> </ul>"},{"location":"design-overview/#43-field-wildcard-in-struct-destructuring","title":"4.3 Field Wildcard in Struct Destructuring","text":"<p>Corresponding Rust:</p> <pre><code>match p {\n    Point { x, .. } =&gt; println!(\"{}\", x),\n}\n</code></pre> <p>Patternia ideal DSL example:</p> <pre><code>struct Point { int x, y, z; };\n\nmatch(p)\n    .when(Point{ bind(x), __, __ } &gt;&gt; [&amp;] {\n        std::cout &lt;&lt; x;\n    })\n    .end();\n</code></pre> <p>Meaning:</p> <ul> <li>Matches object of type <code>Point</code>.</li> <li>Only binds first field <code>x</code>.</li> <li>Other fields (<code>y</code>, <code>z</code>) are ignored with <code>__</code>.</li> </ul> <p><code>__</code> here is field-level wildcard, not a fallback case. Future named field versions could also be extended:</p> <pre><code>.when(Point{ .x = bind(x), .y = __, .z = __ } &gt;&gt; ...)\n</code></pre>"},{"location":"design-overview/#5-when-do-__-and-otherwise-appear-together","title":"5. When Do <code>__</code> and <code>.otherwise()</code> \"Appear Together\"?","text":""},{"location":"design-overview/#51-typical-scenario-expression-match-pattern-fallback-match-fallback","title":"5.1 Typical Scenario: Expression Match + Pattern Fallback + Match Fallback","text":"<p>In complex modes:</p> <ul> <li>Pattern level might already use <code>__</code> for fallback matching all forms;</li> <li>But you can still set <code>.otherwise(...)</code> at match level as \"defensive branch that should never trigger\".</li> </ul> <p>Example:</p> <pre><code>auto label = match(v)\n    .when(type::is&lt;int&gt;         &gt;&gt; \"int\")\n    .when(type::is&lt;std::string&gt; &gt;&gt; \"string\")\n    .when(__                     &gt;&gt; \"other-kind\") // pattern-level fallback\n    .otherwise(\"unreachable\");                    // match-level defense\n</code></pre> <p>Here <code>.otherwise(\"unreachable\")</code> should ideally never trigger in normal logic, but:</p> <ul> <li>Can be used for debug/assertions;</li> <li>Semantically completely valid in the DSL.</li> </ul>"},{"location":"design-overview/#52-expression-matches-must-use-otherwise","title":"5.2 Expression Matches Must Use <code>.otherwise()</code>","text":"<p>Whenever you write:</p> <pre><code>auto res = match(subject)\n    .when(...)\n    ...\n</code></pre> <p>And want to assign the result to <code>res</code>, then expression-style matches must be terminated with <code>.otherwise(...)</code>. Even if the pattern level is already covered by <code>__</code>.</p> <p>The reason is:</p> <ul> <li>Builder needs a finalizer to determine \"this is an expression-style match\";</li> <li>C++ needs a clear return type, and <code>.otherwise(...)</code> is exactly this entry point.</li> </ul>"},{"location":"design-overview/#53-when-does-match-level-fallback-trigger","title":"5.3 When Does Match-level Fallback Trigger?","text":"<p>The <code>.otherwise(handler)</code> is triggered in two scenarios:</p>"},{"location":"design-overview/#scenario-1-no-pattern-matches","title":"Scenario 1: No Pattern Matches","text":"<p>When none of the <code>.when()</code> cases match the subject value:</p> <pre><code>auto result = match(42)\n    .when(lit(1) &gt;&gt; \"one\")      // \u274c No match\n    .when(lit(2) &gt;&gt; \"two\")      // \u274c No match  \n    .when(__ &gt;&gt; \"other\")           // \u274c No match (if no wildcard case for this specific scenario)\n    .otherwise(\"default\");         // \u2705 TRIGGERED: Returns \"default\"\n</code></pre>"},{"location":"design-overview/#scenario-2-explicit-match-level-defense","title":"Scenario 2: Explicit Match-level Defense","text":"<p>Even when patterns (including <code>__</code>) could theoretically match everything, <code>.otherwise()</code> still serves as a defensive fallback:</p> <pre><code>auto result = match(42)\n    .when(lit(1) &gt;&gt; \"one\")      // \u274c No match\n    .when(lit(2) &gt;&gt; \"two\")      // \u274c No match\n    .when(__ &gt;&gt; \"other\")           // \u2705 PATTERN MATCHES: Returns \"other\"\n    .otherwise(\"unreachable\");      // \u274c NOT TRIGGERED: Pattern already matched\n</code></pre> <p>Key Principles:</p> <ol> <li>Pattern Priority: Cases are evaluated in order. The first matching pattern wins.</li> <li>Wildcard Coverage: <code>__</code> matches any value, so if placed before <code>.otherwise()</code>, it will typically match first.</li> <li>Defensive Purpose: <code>.otherwise()</code> as \"unreachable\" provides runtime safety for logic errors or unexpected inputs.</li> </ol>"},{"location":"design-overview/#practical-example-with-pattern-vs-match-fallback","title":"Practical Example with Pattern vs Match Fallback:","text":"<pre><code>// This demonstrates the execution order\nauto classify = std::string input;\n\nauto result = match(classify)\n    .when(lit_ci(\"error\") &gt;&gt; \"ERROR\")           // Case 1: Specific match\n    .when(lit_ci(\"warning\") &gt;&gt; \"WARNING\")       // Case 2: Specific match  \n    .when(__ &gt;&gt; \"UNKNOWN\")                      // Case 3: Pattern fallback\n    .otherwise(\"INVALID INPUT\");                 // Case 4: Match-level fallback (unlikely to trigger)\n\n// For input \"INFO\":\n// - Cases 1,2: No match\n// - Case 3 (__): Matches \u2192 Returns \"UNKNOWN\"  \n// - Case 4 (.otherwise): NOT triggered\n\n// For input null/empty string (if it reaches match):\n// - Cases 1,2,3: All could potentially handle this\n// - Depending on implementation, might reach .otherwise() as defense\n</code></pre> <p>Summary: - Pattern-level fallback (<code>__</code>): Only affects case matching process at pattern level - Match-level fallback (<code>.otherwise()</code>): Determines final return value of match expression - When <code>__</code> can match all pattern forms: <code>.otherwise()</code> serves only as defensive fallback and typically won't trigger</p>"},{"location":"design-overview/#6-when-to-use-end-when-to-use-otherwise","title":"6. When to Use <code>.end()</code>, When to Use <code>.otherwise()</code>?","text":"<p>Use this decision table to directly guide user usage.</p>"},{"location":"design-overview/#61-decision-table","title":"6.1 Decision Table","text":"Requirement Recommended Usage Only execute side effects, no match return value Use <code>.end()</code> Need to get a value from match (like Rust) Use <code>.otherwise(...)</code> Want exhaustiveness checking for enum/variant Use <code>.end()</code> Express \"all remaining matching forms\" Use <code>__</code> in pattern Express \"entire match fallback return value\" Use <code>.otherwise(...)</code>"},{"location":"design-overview/#62-typical-patterns","title":"6.2 Typical Patterns","text":"<ol> <li>Statement-style with fallback:</li> </ol> <pre><code>match(s)\n    .when(lit(Status::Pending) &gt;&gt; [] { ... })\n    .when(lit(Status::Running) &gt;&gt; [] { ... })\n    .when(__ &gt;&gt; [] { ... }) // fallback\n    .end();\n</code></pre> <ol> <li>Expression-style, Rust counterpart:</li> </ol> <pre><code>auto res = match(x)\n    .when(lit(1) &gt;&gt; \"one\")\n    .when(lit(2) &gt;&gt; \"two\")\n    .otherwise(\"Other\");\n</code></pre> <ol> <li>Struct destructuring + field wildcard:</li> </ol> <pre><code>match(p)\n    .when(Point{ bind(x), __, __ } &gt;&gt; [&amp;] { return x; })\n    .otherwise(0);\n</code></pre> <ol> <li>Variant-like + type matching + pattern fallback:</li> </ol> <pre><code>auto info = match(v)\n    .when(type::is&lt;int&gt;         &gt;&gt; \"int\")\n    .when(type::is&lt;std::string&gt; &gt;&gt; \"string\")\n    .when(__                     &gt;&gt; \"other-kind\")\n    .otherwise(\"panic\");\n</code></pre>"},{"location":"design-overview/#7-implementation-details","title":"7. Implementation Details","text":""},{"location":"design-overview/#71-builder-execution-flow","title":"7.1 Builder Execution Flow","text":"<p>The builder pattern ensures that matches are only executed when properly terminated:</p> <pre><code>// Without .end() or .otherwise():\nmatch(value).when(lit(42) &gt;&gt; [] { /* handler */ });\n// Result: Nothing is executed - builder remains unterminated\n\n// With .end():\nmatch(value).when(lit(42) &gt;&gt; [] { /* handler */ }).end();\n// Result: match_impl::eval(subject_, cases_, std::move(dummy_fallback));\n\n// With .otherwise():\nmatch(value).when(lit(42) &gt;&gt; [] { /* handler */ }).otherwise(fallback);\n// Result: match_impl::eval(subject_, cases_, std::move(final_handler));\n</code></pre> <p>Key Points:</p> <ul> <li>Without <code>.end()</code> or <code>.otherwise()</code>, the builder never triggers execution.</li> <li><code>.end()</code> creates an empty fallback handler for statement-style execution.</li> <li><code>.otherwise()</code> uses the provided handler as the final fallback for expression-style execution.</li> </ul>"},{"location":"design-overview/#72-type-safety-guarantees","title":"7.2 Type Safety Guarantees","text":"<ul> <li>Statement-style (<code>.end()</code>): All handlers must return <code>void</code></li> <li>Expression-style (<code>.otherwise()</code>): All handlers must return compatible types</li> <li>Pattern matching: Type-safe heterogeneous comparisons</li> <li>Binding: Compile-time type deduction for bound values</li> </ul>"},{"location":"design-overview/#8-future-roadmap","title":"8. Future Roadmap","text":"<p>To make these semantics truly user-friendly, Patternia's future plans include:</p> <ol> <li>Exhaustiveness Checking for <code>.end()</code>:</li> <li>Enum/bool: Static checking for complete enum value coverage.</li> <li>Variant-like: Check for complete alternative coverage.</li> <li> <p>Provide \"missing case\" and \"useless case\" hints.</p> </li> <li> <p>Formal Struct Destructuring DSL:</p> </li> <li>Positional: <code>Point{ bind(x), __, __ }</code></li> <li>Named: <code>Point{ .x = bind(x), .y = __, .z = __ }</code></li> <li> <p>Support guard/bind/nested patterns.</p> </li> <li> <p>Improved Error Messages:</p> </li> <li>Non-void handler under <code>.end()</code> \u2192 Clear error.</li> <li>Handler return type inconsistency under <code>.otherwise()</code> \u2192 Clear type diagnostics.</li> <li>Wildcard + <code>.otherwise()</code> redundancy \u2192 Hint \"potentially redundant patterns\".</li> </ol> <p>This comprehensive design ensures that Patternia provides clear, predictable, and user-friendly pattern matching semantics while maintaining type safety and performance guarantees.</p>"},{"location":"changelog/releases/","title":"Patternia Releases","text":"<ul> <li>v0.5.2 - December 10, 2025</li> <li>v0.5.3 - December 14, 2025</li> </ul>"},{"location":"changelog/v0.5.2/","title":"Patternia v0.5.2 Release Notes","text":"<p>Release Date: December 10, 2025  Version: 0.5.2</p>"},{"location":"changelog/v0.5.2/#overview","title":"Overview","text":"<p>Patternia v0.5.2 introduces the wildcard pattern <code>__</code> and provides comprehensive documentation updates. This release focuses on semantic clarity, improved developer experience, and establishing a solid foundation for future exhaustiveness checking features.</p>"},{"location":"changelog/v0.5.2/#new-features","title":"New Features","text":""},{"location":"changelog/v0.5.2/#wildcard-pattern-__","title":"Wildcard Pattern (<code>__</code>)","text":"<p>Added: <code>ptn::__</code> - A pattern that matches any value without binding.</p> <pre><code>// Basic wildcard usage\nmatch(value)\n    .when(lit(0) &gt;&gt; \"zero\")\n    .when(__ &gt;&gt; \"other\")  // Matches any other value\n    .end();\n</code></pre> <p>Key Characteristics: - Always matches regardless of input value - Binds no data (returns empty tuple <code>std::tuple&lt;&gt;</code>) - More explicit than <code>bind()</code> when no capture is needed - Essential for catch-all cases and future struct destructuring</p>"},{"location":"changelog/v0.5.2/#enhanced-terminal-method-semantics","title":"Enhanced Terminal Method Semantics","text":"<p>Improved: Clear distinction between <code>.end()</code> and <code>.otherwise()</code> terminal methods.</p>"},{"location":"changelog/v0.5.2/#end-statement-style-matching","title":"<code>.end()</code> - Statement-style Matching","text":"<ul> <li>For void-returning matches</li> <li>Designed for exhaustiveness checking (future feature)</li> <li>Used when only side effects are needed</li> </ul>"},{"location":"changelog/v0.5.2/#otherwisehandler-expression-style-matching","title":"<code>.otherwise(handler)</code> - Expression-style Matching","text":"<ul> <li>For value-returning matches</li> <li>Provides explicit fallback behavior</li> <li>Used when computing results from matches</li> </ul>"},{"location":"changelog/v0.5.2/#fallback-trigger-mechanism-clarification","title":"Fallback Trigger Mechanism Clarification","text":"<p>Added: Detailed explanation of when <code>.otherwise()</code> is triggered:</p> <ol> <li>No Pattern Matches: When no <code>.when()</code> cases match the subject</li> <li>Defensive Fallback: Even with pattern coverage, provides runtime safety</li> </ol> <p>Key Principle: First matching pattern wins, regardless of fallback types.</p>"},{"location":"changelog/v0.5.2/#documentation-improvements","title":"Documentation Improvements","text":""},{"location":"changelog/v0.5.2/#design-overview-document","title":"Design Overview Document","text":"<p>Added: <code>docs/design-overview.md</code> - Comprehensive guide covering: - Three-level architecture (Pattern \u2192 Case \u2192 Match Finalizer) - Semantic differences between <code>__</code>, <code>.end()</code>, and <code>.otherwise()</code> - Usage scenarios and best practices - Implementation details and execution flow - Future roadmap for exhaustiveness checking</p>"},{"location":"changelog/v0.5.2/#enhanced-api-reference","title":"Enhanced API Reference","text":"<p>Updated: <code>docs/api.md</code> with: - Complete wildcard pattern documentation - Detailed comparison of terminal methods - Implementation notes about builder execution - Future features section with exhaustiveness checking roadmap</p>"},{"location":"changelog/v0.5.2/#improved-user-guide","title":"Improved User Guide","text":"<p>Updated: <code>README.md</code> featuring: - Wildcard pattern examples - Clear terminal method guidance - Future roadmap section - Better usage decision tables</p>"},{"location":"changelog/v0.5.2/#internal-improvements","title":"Internal Improvements","text":""},{"location":"changelog/v0.5.2/#comment-standardization","title":"Comment Standardization","text":"<p>Fixed: Consistent English comment style across all modified files: - <code>include/ptn/pattern/wildcard.hpp</code> - Added comprehensive file header - <code>include/ptn/core/engine/detail/builder_impl.hpp</code> - Completed member variable documentation - <code>include/ptn/core/common/common_traits.hpp</code> - Enhanced type trait comments - <code>samples/test.cpp</code> - Added explanatory comments and examples</p>"},{"location":"changelog/v0.5.2/#builder-implementation-enhancements","title":"Builder Implementation Enhancements","text":"<p>Improved: Better documentation in <code>match_builder</code> implementation: - Clear explanation of builder execution flow - Documented member variable purposes - Enhanced inline comments for complex template logic</p>"},{"location":"changelog/v0.5.2/#architecture-changes","title":"Architecture Changes","text":""},{"location":"changelog/v0.5.2/#three-level-design-formalization","title":"Three-Level Design Formalization","text":"<p>Patternia now explicitly follows a three-level architecture:</p> <ol> <li>Pattern Level: <code>lit()</code>, <code>bind()</code>, <code>__</code>, etc.</li> <li>Case Level: <code>.when(pattern &gt;&gt; handler)</code></li> <li>Match Finalizer Level: <code>.end()</code> / <code>.otherwise()</code></li> </ol> <p>This design ensures: - Clear separation of concerns - Predictable behavior matching Rust/standard proposals - Extensible foundation for future features</p>"},{"location":"changelog/v0.5.2/#semantic-clarity-improvements","title":"Semantic Clarity Improvements","text":"<p>Established: Clear distinctions between: - Pattern-level wildcards (<code>__</code>) vs match-level fallbacks (<code>.otherwise()</code>) - Statement-style (<code>.end()</code>) vs expression-style (<code>.otherwise()</code>) matching - Field-level ignoring vs case-level fallbacks</p>"},{"location":"changelog/v0.5.2/#usage-examples","title":"Usage Examples","text":""},{"location":"changelog/v0.5.2/#basic-pattern-matching","title":"Basic Pattern Matching","text":"<pre><code>#include &lt;ptn/patternia.hpp&gt;\n\n// Expression-style match\nauto result = match(value)\n    .when(lit(1) &gt;&gt; \"one\")\n    .when(lit(2) &gt;&gt; \"two\") \n    .when(__ &gt;&gt; \"other\")  // Wildcard fallback\n    .otherwise(\"default\");  // Match-level fallback\n</code></pre>"},{"location":"changelog/v0.5.2/#statement-style-matching","title":"Statement-style Matching","text":"<pre><code>// Statement-style match with exhaustiveness (future)\nmatch(status)\n    .when(lit(Status::Pending) &gt;&gt; [] { log(\"pending\"); })\n    .when(lit(Status::Running) &gt;&gt; [] { log(\"running\"); })\n    .when(__ &gt;&gt; [] { log(\"other\"); })  // Pattern fallback\n    .end();  // Statement termination\n</code></pre>"},{"location":"changelog/v0.5.2/#enum-with-wildcard","title":"Enum with Wildcard","text":"<pre><code>enum class Color { Red, Green, Blue };\nColor c = Color::Green;\n\nmatch(c)\n    .when(lit(Color::Red) &gt;&gt; [] { std::cout &lt;&lt; \"red\"; })\n    .when(lit(Color::Green) &gt;&gt; [] { std::cout &lt;&lt; \"green\"; })\n    .when(__ &gt;&gt; [] { std::cout &lt;&lt; \"other\"; })  // Catch-all\n    .end();\n</code></pre>"},{"location":"changelog/v0.5.2/#bug-fixes","title":"Bug Fixes","text":""},{"location":"changelog/v0.5.2/#api-clarity","title":"API Clarity","text":"<p>Fixed: Ambiguous terminal method behavior - Clear distinction between <code>.end()</code> and <code>.otherwise()</code>  - Better examples showing appropriate use cases</p>"},{"location":"changelog/v0.5.3/","title":"Patternia v0.5.3 Release Notes","text":"<p>Release Date: December 14, 2025  Version: 0.5.3</p>"},{"location":"changelog/v0.5.3/#overview","title":"Overview","text":"<p>Patternia v0.5.3 introduces advanced pattern matching capabilities with guard predicates, enhanced binding mechanisms, structural decomposition patterns, and range matching utilities. This release significantly expands the expressiveness of pattern matching while maintaining zero-overhead performance and type safety.</p>"},{"location":"changelog/v0.5.3/#new-features","title":"New Features","text":""},{"location":"changelog/v0.5.3/#enhanced-binding-patterns-bind-and-bindsubpattern","title":"Enhanced Binding Patterns (<code>bind()</code> and <code>bind(subpattern)</code>)","text":"<p>Enhanced: <code>bind()</code> function with subpattern support for conditional binding.</p> <pre><code>// Basic binding - captures the subject itself\nmatch(value)\n    .when(bind() &gt;&gt; [](auto x) { /* use x */ })\n    .end();\n\n// Binding with subpattern - first matches subpattern, then captures subject\nmatch(number)\n    .when(bind(lit(42)) &gt;&gt; [](auto x) { /* x is 42, subject is also captured */ })\n    .when(bind([](auto n) { return n &gt; 0; }) &gt;&gt; [](auto subject, auto n) {\n        return fmt::format(\"positive: {} (subject: {})\", n, subject);\n    })\n    .otherwise(\"non-positive\");\n</code></pre> <p>Key Capabilities: - <code>bind()</code> - Captures the subject itself as a single-element tuple - <code>bind(subpattern)</code> - First matches with subpattern, then captures both subject and subpattern bindings - Type-safe binding with compile-time validation - Integration with all existing pattern types</p>"},{"location":"changelog/v0.5.3/#guard-predicates-and-placeholder-expressions","title":"Guard Predicates and Placeholder Expressions","text":"<p>Added: Comprehensive guard system with placeholder <code>_</code> and predicate combinators.</p> <pre><code>// Placeholder-based guard expressions\nmatch(number)\n    .when(bind()[_ &gt; 10 &amp;&amp; _ &lt; 100] &gt;&gt; \"two-digit\")\n    .when(bind()[_ &gt;= 100] &gt;&gt; \"three-or-more-digits\")\n    .otherwise(\"single-digit\");\n\n// Range predicates with different modes\nmatch(value)\n    .when(bind()[rng(0, 10)] &gt;&gt; \"small closed\")           // [0, 10]\n    .when(bind()[rng(10, 20, open)] &gt;&gt; \"medium open\")    // (10, 20)\n    .when(bind()[rng(20, 30, open_closed)] &gt;&gt; \"large open-closed\") // (20, 30]\n    .when(bind()[rng(30, 40, closed_open)] &gt;&gt; \"xlarge closed-open\") // [30, 40)\n    .otherwise(\"out of range\");\n\n// Lambda guards for complex conditions\nmatch(data)\n    .when(bind()[[](auto x) { return x.is_valid() &amp;&amp; x.size() &gt; 0; }] &gt;&gt; \"valid\")\n    .otherwise(\"invalid\");\n</code></pre> <p>Guard Features: - <code>_</code> placeholder for creating comparison expressions (<code>_ &gt; 10</code>, <code>_ == 42</code>, etc.) - <code>rng()</code> function for range predicates with four modes: <code>closed</code>, <code>open</code>, <code>open_closed</code>, <code>closed_open</code> - Predicate combinators: <code>&amp;&amp;</code> (logical AND) and <code>||</code> (logical OR) - Lambda guard support for complex custom conditions - Type-safe guard predicate evaluation</p>"},{"location":"changelog/v0.5.3/#structural-decomposition-patterns-has","title":"Structural Decomposition Patterns (<code>has&lt;&gt;</code>)","text":"<p>Added: <code>has&lt;&amp;T::field...&gt;()</code> for aggregate and struct decomposition.</p> <pre><code>struct Point { int x, y; };\nstruct Circle { Point center; int radius; };\n\n// Basic field presence checking\nmatch(point)\n    .when(has&lt;&amp;Point::x, &amp;Point::y&gt; &gt;&gt; \"valid point\")\n    .otherwise(\"invalid point\");\n\n// Combining with binding for field access\nmatch(circle)\n    .when(has&lt;&amp;Circle::center, &amp;Circle::radius&gt; &gt;&gt; bind() &gt;&gt; [](auto c) {\n        return fmt::format(\"circle at ({}, {}) with radius {}\", \n                           c.center.x, c.center.y, c.radius);\n    })\n    .otherwise(\"invalid circle\");\n\n// Multi-level structural matching\nmatch(complex_data)\n    .when(has&lt;&amp;Data::points&gt; &gt;&gt; bind()[[](auto pts) { return !pts.empty(); }]\n         &gt;&gt; [](auto data, auto pts) {\n        return fmt::format(\"data with {} points\", pts.size());\n    })\n    .otherwise(\"empty or invalid data\");\n</code></pre> <p>Structural Pattern Features: - Compile-time validation of member pointer parameters - Support for multiple field pointers in single pattern - Integration with binding patterns for field access - Zero-overhead struct decomposition - Type-safe member access checking</p>"},{"location":"changelog/v0.5.3/#advanced-pattern-composition","title":"Advanced Pattern Composition","text":"<p>Enhanced: Seamless integration between all pattern types.</p> <pre><code>// Complex pattern combining all features\nmatch(data)\n    .when(\n        has&lt;&amp;Data::value, &amp;Data::status&gt; &gt;&gt; \n        bind()[[](auto d) { return d.value &gt; 0; } &amp;&amp; [](auto d) { return d.status == Status::Active; }]\n     &gt;&gt; [](auto d, auto value, auto status) {\n        return fmt::format(\"active data: {} (status: {})\", value, status);\n    })\n    .when(\n        has&lt;&amp;Data::value&gt; &gt;&gt; \n        bind([](auto v) { return v &lt; 0; })[_ &gt; -100]\n     &gt;&gt; [](auto subject, auto v) {\n        return fmt::format(\"negative value: {} (subject: {})\", v, subject);\n    })\n    .otherwise(\"no match\");\n</code></pre>"},{"location":"changelog/v0.5.3/#internal-improvements","title":"Internal Improvements","text":""},{"location":"changelog/v0.5.3/#pattern-framework-extensions","title":"Pattern Framework Extensions","text":"<p>Enhanced: Advanced pattern matching infrastructure: - Guard predicate evaluation system - Enhanced binding pattern composition - Structural pattern validation - Type-safe predicate combinators</p>"},{"location":"changelog/v0.5.3/#type-system-improvements","title":"Type System Improvements","text":"<p>Added: Comprehensive type support for: - Member pointer validation in <code>has&lt;&gt;</code> - Guard predicate type detection - Binding contract forwarding - Template parameter deduction</p>"},{"location":"changelog/v0.5.3/#performance-optimizations","title":"Performance Optimizations","text":"<p>Maintained: Zero-overhead guarantees: - Compile-time guard predicate evaluation where possible - Inlined pattern matching - Optimal struct field access - Efficient tuple composition for binding</p>"},{"location":"changelog/v0.5.3/#architecture-changes","title":"Architecture Changes","text":""},{"location":"changelog/v0.5.3/#guard-system-architecture","title":"Guard System Architecture","text":"<p>Added: Comprehensive guard framework: - <code>guard_predicate_tag</code> for type detection - <code>placeholder_t</code> with comparison operator overloads - <code>binary_predicate</code> for standard comparisons - <code>range_predicate</code> with configurable modes - <code>guarded_pattern</code> wrapper for pattern composition</p>"},{"location":"changelog/v0.5.3/#enhanced-binding-system","title":"Enhanced Binding System","text":"<p>Expanded: Binding pattern capabilities: - <code>binding_pattern</code> for subject capture - <code>binding_as_pattern</code> for subpattern composition - Tuple concatenation for multi-value binding - Forwarding binding contracts to inner patterns</p>"},{"location":"changelog/v0.5.3/#structural-pattern-framework","title":"Structural Pattern Framework","text":"<p>Added: Member pointer-based decomposition: - Compile-time member pointer validation - <code>has_pattern</code> for field presence checking - Integration with existing pattern ecosystem - Zero-overhead field access</p>"},{"location":"changelog/v0.5.3/#usage-examples","title":"Usage Examples","text":""},{"location":"changelog/v0.5.3/#guard-with-placeholders","title":"Guard with Placeholders","text":"<pre><code>match(score)\n    .when(bind()[_ &gt;= 90] &gt;&gt; \"excellent\")\n    .when(bind()[_ &gt;= 80 &amp;&amp; _ &lt; 90] &gt;&gt; \"good\")\n    .when(bind()[_ &gt;= 70 &amp;&amp; _ &lt; 80] &gt;&gt; \"average\")\n    .otherwise(\"needs improvement\");\n</code></pre>"},{"location":"changelog/v0.5.3/#range-matching-with-different-modes","title":"Range Matching with Different Modes","text":"<pre><code>match(temperature)\n    .when(bind()[rng(18.0, 22.0)] &gt;&gt; \"comfortable\")           // [18, 22]\n    .when(bind()[rng(22.0, 30.0, open)] &gt;&gt; \"warm\")            // (22, 30)\n    .when(bind()[rng(30.0, 40.0, open_closed)] &gt;&gt; \"hot\")      // (30, 40]\n    .when(bind()[rng(-10.0, 18.0, closed_open)] &gt;&gt; \"cool\")   // [-10, 18)\n    .otherwise(\"extreme temperature\");\n</code></pre>"},{"location":"changelog/v0.5.3/#structural-pattern-with-guards","title":"Structural Pattern with Guards","text":"<pre><code>struct Employee {\n    std::string name;\n    int age;\n    double salary;\n    bool active;\n};\n\nmatch(employee)\n    .when(\n        has&lt;&amp;Employee::age, &amp;Employee::salary, &amp;Employee::active&gt; &gt;&gt;\n        bind()[[](auto e) { return e.active &amp;&amp; e.age &gt;= 25; }]\n     &gt;&gt; [](auto e, auto age, auto salary, auto active) {\n        return fmt::format(\"active employee: {} ({} years, ${:.2f})\", \n                          e.name, age, salary);\n    })\n    .when(\n        has&lt;&amp;Employee::age&gt; &gt;&gt;\n        bind([](auto age) { return age &lt; 25; })[_ &gt;= 18]\n     &gt;&gt; [](auto subject, auto age) {\n        return fmt::format(\"young employee: {} years old\", age);\n    })\n    .otherwise(\"no match\");\n</code></pre>"},{"location":"changelog/v0.5.3/#complex-pattern-composition","title":"Complex Pattern Composition","text":"<pre><code>match(container)\n    .when(\n        has&lt;&amp;Container::size&gt; &gt;&gt;\n        bind()[[](auto c) { return c.size() &gt; 0; } &amp;&amp; [](auto c) { return c.size() &lt;= 100; }]\n     &gt;&gt; [](auto c, auto size) {\n        return fmt::format(\"container with {} items\", size);\n    })\n    .when(\n        has&lt;&amp;Container::size&gt; &gt;&gt;\n        bind()[[](auto c) { return c.size() == 0; }]\n     &gt;&gt; [](auto c) {\n        return \"empty container\";\n    })\n    .otherwise(\"large or invalid container\");\n</code></pre>"},{"location":"changelog/v0.5.3/#bug-fixes","title":"Bug Fixes","text":""},{"location":"changelog/v0.5.3/#pattern-validation","title":"Pattern Validation","text":"<p>Fixed: Edge cases in pattern matching: - Guard predicate type deduction for complex expressions - Binding contract forwarding for nested patterns - Member pointer validation in <code>has&lt;&gt;</code> patterns - Range boundary evaluation edge cases</p>"},{"location":"changelog/v0.5.3/#compilation-issues","title":"Compilation Issues","text":"<p>Resolved: Template compilation problems: - Guard predicate instantiation failures - Binding pattern type deduction - Structural pattern member access validation - Predicate combinator type resolution</p>"},{"location":"guide/getting-started/","title":"Getting Started","text":"<p>Patternia is a header-only library. Once installed or fetched into your project, you can start using pattern matching immediately.</p> <p>Below is minimal working example demonstrating the core DSL:</p>"},{"location":"guide/getting-started/#optional-recommended-code-style","title":"Optional: Recommended Code Style","text":"<p>To keep your chained <code>.when()</code> and <code>.otherwise()</code> expressions visually aligned and easy to scan, you can add a minimal <code>.clang-format</code> to your project root:</p> <pre><code># patternia .clang-format (minimal)\nBasedOnStyle: LLVM\nIndentWidth: 2            # or 4\nContinuationIndentWidth: 4 # or 6\nColumnLimit: 0\nBinPackArguments: false\nBinPackParameters: false\nBreakBeforeBinaryOperators: None\n</code></pre> <p>With this style, multi-line match expressions remain clean and consistent:</p> <pre><code>auto out =\n    match(5)\n      .when(lit(0) &gt;&gt; \"zero\")\n      .when(lit(5) &gt;&gt; \"five\")\n      .otherwise(\"other\");\n</code></pre>"},{"location":"guide/getting-started/#basic-example","title":"Basic Example","text":"<pre><code>#include &lt;ptn/patternia.hpp&gt;\n#include &lt;iostream&gt;\nusing namespace ptn;\n\nint main() {\n  int x = 42;\n\n  auto result =\n    match(x)\n      .when(lit(0)       &gt;&gt; \"zero\")\n      .when(lit(42)      &gt;&gt; \"answer to everything\")\n      .otherwise(\"other\");\n\n  std::cout &lt;&lt; result &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>answer to everything\n</code></pre>"},{"location":"guide/getting-started/#case-insensitive-matching","title":"Case-insensitive matching","text":"<pre><code>std::string s = \"Ok\";\n\nauto out = match(s)\n  .when(lit_ci(\"OK\") &gt;&gt; \"accepted\")\n  .otherwise(\"rejected\");\n</code></pre>"},{"location":"guide/getting-started/#no-macros-no-reflection-no-magic","title":"No macros. No reflection. No magic","text":"<p>Patternia compiles down to normal C++ control flow using inlined pattern objects. There is no runtime overhead beyond executing the selected handler.</p>"},{"location":"guide/installation/","title":"Installation","text":"<p>Patternia is a header-only C++ library. There is no build system, no linking step, and no external dependency.</p> <p>You can integrate Patternia into your project in any of the following ways.</p>"},{"location":"guide/installation/#1-recommended-fetch-patternia-automatically","title":"1. Recommended: Fetch Patternia automatically","text":"<p>You may choose to fetch Patternia as a remote dependency during configuration.</p> <p>FetchContent:</p> <pre><code>include(FetchContent)\nFetchContent_Declare(patternia\n  GIT_REPOSITORY https://github.com/sentomk/patternia.git\n  GIT_TAG main\n)\nFetchContent_MakeAvailable(patternia)\n\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>CPM.cmake:</p> <pre><code>CPMAddPackage(\"gh:sentomk/patternia@main\")\n</code></pre> <p>This fits well in reproducible CI pipelines and modern CMake workflows.</p>"},{"location":"guide/installation/#2-install-and-consume-via-find_package","title":"2. Install and consume via <code>find_package()</code>","text":"<p>Patternia provides full CMake package export support.</p> <p>Install:</p> <pre><code>cmake -B build\ncmake --build build\ncmake --install build --prefix /path/to/install\n</code></pre> <p>Use in any project:</p> <pre><code>find_package(patternia REQUIRED)\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>This is the recommended method for system-wide integration, packaging, and distribution.</p>"},{"location":"guide/installation/#3-add-patternia-as-a-git-submodule","title":"3. Add Patternia as a Git submodule","text":"<pre><code>git submodule add https://github.com/sentomk/patternia extern/patternia\n</code></pre> <p>Then in your CMake project:</p> <pre><code>add_subdirectory(extern/patternia)\ntarget_link_libraries(your_target PRIVATE patternia::patternia)\n</code></pre> <p>This approach keeps Patternia version-controlled inside your repository and works well for mid- to large-scale projects.</p>"},{"location":"guide/installation/#4-include-the-include-directory-directly","title":"4. Include the <code>include/</code> directory directly","text":"<p>This is the simplest approach. Just add Patternia\u2019s header path to your target:</p> <pre><code>target_include_directories(your_target\n  PRIVATE /path/to/patternia/include\n)\n</code></pre> <p>No configuration, no installation, immediately usable.</p>"}]}